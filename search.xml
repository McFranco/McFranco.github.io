<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AJAX笔记</title>
      <link href="/2022/11/01/ajax%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/ajax%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="AJAX（Asynchronous-Javascript-And-Xml）"><a href="#AJAX（Asynchronous-Javascript-And-Xml）" class="headerlink" title="AJAX（Asynchronous Javascript And Xml）"></a>AJAX（Asynchronous Javascript And Xml）</h1><h2 id="传统请求及缺点"><a href="#传统请求及缺点" class="headerlink" title="传统请求及缺点"></a>传统请求及缺点</h2><ul><li>传统的请求都有哪些？<ul><li>直接在浏览器地址栏上输入URL。</li><li>点击超链接</li><li>提交form表单</li><li>使用JS代码发送请求<ul><li>window.open(url)</li><li>document.location.href &#x3D; url</li><li>window.location.href &#x3D; url</li><li>….</li></ul></li></ul></li><li>传统请求存在的问题<ul><li>页面全部刷新导致了用户的体验较差。</li><li>传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）</li></ul></li></ul><h2 id="AJAX概述"><a href="#AJAX概述" class="headerlink" title="AJAX概述"></a>AJAX概述</h2><ul><li>AJAX不能称为一种技术，它是多种技术的综合产物。</li><li>AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。</li><li>什么是异步，什么是同步？<ul><li>假设有t1和t2线程，t1和t2线程并发，就是异步。</li><li>假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。</li><li>AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。</li></ul></li><li>AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。</li><li>AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。</li><li>AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）</li><li>AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。</li></ul><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><ul><li><p>XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。</p></li><li><p>XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。</p></li><li><p>创建XMLHttpRequest对象</p><ul><li>&#96;&#96;&#96;javascript<br>var xhr &#x3D; new XMLHttpRequest();<pre class="line-numbers language-none"><code class="language-none">- XMLHttpRequest对象的方法| 方法                                          | 描述                                                         || :-------------------------------------------- | :----------------------------------------------------------- || abort()                                       | 取消当前请求                                                 || getAllResponseHeaders()                       | 返回头部信息                                                 || getResponseHeader()                           | 返回特定的头部信息                                           || open(*method*, *url*, *async*, *user*, *psw*) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 || send()                                        | 将请求发送到服务器，用于 GET 请求                            || send(*string*)                                | 将请求发送到服务器，用于 POST 请求                           || setRequestHeader()                            | 向要发送的报头添加标签&#x2F;值对                                  |- XMLHttpRequest对象的属性| 属性               | 描述                                                         || :----------------- | :----------------------------------------------------------- || onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 || readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 || responseText       | 以字符串返回响应数据                                         || responseXML        | 以 XML 数据返回响应数据                                      || status             | 返回请求的状态号200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot;    || statusText         | 返回状态文本（比如 &quot;OK&quot; 或 &quot;Not Found&quot;）                     |## AJAX GET请求- 发送AJAX get请求，前端代码：  &#96;&#96;&#96;html  &lt;!DOCTYPE html&gt;  &lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;      &lt;title&gt;发送ajax get请求&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;      window.onload &#x3D; function () &#123;          document.getElementById(&quot;btn&quot;).onclick &#x3D; function () &#123;              &#x2F;&#x2F;1. 创建AJAX核心对象              var xhr &#x3D; new XMLHttpRequest();              &#x2F;&#x2F;2. 注册回调函数              xhr.onreadystatechange &#x3D; function()&#123;                  if (this.readyState &#x3D;&#x3D; 4) &#123;                      if (this.status &#x3D;&#x3D; 200) &#123;                          &#x2F;&#x2F; 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。                          &#x2F;&#x2F; 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）                          &#x2F;&#x2F; innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。                          &#x2F;&#x2F; innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）                          &#x2F;&#x2F;document.getElementById(&quot;myspan&quot;).innerHTML &#x3D; this.responseText                          document.getElementById(&quot;mydiv&quot;).innerHTML &#x3D; this.responseText                          &#x2F;&#x2F; innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。                          &#x2F;&#x2F; innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。                          &#x2F;&#x2F;document.getElementById(&quot;myspan&quot;).innerText &#x3D; this.responseText                      &#125;else&#123;                          alert(this.status)                      &#125;                  &#125;              &#125;              &#x2F;&#x2F;3. 开启通道              xhr.open(&quot;GET&quot;, &quot;&#x2F;ajax&#x2F;ajaxrequest2&quot;, true)              &#x2F;&#x2F;4. 发送请求              xhr.send()          &#125;      &#125;  &lt;&#x2F;script&gt;  &lt;button id&#x3D;&quot;btn&quot;&gt;发送ajax get请求&lt;&#x2F;button&gt;  &lt;span id&#x3D;&quot;myspan&quot;&gt;&lt;&#x2F;span&gt;  &lt;div id&#x3D;&quot;mydiv&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;body&gt;  &lt;&#x2F;html&gt;</code></pre></li></ul></li><li><p>发送AJAX get请求，后端代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.ajax.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;&#x2F;** * @program: 代码 * @ClassName: AjaxRequest2Servlet * @version: 1.0 * @description: * @author: bjpowernode * @create: 2022-05-13 10:46 **&#x2F;@WebServlet(&quot;&#x2F;ajaxrequest2&quot;)public class AjaxRequest2Servlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        &#x2F;&#x2F; 设置响应的内容类型以及字符集        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);        &#x2F;&#x2F; 获取响应流        PrintWriter out &#x3D; response.getWriter();        &#x2F;&#x2F; 响应        out.print(&quot;&lt;font color&#x3D;&#39;red&#39;&gt;用户名已存在！！！&lt;&#x2F;font&gt;&quot;);    &#125;&#125;</code></pre></li><li><p>AJAX get请求如何提交数据呢？</p><ul><li>get请求提交数据是在“请求行”上提交，格式是：url?name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value….</li><li>其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。</li></ul></li></ul><h2 id="AJAX-GET请求的缓存问题"><a href="#AJAX-GET请求的缓存问题" class="headerlink" title="AJAX GET请求的缓存问题"></a>AJAX GET请求的缓存问题</h2><ul><li>对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。</li><li>什么是AJAX GET请求缓存问题呢？<ul><li>在HTTP协议中是这样规定get请求的：get请求会被缓存起来。</li><li>发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。</li></ul></li><li>POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。</li><li>GET请求缓存的优缺点：<ul><li>优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。</li><li>缺点：无法实时获取最新的服务器资源。</li></ul></li><li>浏览器什么时候会走缓存？<ul><li>第一：是一个GET请求</li><li>第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。</li></ul></li><li>如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？<ul><li>可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。</li><li>可以采用时间戳：”url?t&#x3D;” + new Date().getTime()</li><li>或者可以通过随机数：”url?t&#x3D;” + Math.random()</li><li>也可以随机数+时间戳….</li></ul></li></ul><h2 id="AJAX-POST请求"><a href="#AJAX-POST请求" class="headerlink" title="AJAX POST请求"></a>AJAX POST请求</h2><ul><li><p>AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 4. 发送AJAX POST请求xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;) &#x2F;&#x2F; 设置请求头的内容类型。模拟form表单提交数据。&#x2F;&#x2F; 获取表单中的数据var username &#x3D; document.getElementById(&quot;username&quot;).value;var password &#x3D; document.getElementById(&quot;password&quot;).value;&#x2F;&#x2F; send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。xhr.send(&quot;username&#x3D;&quot;+username+&quot;&amp;password&#x3D;&quot;+password)</code></pre></li><li><p>实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：</p><ul><li>在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名</li><li>在后端，接收到用户名，连接数据库，根据用户名去表中搜索</li><li>如果用户名已存在<ul><li>后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）</li></ul></li><li>如果用户名不存在<ul><li>后端响应消息：用户名可以使用（在前端页面以绿色字体展示）</li></ul></li></ul></li><li><p>实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。</p><ul><li>在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。</li></ul></li></ul><h2 id="基于JSON的数据交换"><a href="#基于JSON的数据交换" class="headerlink" title="基于JSON的数据交换"></a>基于JSON的数据交换</h2><ul><li><p>在WEB前端中，如何将一个json格式的字符串转换成json对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jsonStr &#x3D; &quot;&#123;\&quot;username\&quot; : \&quot;zhangsan\&quot;, \&quot;password\&quot; : \&quot;1233344\&quot;&#125;&quot;var jsonObj &#x3D; JSON.parse(jsonStr)console.log(jsonObj.username)console.log(jsonObj.password)</code></pre></li><li><p>在后端拼接JSON格式的字符串，响应给前端的浏览器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">json.append(&quot;[&quot;);while (rs.next()) &#123;    &#x2F;&#x2F; 获取每个学生的信息    String name &#x3D; rs.getString(&quot;name&quot;);    String age &#x3D; rs.getString(&quot;age&quot;);    String addr &#x3D; rs.getString(&quot;addr&quot;);    &#x2F;&#x2F; 拼接json格式的字符串    &#x2F;&#x2F; &#123;&quot;name&quot;:&quot;   王五    &quot;,&quot;age&quot;:    20      ,&quot;addr&quot;:&quot;      北京大兴区     &quot;&#125;,    json.append(&quot;&#123;\&quot;name\&quot;:\&quot;&quot;);    json.append(name);    json.append(&quot;\&quot;,\&quot;age\&quot;:&quot;);    json.append(age);    json.append(&quot;,\&quot;addr\&quot;:\&quot;&quot;);    json.append(addr);    json.append(&quot;\&quot;&#125;,&quot;);&#125;jsonStr &#x3D; json.substring(0, json.length() - 1) + &quot;]&quot;;</code></pre></li><li><p>拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Student&gt; studentList &#x3D; new ArrayList&lt;&gt;();while (rs.next()) &#123;    &#x2F;&#x2F; 取出数据    String name &#x3D; rs.getString(&quot;name&quot;);    int age &#x3D; rs.getInt(&quot;age&quot;);    String addr &#x3D; rs.getString(&quot;addr&quot;);    &#x2F;&#x2F; 将以上数据封装成Student对象    Student s &#x3D; new Student(name, age, addr);    &#x2F;&#x2F; 将Student对象放到List集合    studentList.add(s);&#125;&#x2F;&#x2F; 将List集合转换成json字符串jsonStr &#x3D; JSON.toJSONString(studentList);</code></pre><p>注意：使用fastjson需要引入fastjson-1.2.2.jar</p></li></ul><h2 id="基于XML的数据交换"><a href="#基于XML的数据交换" class="headerlink" title="基于XML的数据交换"></a>基于XML的数据交换</h2><ul><li><p>注意：如果服务器端响应XML的话，响应的内容类型需要写成：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">response.setContentType(&quot;text&#x2F;xml;charset&#x3D;UTF-8&quot;);</code></pre></li><li><p>xml和JSON都是常用的数据交换格式</p><ul><li>XML体积大，解析麻烦。较少用。</li><li>JSON体积小，解析简单，较常用。</li></ul></li><li><p>基于XML的数据交换，前端代码</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;使用XML完成数据交换&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;    window.onload &#x3D; function()&#123;        document.getElementById(&quot;btn&quot;).onclick &#x3D; function()&#123;            &#x2F;&#x2F; 1.创建XMLHTTPRequest对象            var xhr &#x3D; new XMLHttpRequest();            &#x2F;&#x2F; 2.注册回调函数            xhr.onreadystatechange &#x3D; function () &#123;                if (this.readyState &#x3D;&#x3D; 4) &#123;                    if (this.status &#x3D;&#x3D; 200) &#123;                        &#x2F;&#x2F; 服务器端响应了一个XML字符串，这里怎么接收呢？                        &#x2F;&#x2F; 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）                        var xmlDoc &#x3D; this.responseXML                        &#x2F;&#x2F;console.log(xmlDoc)                        &#x2F;&#x2F; 获取所有的&lt;student&gt;元素，返回了多个对象，应该是数组。                        var students &#x3D; xmlDoc.getElementsByTagName(&quot;student&quot;)                        &#x2F;&#x2F;console.log(students[0].nodeName)                        var html &#x3D; &quot;&quot;;                        for (var i &#x3D; 0; i &lt; students.length; i++) &#123;                            var student &#x3D; students[i]                            &#x2F;&#x2F; 获取&lt;student&gt;元素下的所有子元素                            html +&#x3D; &quot;&lt;tr&gt;&quot;                            html +&#x3D; &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;&#x2F;td&gt;&quot;                            var nameOrAge &#x3D; student.childNodes                            for (var j &#x3D; 0; j &lt; nameOrAge.length; j++) &#123;                                var node &#x3D; nameOrAge[j]                                if (node.nodeName &#x3D;&#x3D; &quot;name&quot;) &#123;                                    &#x2F;&#x2F;console.log(&quot;name &#x3D; &quot; + node.textContent)                                    html +&#x3D; &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;&#x2F;td&gt;&quot;                                &#125;                                if (node.nodeName &#x3D;&#x3D; &quot;age&quot;) &#123;                                    &#x2F;&#x2F;console.log(&quot;age &#x3D; &quot; + node.textContent)                                    html +&#x3D; &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;&#x2F;td&gt;&quot;                                &#125;                            &#125;                            html +&#x3D; &quot;&lt;&#x2F;tr&gt;&quot;                        &#125;                        document.getElementById(&quot;stutbody&quot;).innerHTML &#x3D; html                    &#125;else&#123;                        alert(this.status)                    &#125;                &#125;            &#125;            &#x2F;&#x2F; 3.开启通道            xhr.open(&quot;GET&quot;, &quot;&#x2F;ajax&#x2F;ajaxrequest6?t&#x3D;&quot; + new Date().getTime(), true)            &#x2F;&#x2F; 4.发送请求            xhr.send()        &#125;    &#125;&lt;&#x2F;script&gt;&lt;button id&#x3D;&quot;btn&quot;&gt;显示学生列表&lt;&#x2F;button&gt;&lt;table width&#x3D;&quot;500px&quot; border&#x3D;&quot;1px&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;序号&lt;&#x2F;th&gt;        &lt;th&gt;姓名&lt;&#x2F;th&gt;        &lt;th&gt;年龄&lt;&#x2F;th&gt;    &lt;&#x2F;tr&gt;    &lt;&#x2F;thead&gt;    &lt;tbody id&#x3D;&quot;stutbody&quot;&gt;    &lt;!--&lt;tr&gt;        &lt;td&gt;1&lt;&#x2F;td&gt;        &lt;td&gt;zhangsan&lt;&#x2F;td&gt;        &lt;td&gt;20&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;2&lt;&#x2F;td&gt;        &lt;td&gt;lisi&lt;&#x2F;td&gt;        &lt;td&gt;22&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;--&gt;    &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></li><li><p>基于XML的数据交换，后端java程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.ajax.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;&#x2F;** * @program: 代码 * @ClassName: AjaxRequest6Servlet * @version: 1.0 * @description: 服务器端返回XML字符串 * @author: bjpowernode * @create: 2022-05-15 11:48 **&#x2F;@WebServlet(&quot;&#x2F;ajaxrequest6&quot;)public class AjaxRequest6Servlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        &#x2F;&#x2F; 注意：响应的内容类型是XML。        response.setContentType(&quot;text&#x2F;xml;charset&#x3D;UTF-8&quot;);        PrintWriter out &#x3D; response.getWriter();        &#x2F;*        &lt;students&gt;            &lt;student&gt;                &lt;name&gt;zhangsan&lt;&#x2F;name&gt;                &lt;age&gt;20&lt;&#x2F;age&gt;            &lt;&#x2F;student&gt;            &lt;student&gt;                &lt;name&gt;lisi&lt;&#x2F;name&gt;                &lt;age&gt;22&lt;&#x2F;age&gt;            &lt;&#x2F;student&gt;        &lt;&#x2F;students&gt;         *&#x2F;        StringBuilder xml &#x3D; new StringBuilder();        xml.append(&quot;&lt;students&gt;&quot;);        xml.append(&quot;&lt;student&gt;&quot;);        xml.append(&quot;&lt;name&gt;zhangsan&lt;&#x2F;name&gt;&quot;);        xml.append(&quot;&lt;age&gt;20&lt;&#x2F;age&gt;&quot;);        xml.append(&quot;&lt;&#x2F;student&gt;&quot;);        xml.append(&quot;&lt;student&gt;&quot;);        xml.append(&quot;&lt;name&gt;lisi&lt;&#x2F;name&gt;&quot;);        xml.append(&quot;&lt;age&gt;22&lt;&#x2F;age&gt;&quot;);        xml.append(&quot;&lt;&#x2F;student&gt;&quot;);        xml.append(&quot;&lt;&#x2F;students&gt;&quot;);        out.print(xml);    &#125;&#125;</code></pre></li></ul><h2 id="AJAX乱码问题"><a href="#AJAX乱码问题" class="headerlink" title="AJAX乱码问题"></a>AJAX乱码问题</h2><ul><li><p>测试内容：</p><ul><li>发送ajax get请求<ul><li>发送数据到服务器，服务器获取的数据是否乱码？</li><li>服务器响应给前端的中文，会不会乱码？</li></ul></li><li>发送ajax post请求<ul><li>发送数据到服务器，服务器获取的数据是否乱码？</li><li>服务器响应给前端的中文，会不会乱码？</li></ul></li></ul></li><li><p>包括还要测试tomcat服务器的版本：</p><ul><li>tomcat10和tomcat9都要进行测试。</li></ul></li><li><p>测试结果：</p><ul><li><p>对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。</p></li><li><p>对于tomcat9来说呢？</p><ul><li><p>响应中文的时候，会出现乱码，怎么解决？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</code></pre></li><li><p>发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">request.setCharacterEncoding(&quot;UTF-8&quot;);</code></pre></li></ul></li></ul></li></ul><h2 id="AJAX的异步与同步"><a href="#AJAX的异步与同步" class="headerlink" title="AJAX的异步与同步"></a>AJAX的异步与同步</h2><ul><li><p>什么是异步？什么是同步？</p><ul><li>ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）</li><li>如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）</li></ul></li><li><p>异步和同步在代码上如何实现？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 假设这个是ajax请求1&#x2F;&#x2F; 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。&#x2F;&#x2F; false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。xhr1.open(&quot;请求方式&quot;, &quot;URL&quot;, false)xhr1.send()&#x2F;&#x2F; 假设这个是ajax请求2&#x2F;&#x2F; 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。xhr2.open(&quot;请求方式&quot;, &quot;URL&quot;, true) xhr2.send()</code></pre></li><li><p>什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）</p><ul><li>举一个例子<ul><li>用户注册<ul><li>用户名需要发送ajax请求进行校验</li><li>邮箱地址也需要发送ajax请求校验</li><li>其他的也可能需要发送ajax请求。。。</li><li>并且最终注册按钮的时候，也是发送ajax请求进行注册。</li><li>那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。</li></ul></li></ul></li></ul></li></ul><h2 id="AJAX代码封装"><a href="#AJAX代码封装" class="headerlink" title="AJAX代码封装"></a>AJAX代码封装</h2><ul><li><p>AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。</p></li><li><p>接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）</p></li><li><p>手动开发jQuery，源代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function jQuery(selector)&#123;    if (typeof selector &#x3D;&#x3D; &quot;string&quot;) &#123;        if (selector.charAt(0) &#x3D;&#x3D; &quot;#&quot;) &#123;            domObj &#x3D; document.getElementById(selector.substring(1))            return new jQuery()        &#125;    &#125;    if (typeof selector &#x3D;&#x3D; &quot;function&quot;) &#123;        window.onload &#x3D; selector    &#125;    this.html &#x3D; function(htmlStr)&#123;        domObj.innerHTML &#x3D; htmlStr    &#125;    this.click &#x3D; function(fun)&#123;        domObj.onclick &#x3D; fun    &#125;    this.focus &#x3D; function (fun)&#123;        domObj.onfocus &#x3D; fun    &#125;    this.blur &#x3D; function(fun) &#123;        domObj.onblur &#x3D; fun    &#125;    this.change &#x3D; function (fun)&#123;        domObj.onchange &#x3D; fun    &#125;    this.val &#x3D; function(v)&#123;        if (v &#x3D;&#x3D; undefined) &#123;            return domObj.value        &#125;else&#123;            domObj.value &#x3D; v        &#125;    &#125;    &#x2F;&#x2F; 静态的方法，发送ajax请求    &#x2F;**     * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？     *      请求的方式(type)：GET&#x2F;POST     *      请求的URL(url)：url     *      请求时提交的数据(data)：data     *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。     *&#x2F;    jQuery.ajax &#x3D; function(jsonArgs)&#123;        &#x2F;&#x2F; 1.        var xhr &#x3D; new XMLHttpRequest();        &#x2F;&#x2F; 2.        xhr.onreadystatechange &#x3D; function()&#123;            if (this.readyState &#x3D;&#x3D; 4) &#123;                if (this.status &#x3D;&#x3D; 200) &#123;                    &#x2F;&#x2F; 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。                    var jsonObj &#x3D; JSON.parse(this.responseText)                    &#x2F;&#x2F; 调用函数                    jsonArgs.success(jsonObj)                &#125;            &#125;        &#125;        if (jsonArgs.type.toUpperCase() &#x3D;&#x3D; &quot;POST&quot;) &#123;            &#x2F;&#x2F; 3.            xhr.open(&quot;POST&quot;, jsonArgs.url, jsonArgs.async)            &#x2F;&#x2F; 4.            xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;)            xhr.send(jsonArgs.data)        &#125;        if (jsonArgs.type.toUpperCase() &#x3D;&#x3D; &quot;GET&quot;) &#123;            xhr.open(&quot;GET&quot;, jsonArgs.url + &quot;?&quot; + jsonArgs.data, jsonArgs.async)            xhr.send()        &#125;    &#125;&#125;$ &#x3D; jQuery&#x2F;&#x2F; 这里有个细节，执行这个目的是为了让静态方法ajax生效。new jQuery()</code></pre></li><li><p>使用以上库，怎么用？</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;ajax&#x2F;js&#x2F;jQuery-1.0.0.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;    $(function()&#123;        $(&quot;#btn1&quot;).click(function()&#123;            $.ajax(&#123;                type : &quot;POST&quot;,                url : &quot;&#x2F;ajax&#x2F;ajaxrequest11&quot;,                data : &quot;username&#x3D;&quot; + $(&quot;#username&quot;).val(),                async : true,                success : function(json)&#123;                    $(&quot;#div1&quot;).html(json.uname)                &#125;            &#125;)        &#125;)    &#125;)&lt;&#x2F;script&gt;</code></pre></li></ul><h2 id="AJAX实现省市联动"><a href="#AJAX实现省市联动" class="headerlink" title="AJAX实现省市联动"></a>AJAX实现省市联动</h2><ul><li><p>什么是省市联动？</p><ul><li>在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）</li></ul></li><li><p>进行数据库表的设计</p><ul><li><p>&#96;&#96;&#96;<br>t_area （区域表）</p><h2 id="id-PK-自增-codenamepcode"><a href="#id-PK-自增-codenamepcode" class="headerlink" title="id(PK-自增)  codenamepcode"></a>id(PK-自增)  codenamepcode</h2><p>1001 河北省null<br>2002 河南省null<br>3003 石家庄    001<br>4004 邯郸 001<br>5005 郑州 002<br>6006 洛阳 002<br>7007 丛台区    004  </p><p>将全国所有的省、市、区、县等信息都存储到一张表当中。<br>采用的存储方式实际上是code pcode形势。</p><pre class="line-numbers language-none"><code class="language-none">- 建表t_area，模拟好数据。- 首先实现第一个功能：  - 页面加载完毕之后，先把省份全部展现出来。## AJAX跨域问题### 跨域- 跨域是指从一个域名的网页去请求另一个域名的资源。比如从百度(https:&#x2F;&#x2F;baidu.com)页面去请求京东(https:&#x2F;&#x2F;www.jd.com)的资源。- 通过超链接或者form表单提交或者window.location.href的方式进行跨域是不存在问题的（**大家可以编写程序测试一下**）。但在一个域名的网页中的一段js代码发送ajax请求去访问另一个域名中的资源，由于同源策略的存在导致无法跨域访问，那么ajax就存在这种跨域问题。- 同源策略是指一段脚本只能读取来自同一来源的窗口和文档的属性，同源就是协议、域名和端口都相同。- 同源策略有什么用？如果你刚刚在网银输入账号密码，查看了自己还有1万块钱，紧接着访问一些不规矩的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。所以，从安全的角度来讲，同源策略是有利于保护网站信息的。- 有一些情况下，我们是需要使用ajax进行跨域访问的。比如某公司的A页面(a.bjpowernode.com)有可能需要获取B页面(b.bjpowernode.com)。### 同源还是不同源- 区分同源和不同源的三要素- - 协议  - 域名  - 端口- 协议一致，域名一致，端口号一致，三个要素都一致，才是同源，其它一律都是不同源| **URL1**                           | **URL2**                        | **是否同源** | 描述               || ---------------------------------- | ------------------------------- | ------------ | ------------------ || http:&#x2F;&#x2F;localhost:8080&#x2F;a&#x2F;index.html | http:&#x2F;&#x2F;localhost:8080&#x2F;a&#x2F;first   | 同源         | 协议 域名 端口一致 || http:&#x2F;&#x2F;localhost:8080&#x2F;a&#x2F;index.html | http:&#x2F;&#x2F;localhost:8080&#x2F;b&#x2F;first   | 同源         | 协议 域名 端口一致 || http:&#x2F;&#x2F;www.myweb.com:8080&#x2F;a.js     | https:&#x2F;&#x2F;www.myweb.com:8080&#x2F;b.js | 不同源       | 协议不同           || http:&#x2F;&#x2F;www.myweb.com:8080&#x2F;a.js     | http:&#x2F;&#x2F;www.myweb.com:8081&#x2F;b.js  | 不同源       | 端口不同           || http:&#x2F;&#x2F;www.myweb.com&#x2F;a.js          | http:&#x2F;&#x2F;www.myweb2.com&#x2F;b.js      | 不同源       | 域名不同           || http:&#x2F;&#x2F;www.myweb.com&#x2F;a.js          | http:&#x2F;&#x2F;crm.myweb.com&#x2F;b.js       | 不同源       | 子域名不同         |### 复现AJAX跨域问题### AJAX跨域解决方案#### 方案1：设置响应头- 核心原理：跨域访问的资源允许你跨域访问。- 实现：  - &#96;&#96;&#96;java    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http:&#x2F;&#x2F;localhost:8080&quot;); &#x2F;&#x2F; 允许某个    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); &#x2F;&#x2F; 允许所有</code></pre></li></ul></li></ul><h4 id="方案2：jsonp"><a href="#方案2：jsonp" class="headerlink" title="方案2：jsonp"></a>方案2：jsonp</h4><ul><li>jsonp：json with padding（带填充的json【学完之后再理解这个什么意思！！！】）</li><li>jsonp不是一个真正的ajax请求。只不过可以完成ajax的局部刷新效果。可以说jsonp是一种类ajax请求的机制。</li><li>jsonp不是ajax请求，但是可以完成局部刷新的效果，并且可以解决跨域问题。</li><li>注意：jsonp解决跨域的时候，只支持GET请求。不支持post请求。</li></ul><h4 id="方案3：jQuery封装的jsonp"><a href="#方案3：jQuery封装的jsonp" class="headerlink" title="方案3：jQuery封装的jsonp"></a>方案3：jQuery封装的jsonp</h4><ul><li><p>牛人们写的jQuery库，已经对jsonp进行了封装。大家可以直接拿来用。</p></li><li><p>用之前需要引入jQuery库的js文件。（这里的jQuery库咱们就不再封装了，咱们直接用jQuery写好的jsonp方式。）</p></li><li><p>jQuery中的jsonp其实就是我们方案2的高度封装，底层原理完全相同。</p></li><li><p>核心代码</p><ul><li><pre><code class="javascript">$.ajax(&#123;    type : &quot;GET&quot;,    url : &quot;跨域的url&quot;,    dataType : &quot;jsonp&quot;, // 指定数据类型    jsonp : &quot;fun&quot;, // 指定参数名（不设置的时候，默认是：&quot;callback&quot;）    jsonpCallback : &quot;sayHello&quot; // 指定回调函数的名字                               // （不设置的时候，jQuery会自动生成一个随机的回调函数，                               //并且这个回调函数还会自动调用success的回调函数。）&#125;)</code></pre></li></ul></li></ul><h4 id="方案4：代理机制（httpclient）"><a href="#方案4：代理机制（httpclient）" class="headerlink" title="方案4：代理机制（httpclient）"></a>方案4：代理机制（httpclient）</h4><ul><li>使用Java程序怎么去发送get&#x2F;post请求呢？【GET和POST请求就是HTTP请求。】<ul><li>第一种方案：使用JDK内置的API（java.net.URL…..），这些API是可以发送HTTP请求的。</li><li>第二种方案：使用第三方的开源组件，比如：apache的httpclient组件。（httpclient组件是开源免费的，可以直接用）</li></ul></li><li>在java程序中，使用httpclient组件可以发送http请求。<ul><li>对于httpclient组件的代码，大家目前可以不进行深入的研究，可以从网上直接搜。然后粘贴过来，改一改，看看能不能完成发送get和post请求。</li><li>使用httpclient组件，需要先将这个组件相关的jar包引入到项目当中。</li></ul></li></ul><h4 id="方案5：nginx反向代理"><a href="#方案5：nginx反向代理" class="headerlink" title="方案5：nginx反向代理"></a>方案5：nginx反向代理</h4><ul><li>nginx反向代理中也是使用了这种代理机制来完成AJAX的跨域，实现起来非常简单，只要修改一个nginx的配置即可。以后大家学习nginx之后再说吧。！！！！</li></ul><h2 id="AJAX实现搜索联想-自动补全"><a href="#AJAX实现搜索联想-自动补全" class="headerlink" title="AJAX实现搜索联想 自动补全"></a>AJAX实现搜索联想 自动补全</h2><ul><li>什么是搜索联想？自动补全？<ul><li>百度是一个很典型的代表。在百度的搜索框中输入相关信息的时候，会有搜索联想以及自动补全。</li><li>搜索联想和自动补全：实际上是为了方便用户的使用。让用户的体验更好。</li><li>搜索联想：当用户输入一些单词之后，自动联想出用户要搜索的信息，给一个提示。</li><li>自动补全：当联想出一些内容之后，用户点击某个联想的单词，然后将这个单词自动补全到搜索框当中。</li><li>搜索联想和自动补全功能，因为是页面局部刷新效果，所以需要使用ajax请求来完成。</li></ul></li><li>搜索联想，自动补全功能的核心实现原理？<ul><li>当键盘事件发生之后，比如：keyup：键弹起事件。</li><li>发送ajax请求，请求中提交用户输入的搜索内容，例如：北京（发送ajax请求，携带“北京”两个字）</li><li>后端接收到ajax请求，接收到“北京”两个字，执行select语句进行模糊查询。返回查询结果。</li><li>将查询结果封装成json格式的字符串，将json格式的字符串响应到前端。</li><li>前端接收到json格式的字符串之后，解析这个json字符串，动态展示页面。</li></ul></li></ul><h2 id="附录：HTTP状态信息"><a href="#附录：HTTP状态信息" class="headerlink" title="附录：HTTP状态信息"></a>附录：HTTP状态信息</h2><h3 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx: 信息"></a>1xx: 信息</h3><table><thead><tr><th align="left">消息:</th><th align="left">描述:</th></tr></thead><tbody><tr><td align="left">100 Continue</td><td align="left">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td></tr><tr><td align="left">101 Switching Protocols</td><td align="left">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td></tr></tbody></table><h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx: 成功"></a>2xx: 成功</h3><table><thead><tr><th align="left">消息:</th><th align="left">描述:</th></tr></thead><tbody><tr><td align="left">200 OK</td><td align="left">请求成功（其后是对GET和POST请求的应答文档。）</td></tr><tr><td align="left">201 Created</td><td align="left">请求被创建完成，同时新的资源被创建。</td></tr><tr><td align="left">202 Accepted</td><td align="left">供处理的请求已被接受，但是处理未完成。</td></tr><tr><td align="left">203 Non-authoritative Information</td><td align="left">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td></tr><tr><td align="left">204 No Content</td><td align="left">没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td></tr><tr><td align="left">205 Reset Content</td><td align="left">没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td></tr><tr><td align="left">206 Partial Content</td><td align="left">客户发送了一个带有Range头的GET请求，服务器完成了它。</td></tr></tbody></table><h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h3><table><thead><tr><th align="left">消息:</th><th align="left">描述:</th></tr></thead><tbody><tr><td align="left">300 Multiple Choices</td><td align="left">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td></tr><tr><td align="left">301 Moved Permanently</td><td align="left">所请求的页面已经转移至新的url。</td></tr><tr><td align="left">302 Found</td><td align="left">所请求的页面已经临时转移至新的url。</td></tr><tr><td align="left">303 See Other</td><td align="left">所请求的页面可在别的url下被找到。</td></tr><tr><td align="left">304 Not Modified</td><td align="left">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td></tr><tr><td align="left">305 Use Proxy</td><td align="left">客户请求的文档应该通过Location头所指明的代理服务器提取。</td></tr><tr><td align="left">306 <em>Unused</em></td><td align="left">此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td></tr><tr><td align="left">307 Temporary Redirect</td><td align="left">被请求的页面已经临时移至新的url。</td></tr></tbody></table><h3 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h3><table><thead><tr><th align="left">消息:</th><th align="left">描述:</th></tr></thead><tbody><tr><td align="left">400 Bad Request</td><td align="left">服务器未能理解请求。</td></tr><tr><td align="left">401 Unauthorized</td><td align="left">被请求的页面需要用户名和密码。</td></tr><tr><td align="left">402 Payment Required</td><td align="left">此代码尚无法使用。</td></tr><tr><td align="left">403 Forbidden</td><td align="left">对被请求页面的访问被禁止。</td></tr><tr><td align="left">404 Not Found</td><td align="left">服务器无法找到被请求的页面。</td></tr><tr><td align="left">405 Method Not Allowed</td><td align="left">请求中指定的方法不被允许。</td></tr><tr><td align="left">406 Not Acceptable</td><td align="left">服务器生成的响应无法被客户端所接受。</td></tr><tr><td align="left">407 Proxy Authentication Required</td><td align="left">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td></tr><tr><td align="left">408 Request Timeout</td><td align="left">请求超出了服务器的等待时间。</td></tr><tr><td align="left">409 Conflict</td><td align="left">由于冲突，请求无法被完成。</td></tr><tr><td align="left">410 Gone</td><td align="left">被请求的页面不可用。</td></tr><tr><td align="left">411 Length Required</td><td align="left">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td></tr><tr><td align="left">412 Precondition Failed</td><td align="left">请求中的前提条件被服务器评估为失败。</td></tr><tr><td align="left">413 Request Entity Too Large</td><td align="left">由于所请求的实体的太大，服务器不会接受请求。</td></tr><tr><td align="left">414 Request-url Too Long</td><td align="left">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td></tr><tr><td align="left">415 Unsupported Media Type</td><td align="left">由于媒介类型不被支持，服务器不会接受请求。</td></tr><tr><td align="left">416</td><td align="left">服务器不能满足客户在请求中指定的Range头。</td></tr><tr><td align="left">417 Expectation Failed</td><td align="left"></td></tr></tbody></table><h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx: 服务器错误"></a>5xx: 服务器错误</h3><table><thead><tr><th align="left">消息:</th><th align="left">描述:</th></tr></thead><tbody><tr><td align="left">500 Internal Server Error</td><td align="left">请求未完成。服务器遇到不可预知的情况。</td></tr><tr><td align="left">501 Not Implemented</td><td align="left">请求未完成。服务器不支持所请求的功能。</td></tr><tr><td align="left">502 Bad Gateway</td><td align="left">请求未完成。服务器从上游服务器收到一个无效的响应。</td></tr><tr><td align="left">503 Service Unavailable</td><td align="left">请求未完成。服务器临时过载或当机。</td></tr><tr><td align="left">504 Gateway Timeout</td><td align="left">网关超时。</td></tr><tr><td align="left">505 HTTP Version Not Supported</td><td align="left">服务器不支持请求中指明的HTTP协议版本。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC笔记</title>
      <link href="/2022/11/01/springmvc%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/springmvc%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.什么是SpringMVC<br>  它是基于MVC开发模式的框架,用来优化控制器.它是Spring家族的一员.它也具备IOC和AOP.</p><p>  什么是MVC?<br>  它是一种开发模式,它是模型视图控制器的简称.所有的web应用都是基于MVC开发.<br>  M:模型层,包含实体类,业务逻辑层,数据访问层<br>  V:视图层,html,javaScript,vue等都是视图层,用来显现数据<br>  C:控制器,它是用来接收客户端的请求,并返回响应到客户端的组件,Servlet就是组件</p><p>2.SpringMVC框架的优点<br>  1)轻量级,基于MVC的框架<br>  2)易于上手,容易理解,功能强大<br>  3)它具备IOC和AOP<br>  4)完全基于注解开发</p><p>3.基于注解的SpringMVC框架开发的步骤<br>  1)新建项目,选择webapp模板.<br>  2)修改目录,添加缺失的test,java,resources(两套),并修改目录属性<br>  3)修改pom.xml文件,添加SpringMVC的依赖,添加Servlet的依赖<br>    <dependency><br>      <groupId>org.springframework</groupId><br>      <artifactId>spring-webmvc</artifactId><br>      <version>5.2.5.RELEASE</version><br>    </dependency><br>    <!--添加servlet的依赖--><br>    <dependency><br>      <groupId>javax.servlet</groupId><br>      <artifactId>javax.servlet-api</artifactId><br>      <version>3.1.0</version><br>    </dependency><br>  4)添加springmvc.xml配置文件,指定包扫描,添加视图解析器.<br>    <!--添加包扫描--><br>    &lt;context:component-scan base-package&#x3D;”com.bjpowernode.controller”&gt;</context:component-scan><br>    <!--添加视图解析器--><br>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"><br>        <!--配置前缀--><br>        <property name="prefix" value="/admin/"></property><br>        <!--配置后缀--><br>        <property name="suffix" value=".jsp"></property><br>    </bean><br>  5)删除web.xml文件,新建web.xml<br>  6)在web.xml文件中注册springMVC框架(所有的web请求都是基于servlet的)<br>    <!--注册SpringMVC框架--><br>    <servlet><br>        <servlet-name>springmvc</servlet-name><br>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><br>        <init-param><br>            <param-name>contextConfigLocation</param-name><br>            <param-value>classpath:springmvc.xml</param-value><br>        </init-param><br>    </servlet><br>    <servlet-mapping><br>        <servlet-name>springmvc</servlet-name><br>        <!--          指定拦截什么样的请求          http://localhost:8080/one          http://localhost:8080/index.jsp          http://localhost:8080/demo.action          <a href="${pageContext.request.contextPath}/demo.action">访问服务器</a>        --><br>        <url-pattern><em>.action</url-pattern><br>    </servlet-mapping><br>  7)在webapp目录下新建admin目录,在admin目录下新建main.jsp页面,删除index.jsp页面,并新建,发送请求给服务器<br>  8)开发控制器(Servlet),它是一个普通的类.<br>      @Controller  &#x2F;&#x2F;交给Spring去创建对象<br>    public class DemoAction {<br>        &#x2F;</em>*<br>         * 以前的Servlet的规范<br>         * protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}<br>         * action中所有的功能实现都是由方法来完成的<br>         * action方法的规范<br>         * 1)访问权限是public<br>         * 2)方法的返回值任意<br>         * 3)方法名称任意<br>         * 4)方法可以没有参数,如果有可是任意类型<br>         * 5)要使用@RequestMapping注解来声明一个访问的路径(名称)<br>         *<br>         *&#x2F;<br>        @RequestMapping(“&#x2F;demo”)<br>        public String demo(){<br>            System.out.println(“服务器被访问到了…….”);<br>            return “main”;  &#x2F;&#x2F;可以直接跳到&#x2F;admin&#x2F;main.jsp页面上<br>        }<br>    }<br>  9)添加tomcat进行测试功能</p><p>4.分析web请求<br>  web请求执行的流程<br>                                  核心处理器<br>  index.jsp&lt;—————&gt;DispatcherServlet&lt;——————-&gt;SpringMVC的处理器是一个普通的方法<br>  one.jsp  &lt;—————&gt;DispatcherServlet&lt;——————-&gt;SpringMVC的处理器是一个普通的方法</p><p>  DispatcherServlet要在web.xml文件中注册才可用.</p><p>5.@RequestMapping注解详解<br>  此注解就是来映射服务器访问的路径.<br>  1)此注解可加在方法上,是为此方法注册一个可以访问的名称(路径)<br>  @RequestMapping(“&#x2F;demo”)<br>    public String demo(){<br>        System.out.println(“服务器被访问到了…….”);<br>        return “main”;  &#x2F;&#x2F;可以直接跳到&#x2F;admin&#x2F;main.jsp页面上<br>    }<br>  <a href="${pageContext.request.contextPath}/demo.action">访问服务器</a></p><p>  2)此注解可以加在类上,相当于是包名(虚拟路径),区分不同类中相同的action的名称<br>  @RequestMapping(“&#x2F;user”)<br>  public class DemoAction1 {..}<br>  <a href="${pageContext.request.contextPath}/user/demo.action">访问服务器</a></p><p>  3)此注解可区分get请求和post请求<br>  @Controller<br>    public class ReqAction {<br>        @RequestMapping(value &#x3D; “&#x2F;req”,method &#x3D; RequestMethod.GET)<br>        public String req(){<br>            System.out.println(“我是处理get请求的……..”);<br>            return “main”;<br>        }<br>        @RequestMapping(value &#x3D; “&#x2F;req” ,method &#x3D; RequestMethod.POST)<br>        public String req1(){<br>            System.out.println(“我是处理post请求的……..”);<br>            return “main”;<br>        }<br>    }<br>6.五种数据提交方式的优化<br>  1)单个提交数据<br>  页面:<br>  <form action="${pageContext.request.contextPath}/one.action"><br>      姓名:<input name="myname"><br><br>      年龄:<input name="age"><br><br>      <input type="submit" value="提交"><br>  </form><br>  action:<br>  @RequestMapping(“&#x2F;one”)<br>    public String one(String myname,int age){  &#x3D;&#x3D;&#x3D;&gt;自动注入,并且类型转换<br>        System.out.println(“myname&#x3D;”+myname+”,age&#x3D;”+(age+100));<br>        return “main”;<br>    }<br>  2)对象封装提交数据<br>    在提交请求中,保证请求参数的名称与实体类中成员变量的名称一致,则可以自动创建对象,则可以自动提交数据,自动类型转换,自动封装数据到对象中.<br>    实体类:<br>    public class Users {<br>    private String name;<br>    private int age;}<br>    页面:<br>    <form action="${pageContext.request.contextPath}/two.action" method="post"><br>        姓名:<input name="name"><br><br>        年龄:<input name="age"><br><br>        <input type="submit" value="提交"><br>    </form><br>    action:<br>    @RequestMapping(“&#x2F;two”)<br>    public String two(Users u){<br>        System.out.println(u);<br>        return “main”;<br>    }<br>  3)动态占位符提交<br>    仅限于超链接或地址拦提交数据.它是一杠一值,一杠一大括号,使用注解@PathVariable来解析.<br>    <a href="${pageContext.request.contextPath}/three/张三/22.action">动态提交</a><br>    @RequestMapping(“&#x2F;three&#x2F;{uname}&#x2F;{uage}”)<br>    public String three(<br>            @PathVariable(“uname”)  &#x3D;&#x3D;&#x3D;&gt;用来解析路径中的请求参数<br>            String name,<br>            @PathVariable(“uage”)<br>            int age){<br>        System.out.println(“name&#x3D;”+name+”,age&#x3D;”+(age+100));<br>        return “main”;<br>    }<br>  4)映射名称不一致<br>    提交请求参数与action方法的形参的名称不一致,使用注解@RequestParam来解析<br>    &#x2F;**<br>     *  姓名:<input name="name"><br><br>     *  年龄:<input name="age"><br><br>     <em>&#x2F;<br>    @RequestMapping(“&#x2F;four”)<br>    public String four(<br>            @RequestParam(“name”)  &#x3D;&#x3D;&#x3D;&gt;专门用来解决名称不一致的问题<br>            String uname,<br>            @RequestParam(“age”)<br>            int uage){<br>        System.out.println(“uname&#x3D;”+uname+”,uage&#x3D;”+(uage+100));<br>        return “main”;<br>    }<br>  5)手工提取数据<br>  &#x2F;</em>*<br>     *  姓名:<input name="name"><br><br>     *  年龄:<input name="age"><br><br>     <em>&#x2F;<br>  @RequestMapping(“&#x2F;five”)<br>    public String five(HttpServletRequest request){<br>        String name &#x3D; request.getParameter(“name”);<br>        int age &#x3D; Integer.parseInt(request.getParameter(“age”));<br>        System.out.println(“name&#x3D;”+name+”,age&#x3D;”+(age+100));<br>        return “main”;<br>    }<br>7.中文乱码解决方案<br>  配置过滤器.<br>  <filter><br>        <filter-name>encode</filter-name><br>        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class><br>        <!--          配置参数            private String encoding;            private boolean forceRequestEncoding;            private boolean forceResponseEncoding;        --><br>        <init-param><br>            <param-name>encoding</param-name><br>            <param-value>UTF-8</param-value><br>        </init-param><br>        <init-param><br>            <param-name>forceRequestEncoding</param-name><br>            <param-value>true</param-value><br>        </init-param><br>        <init-param><br>            <param-name>forceResponseEncoding</param-name><br>            <param-value>true</param-value><br>        </init-param><br>    </filter><br>    <filter-mapping><br>        <filter-name>encode</filter-name><br>        <url-pattern>&#x2F;</em></url-pattern><br>    </filter-mapping> </p><p>8.action方法的返回值<br>  1)String:客户端资源的地址,自动拼接前缀和后缀.还可以屏蔽自动拼接字符串,可以指定返回的路径.<br>  2)Object:返回json格式的对象.自动将对象或集合转为json.使用的jackson工具进行转换,必须要添加jackson依赖.一般用于ajax请求.<br>  3)void:无返回值,一般用于ajax请求.<br>  4)基本数据类型,用于ajax请求.<br>  5)ModelAndView:返回数据和视图对象,现在用的很少.</p><p>9.完成ajax请求访问服务器,返回学生集合.<br>  1)添加jackson依赖<br>     <dependency><br>      <groupId>com.fasterxml.jackson.core</groupId><br>      <artifactId>jackson-databind</artifactId><br>      <version>2.9.8</version><br>    </dependency><br>  2)在webapp目录下新建js目录,添加jQuery函数库<br>  3)在index.jsp页面上导入函数库<br>  function show() {<br>        $.ajax({<br>            url:”${pageContext.request.contextPath}&#x2F;ajax.action”,<br>            dataType:”json”,<br>            type:”get”,<br>            success:function (list) {<br>              &#x2F;&#x2F;  alert(list);<br>                var s&#x3D;””;<br>                $.each(list,function (i,stu) {<br>                  &#x2F;&#x2F;  alert(stu);<br>                    s+&#x3D;stu.name+”—-“+stu.age+”<br>“;<br>                });<br>                $(“#mydiv”).html(s);</p><pre><code>        &#125;    &#125;);&#125;</code></pre><p>  4)在action上添加注解@ResponseBody,用来处理ajax请求<br>    @Controller<br>    public class AjaxAction {<br>        &#x2F;&#x2F;处理ajax请求,一定要加@ResponseBody<br>        @ResponseBody<br>        @RequestMapping(“&#x2F;ajax”)<br>        public List<Student> ajax(){<br>            Student stu1 &#x3D; new Student(“张三”,22);<br>            Student stu2 &#x3D; new Student(“李四”,24);<br>            Student stu3 &#x3D; new Student(“王五”,23);<br>           List<Student> list &#x3D; new ArrayList&lt;&gt;();<br>           list.add(stu1);<br>           list.add(stu2);<br>           list.add(stu3);<br>            &#x2F;&#x2F;调用json转换工具ObjectMapper进行转换<br>            return list;  &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&gt;springmvc负责转换成json<br>        }<br>    }<br>  5)在springmvc.xml文件中添加注解驱动<a href="mvc:annotationdriven/">mvc:annotationdriven/</a>,它用来解析@ResponseBody注解<br>  <a href="mvc:annotation-driven">mvc:annotation-driven</a></mvc:annotation-driven></p><p>10.四种跳转方式<br>  本质还是两种跳转:请求转发和重定向,衍生出四种是请求转发页面,转发action,重定向页面,重定向action<br>  @RequestMapping(“&#x2F;one”)<br>    public String one(){<br>        System.out.println(“这是请求转发页面跳转………”);<br>        return “main”;  &#x2F;&#x2F;默认是请求转发,使用视图解析器拼接前缀后缀进行页面跳转<br>    }</p><pre><code>@RequestMapping(&quot;/two&quot;)public String two()&#123;    System.out.println(&quot;这是请求转发action跳转.........&quot;);    //  /admin/  /other.action  .jsp    //forward: 这组字符串可以屏蔽前缀和后缀的拼接.实现请求转发跳转    return &quot;forward:/other.action&quot;;  //默认是请求转发,使用视图解析器拼接前缀后缀进行页面跳转&#125;@RequestMapping(&quot;/three&quot;)public String three()&#123;    System.out.println(&quot;这是重定向页面.......&quot;);    //redirect:  这组字符串可以屏蔽前缀和后缀的拼接.实现重定向跳转    return &quot;redirect:/admin/main.jsp&quot;;&#125;@RequestMapping(&quot;/four&quot;)public String four()&#123;    System.out.println(&quot;这是重定向action.......&quot;);    //redirect:  这组字符串可以屏蔽前缀和后缀的拼接.实现重定向跳转    return &quot;redirect:/other.action&quot;;&#125;@RequestMapping(&quot;/five&quot;)public String five()&#123;    System.out.println(&quot;这是随便跳.......&quot;);    return &quot;forward:/fore/login.jsp&quot;;&#125;</code></pre><p>11.SpringMVC默认的参数类型<br>  不需要去创建,直接拿来使用即可.<br>  1)HttpServletRequest<br>  2)HttpServletResponse<br>  3)HttpSession<br>  4)Model<br>  5)Map<br>  6)ModelMap<br>           &#x2F;&#x2F;做一个数据,传到main.jsp页面上<br>        Users u &#x3D; new Users(“张三”,22);</p><pre><code>    //传递数据    request.setAttribute(&quot;requestUsers&quot;,u);    session.setAttribute(&quot;sessionUsers&quot;,u);    model.addAttribute(&quot;modelUsers&quot;,u);    map.put(&quot;mapUsers&quot;,u);    modelMap.addAttribute(&quot;modelMapUsers&quot;,u);</code></pre><p>  注意:Map,Model,ModelMap和request一样,都使用请求作用域进行数据传递.所以服务器端的跳转必须是请求转发.</p><p>12.日期处理<br>  1)日期的提交处理<br>    A.单个日期处理<br>    要使用注解@DateTimeFormat,此注解必须搭配springmvc.xml文件中的<a href="mvc:annotationdriven标签">mvc:annotationdriven标签</a></p><pre><code>B.类中全局日期处理注册一个注解,用来解析本类中所有的日期类型,自动转换. @InitBinderpublic void initBinder(WebDataBinder dataBinder)&#123;    dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(sf,true));&#125;</code></pre><p>  2)日期的显示处理<br>    在页面上显示好看的日期,必须使用JSTL.<br>    步骤:<br>    A)添加依赖jstl<br>      <dependency><br>      <groupId>jstl</groupId><br>      <artifactId>jstl</artifactId><br>      <version>1.2</version><br>    </dependency></p><pre><code>B)在页面上导入标签库 如果是单个日期对象,直接转为好看的格式化的字符串进行显示.如果是list中的实体类对象的成员变量是日期类型,则必须使用jstl进行显示.&lt;%--导入jstl核心标签库--%&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--导入jstl格式化标签库--%&gt;&lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;C)使用标签显示数据    </code></pre>   <table width="800px" border="1">    <tr>        <th>姓名</th>        <th>生日</th>    </tr>        <c:forEach items="${list}" var="stu">    <tr>            <td>${stu.name}</td>            <td>${stu.birthday}------ <fmt:formatDate value="${stu.birthday}" pattern="yyyy-MM-dd"></fmt:formatDate></td>    </tr>        </c:forEach>    </table><p>13.资源在WEB-INF目录下<br>  此目录下的动态资源,不可直接访问,只能通过请求转发的方式进行访问 .<br>  @Controller<br>    public class WebInfAction {<br>        @RequestMapping(“&#x2F;showIndex”)<br>        public String showIndex(){<br>            System.out.println(“访问index.jsp”);<br>            return “index”;<br>        }<br>        @RequestMapping(“&#x2F;showMain”)<br>        public String showMain(){<br>            System.out.println(“访问main.jsp”);<br>            return “main”;<br>        }<br>        @RequestMapping(“&#x2F;showLogin”)<br>        public String showLogin(){<br>            System.out.println(“访问login.jsp”);<br>            return “login”;<br>        }<br>        &#x2F;&#x2F;登录的业务判断<br>        @RequestMapping(“&#x2F;login”)<br>        public String login(String name, String pwd, HttpServletRequest request){<br>            if(“zar”.equalsIgnoreCase(name) &amp;&amp; “123”.equalsIgnoreCase(pwd)){<br>                return “main”;<br>            }else{<br>                request.setAttribute(“msg”,”用户名或密码不正确!”);<br>                return “login”;<br>            }<br>        }<br>    }<br>14.SpringMVC的拦截器<br>  针对请求和响应进行的额外的处理.在请求和响应的过程中添加预处理,后处理和最终处理.</p><p>15.拦截器执行的时机<br>  1)preHandle():在请求被处理之前进行操作,预处理<br>  2)postHandle():在请求被处理之后,但结果还没有渲染前进行操作,可以改变响应结果,后处理<br>  3)afterCompletion:所有的请求响应结束后执行善后工作,清理对象,关闭资源 ,最终处理.</p><p>16.拦截器实现的两种方式<br>  1)继承HandlerInterceptorAdapter的父类<br>  2)实现HandlerInterceptor接口,实现的接口,推荐使用实现接口的方式</p><p>17.拦截器实现的步骤<br>  1)改造登录方法,在session中存储用户信息,用于进行权限验证<br>  @RequestMapping(“&#x2F;login”)<br>    public String login(String name, String pwd, HttpServletRequest request){<br>        if(“zar”.equalsIgnoreCase(name) &amp;&amp; “123”.equalsIgnoreCase(pwd)){<br>            &#x2F;&#x2F;在session中存储用户信息,用于进行权限验证<br>            request.getSession().setAttribute(“users”,name);<br>            return “main”;<br>        }else{<br>            request.setAttribute(“msg”,”用户名或密码不正确!”);<br>            return “login”;<br>        }<br>    }<br>  2)开发拦截器的功能.实现HandlerInterceptor接口,重写preHandle()方法<br>    if(request.getSession().getAttribute(“users”) &#x3D;&#x3D; null){<br>            &#x2F;&#x2F;此时就是没有登录,打回到登录页面,并给出提示<br>            request.setAttribute(“msg”,”您还没有登录,请先去登录!”);<br>            request.getRequestDispatcher(“&#x2F;WEB-INF&#x2F;jsp&#x2F;login.jsp”).forward(request,response);<br>            return false;<br>        }<br>        return true;&#x2F;&#x2F;放行请求<br>  2)在springmvc.xml文件中注册拦截器<br>      <a href="mvc:interceptors">mvc:interceptors</a><br>        <a href="mvc:interceptor">mvc:interceptor</a><br>            <!--映射要拦截的请求--><br>            &lt;mvc:mapping path&#x3D;”&#x2F;**”&#x2F;&gt;<br>            <!--设置放行的请求--><br>            &lt;mvc:exclude-mapping path&#x3D;”&#x2F;showLogin”&gt;</mvc:exclude-mapping><br>            &lt;mvc:exclude-mapping path&#x3D;”&#x2F;login”&gt;</mvc:exclude-mapping><br>            <!--配置具体的拦截器实现功能的类--><br>            <bean class="com.bjpowernode.interceptor.LoginInterceptor"></bean><br>        </mvc:interceptor><br>    </mvc:interceptors></p><p>18.SSM整合的步骤<br>  0)建库,建表<br>  1)新建Maven项目,选择webapp模板<br>  2)修改目录<br>  3)修改pom.xml文件(使用老师提供)<br>  4)添加jdbc.properties属性文件<br>  5)添加SqlMapConfig.xml文件(使用模板)<br>  6)添加applicationContext_mapper.xml文件(数据访问层的核心配置文件)<br>  7)添加applicationContext_service.xml文件(业务逻辑层的核心配置文件)<br>  8)添加spirngmvc.xml文件<br>  9)删除web.xml文件,新建,改名,设置中文编码,并注册spirngmvc框架,并注册Spring框架<br>  10)新建实体类user<br>  11)新建UserMapper.java接口<br>  12)新建UserMapper.xml实现增删查所有功能,没有更新<br>  13)新建service接口和实现类<br>  14)新建测试类,完成所有功能的测试<br>  15)新建控制器,完成所有功能<br>  16)浏览器测试功能</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot笔记</title>
      <link href="/2022/11/01/SpringBoot%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/SpringBoot%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h1 id="第一章-JavaConfig"><a href="#第一章-JavaConfig" class="headerlink" title="第一章  JavaConfig"></a>第一章  JavaConfig</h1><ol><li><p>为什么要使用 Spring Boot</p><p>因为Spring， SpringMVC 需要使用的大量的配置文件 （xml文件）</p><p>还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象</p><p>需要了解其他框架配置规则。</p></li><li><p>SpringBoot 就相当于 不需要配置文件的Spring+SpringMVC。 常用的框架和第三方库都已经配置好了。</p><p>拿来就可以使用了。</p></li><li><p>SpringBoot开发效率高，使用方便多了</p></li></ol><h2 id="1-1-JavaConfig"><a href="#1-1-JavaConfig" class="headerlink" title="1.1 JavaConfig"></a>1.1 JavaConfig</h2><p>JavaConfig: 使用java类作为xml配置文件的替代， 是配置spring容器的纯java的方式。 在这个java类这可以创建java对象，把对象放入spring容器中（注入到容器）， </p><p>使用两个注解：</p><p>1）@Configuration ： 放在一个类的上面，表示这个类是作为配置文件使用的。</p><p>2）@Bean：声明对象，把对象注入到容器中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">例子：package com.bjpowernode.config;import com.bjpowernode.vo.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;&#x2F;** * Configuration:表示当前类是作为配置文件使用的。 就是用来配置容器的 *       位置：在类的上面 * *  SpringConfig这个类就相当于beans.xml *&#x2F;@Configurationpublic class SpringConfig &#123;    &#x2F;**     * 创建方法，方法的返回值是对象。 在方法的上面加入@Bean     * 方法的返回值对象就注入到容器中。     *     * @Bean: 把对象注入到spring容器中。 作用相当于&lt;bean&gt;     *     *     位置：方法的上面     *     *     说明：@Bean,不指定对象的名称，默认是方法名是 id     *     *&#x2F;    @Bean    public Student createStudent()&#123;        Student s1  &#x3D; new Student();        s1.setName(&quot;张三&quot;);        s1.setAge(26);        s1.setSex(&quot;男&quot;);        return s1;    &#125;    &#x2F;***     * 指定对象在容器中的名称（指定&lt;bean&gt;的id属性）     * @Bean的name属性，指定对象的名称（id）     *&#x2F;    @Bean(name &#x3D; &quot;lisiStudent&quot;)    public Student makeStudent()&#123;        Student s2  &#x3D; new Student();        s2.setName(&quot;李四&quot;);        s2.setAge(22);        s2.setSex(&quot;男&quot;);        return s2;    &#125;&#125;</code></pre><h2 id="1-2-ImporResource"><a href="#1-2-ImporResource" class="headerlink" title="1.2 @ImporResource"></a>1.2 @ImporResource</h2><p>@ImportResource 作用导入其他的xml配置文件， 等于 在xml </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;import resources&#x3D;&quot;其他配置文件&quot;&#x2F;&gt;</code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ImportResource(value &#x3D;&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)public class SpringConfig &#123;&#125;</code></pre><h2 id="1-3-PropertyResource"><a href="#1-3-PropertyResource" class="headerlink" title="1.3 @PropertyResource"></a>1.3 @PropertyResource</h2><p>@PropertyResource: 读取properties属性配置文件。 使用属性配置文件可以实现外部化配置 ，</p><p>在程序代码之外提供数据。</p><p>步骤：</p><ol><li>在resources目录下，创建properties文件， 使用k&#x3D;v的格式提供数据</li><li>在PropertyResource 指定properties文件的位置</li><li>使用@Value（value&#x3D;”${key}”）</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ImportResource(value &#x3D;&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)@PropertySource(value &#x3D; &quot;classpath:config.properties&quot;)@ComponentScan(basePackages &#x3D; &quot;com.bjpowernode.vo&quot;)public class SpringConfig &#123;&#125;</code></pre><h1 id="第二-章-Spring-Boot"><a href="#第二-章-Spring-Boot" class="headerlink" title="第二 章 Spring Boot"></a>第二 章 Spring Boot</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>SpringBoot是Spring中的一个成员， 可以简化Spring，SpringMVC的使用。 他的核心还是IOC容器。</p><p>特点：</p><ul><li><p>Create stand-alone Spring applications</p><p>创建spring应用</p></li><li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p><p>内嵌的tomcat， jetty ， Undertow </p></li><li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p><p>提供了starter起步依赖，简化应用的配置。   </p><p>比如使用MyBatis框架 ， 需要在Spring项目中，配置MyBatis的对象 SqlSessionFactory ， Dao的代理对象</p><p>在SpringBoot项目中，在pom.xml里面, 加入一个 mybatis-spring-boot-starter依赖</p></li><li><p>Automatically configure Spring and 3rd party libraries whenever possible</p><p>尽可能去配置spring和第三方库。叫做自动配置（就是把spring中的，第三方库中的对象都创建好，放到容器中， 开发人员可以直接使用）</p></li><li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p><p>提供了健康检查， 统计，外部化配置</p></li><li><p>Absolutely no code generation and no requirement for XML configuration</p><p>不用生成代码， 不用使用xml，做配置</p></li></ul><h2 id="2-2-创建Spring-Boot项目"><a href="#2-2-创建Spring-Boot项目" class="headerlink" title="2.2 创建Spring Boot项目"></a>2.2 创建Spring Boot项目</h2><h3 id="2-2-1-第一种方式，-使用Spring提供的初始化器，-就是向导创建SpringBoot应用"><a href="#2-2-1-第一种方式，-使用Spring提供的初始化器，-就是向导创建SpringBoot应用" class="headerlink" title="2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用"></a>2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用</h3><p>使用的地址： <a href="https://start.spring.io/">https://start.spring.io</a></p><p>SpringBoot项目的结构：</p><p><img src="D:\course\25-SpringBoot\笔记\images\image-20210115152427829.png" alt="image-20210115152427829"></p><h3 id="2-2-1-使用国内的地址"><a href="#2-2-1-使用国内的地址" class="headerlink" title="2.2.1  使用国内的地址"></a>2.2.1  使用国内的地址</h3><p><a href="https://start.springboot.io/">https://start.springboot.io</a></p><p><img src="D:\course\25-SpringBoot\笔记\images\image-20210115155556662.png" alt="image-20210115155556662"></p><h2 id="2-3-注解的使用"><a href="#2-3-注解的使用" class="headerlink" title="2.3  注解的使用"></a>2.3  注解的使用</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication符合注解：由@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan        1.@SpringBootConfiguration    @Configurationpublic @interface SpringBootConfiguration &#123;    @AliasFor(        annotation &#x3D; Configuration.class    )    boolean proxyBeanMethods() default true;&#125;说明：使用了@SpringBootConfiguration注解标注的类，可以作为配置文件使用的，    可以使用Bean声明对象，注入到容器</code></pre><p>2.@EnableAutoConfiguration</p><p>启用自动配置， 把java对象配置好，注入到spring容器中。例如可以把mybatis的对象创建好，放入到容器中</p><p>3.@ComponentScan</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ComponentScan 扫描器，找到注解，根据注解的功能创建对象，给属性赋值等等。默认扫描的包： @ComponentScan所在的类所在的包和子包。    </code></pre><h2 id="2-4-SpringBoot的配置文件"><a href="#2-4-SpringBoot的配置文件" class="headerlink" title="2.4 SpringBoot的配置文件"></a>2.4 SpringBoot的配置文件</h2><p>配置文件名称： application</p><p>扩展名有： properties( k&#x3D;v) ;  yml ( k: v)</p><p>使用application.properties,   application.yml</p><p>例1：application.properties设置 端口和上下文</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">#设置端口号server.port&#x3D;8082#设置访问应用上下文路径， contextpathserver.servlet.context-path&#x3D;&#x2F;myboot</code></pre><p>例2： application.yml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 8083  servlet:    context-path: &#x2F;myboot2</code></pre><h2 id="2-5-多环境配置"><a href="#2-5-多环境配置" class="headerlink" title="2.5 多环境配置"></a>2.5 多环境配置</h2><p>有开发环境， 测试环境， 上线的环境。</p><p>每个环境有不同的配置信息， 例如端口， 上下文件， 数据库url，用户名，密码等等</p><p>使用多环境配置文件，可以方便的切换不同的配置。</p><p>使用方式： 创建多个配置文件， 名称规则： application-环境名称.properties(yml)</p><p>创建开发环境的配置文件： application-dev.properties(  application-dev.yml )</p><p>创建测试者使用的配置： application-test.properties</p><h2 id="2-6-ConfigurationProperties"><a href="#2-6-ConfigurationProperties" class="headerlink" title="2.6 @ConfigurationProperties"></a>2.6 @ConfigurationProperties</h2><p>@ConfigurationProperties: 把配置文件的数据映射为java对象。</p><p>属性：prefix 配置文件中的某些key的开头的内容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@ConfigurationProperties(prefix &#x3D; &quot;school&quot;)public class SchoolInfo &#123;    private String name;    private String website;    private String address;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public String getWebsite() &#123;        return website;    &#125;    public void setWebsite(String website) &#123;        this.website &#x3D; website;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address &#x3D; address;    &#125;    @Override    public String toString() &#123;        return &quot;SchoolInfo&#123;&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, website&#x3D;&#39;&quot; + website + &#39;\&#39;&#39; +                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>application.properties</p><pre class="line-numbers language-pro" data-language="pro"><code class="language-pro">#配置端口号server.port&#x3D;8082#context-pathserver.servlet.context-path&#x3D;&#x2F;myboot#自定义key&#x3D;valueschool.name&#x3D;动力节点school.website&#x3D;www.bjpowernode.comschool.address&#x3D;北京的大兴区site&#x3D;www.bjpowernode.com</code></pre><h2 id="2-7-使用jsp"><a href="#2-7-使用jsp" class="headerlink" title="2.7  使用jsp"></a>2.7  使用jsp</h2><p>SpringBoot不推荐使用jsp ，而是使用模板技术代替jsp</p><p>使用jsp需要配置：</p><p>1） 加入一个处理jsp的依赖。 负责编译jsp文件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="2"><li>如果需要使用servlet， jsp，jstl的功能</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;&lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;&lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;&lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;&lt;artifactId&gt;javax.servlet.jsp-api&lt;&#x2F;artifactId&gt;&lt;version&gt;2.3.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="3"><li>创建一个存放jsp的目录，一般叫做webapp</li></ol><p>​    index.jsp</p><ol start="4"><li>需要在pom.xml指定jsp文件编译后的存放目录。</li></ol><p>  META-INF&#x2F;resources</p><p>5）创建Controller， 访问jsp</p><p>6）在application.propertis文件中配置视图解析器</p><h2 id="2-8-使用容器"><a href="#2-8-使用容器" class="headerlink" title="2.8 使用容器"></a>2.8 使用容器</h2><p>你想通过代码，从容器中获取对象。</p><p>通过SpringApplication.run(Application.class, args); 返回值获取容器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;        return run(new Class[]&#123;primarySource&#125;, args);&#125;ConfigurableApplicationContext : 接口，是ApplicationContext的子接口public interface ConfigurableApplicationContext extends ApplicationContext</code></pre><h2 id="2-9-ComnandLineRunner-接口-，-ApplcationRunner接口"><a href="#2-9-ComnandLineRunner-接口-，-ApplcationRunner接口" class="headerlink" title="2.9 ComnandLineRunner 接口 ，  ApplcationRunner接口"></a>2.9 ComnandLineRunner 接口 ，  ApplcationRunner接口</h2><p>这两个接口都 有一个run方法。 执行时间在容器对象创建好后， 自动执行run（）方法。</p><p>可以完成自定义的在容器对象创建好的一些操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@FunctionalInterfacepublic interface CommandLineRunner &#123;    void run(String... args) throws Exception;&#125;@FunctionalInterfacepublic interface ApplicationRunner &#123;    void run(ApplicationArguments args) throws Exception;&#125;</code></pre><h1 id="第三章-Web组件"><a href="#第三章-Web组件" class="headerlink" title="第三章 Web组件"></a>第三章 Web组件</h1><p>讲三个内容： 拦截器， Servlet ，Filter</p><h2 id="3-1-拦截器"><a href="#3-1-拦截器" class="headerlink" title="3.1 拦截器"></a>3.1 拦截器</h2><p>拦截器是SpringMVC中一种对象，能拦截器对Controller的请求。</p><p>拦截器框架中有系统的拦截器， 还可以自定义拦截器。  实现对请求预先处理。</p><p>实现自定义拦截器：</p><ol><li><p>创建类实现SpringMVC框架的HandlerInterceptor接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;     return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125;</code></pre></li></ol><p>2.需在SpringMVC的配置文件中，声明拦截器</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mvc:interceptors&gt;&lt;mvc:interceptor&gt;    &lt;mvc:path&#x3D;&quot;url&quot; &#x2F;&gt;        &lt;bean class&#x3D;&quot;拦截器类全限定名称&quot;&#x2F;&gt;    &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;</code></pre><p>SpringBoot中注册拦截器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MyAppConfig implements WebMvcConfigurer &#123;    &#x2F;&#x2F;添加拦截器对象， 注入到容器中    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        &#x2F;&#x2F;创建拦截器对象        HandlerInterceptor interceptor &#x3D; new LoginInterceptor();        &#x2F;&#x2F;指定拦截的请求uri地址        String path []&#x3D; &#123;&quot;&#x2F;user&#x2F;**&quot;&#125;;        &#x2F;&#x2F;指定不拦截的地址        String excludePath  [] &#x3D; &#123;&quot;&#x2F;user&#x2F;login&quot;&#125;;        registry.addInterceptor(interceptor)                .addPathPatterns(path)                .excludePathPatterns(excludePath);    &#125;&#125;</code></pre><h2 id="3-2-Servlet"><a href="#3-2-Servlet" class="headerlink" title="3.2  Servlet"></a>3.2  Servlet</h2><p>在SpringBoot框架中使用Servlet对象。</p><p>使用步骤：</p><ol><li>创建Servlet类。 创建类继承HttpServlet</li><li>注册Servlet ，让框架能找到Servlet</li></ol><p> 例子：</p><p>1.创建自定义Servlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;创建Servlet类public class MyServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       &#x2F;&#x2F;使用HttpServletResponse输出数据，应答结果        resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);        PrintWriter out  &#x3D; resp.getWriter();        out.println(&quot;&#x3D;&#x3D;&#x3D;执行的是Servlet&#x3D;&#x3D;&quot;);        out.flush();        out.close();    &#125;&#125;</code></pre><ol start="2"><li>注册Servlet</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class WebApplictionConfig &#123;    &#x2F;&#x2F;定义方法， 注册Servlet对象    @Bean    public ServletRegistrationBean servletRegistrationBean()&#123;        &#x2F;&#x2F;public ServletRegistrationBean(T servlet, String... urlMappings)        &#x2F;&#x2F;第一个参数是 Servlet对象， 第二个是url地址        &#x2F;&#x2F;ServletRegistrationBean bean &#x3D;                &#x2F;&#x2F;new ServletRegistrationBean( new MyServlet(),&quot;&#x2F;myservlet&quot;);        ServletRegistrationBean bean &#x3D; new ServletRegistrationBean();        bean.setServlet( new MyServlet());        bean.addUrlMappings(&quot;&#x2F;login&quot;,&quot;&#x2F;test&quot;); &#x2F;&#x2F; &lt;url-pattern&gt;        return bean;    &#125;&#125;</code></pre><h2 id="3-3-过滤器Filter"><a href="#3-3-过滤器Filter" class="headerlink" title="3.3 过滤器Filter"></a>3.3 过滤器Filter</h2><p>Filter是Servlet规范中的过滤器，可以处理请求， 对请求的参数， 属性进行调整。 常常在过滤器中处理字符编码</p><p>在框架中使用过滤器：</p><ol><li>创建自定义过滤器类</li><li>注册Filter过滤器对象</li></ol><p>例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 自定义过滤器public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;执行了MyFilter，doFilter &quot;);        filterChain.doFilter(servletRequest,servletResponse);    &#125;&#125;</code></pre><p>注册Filter</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class WebApplicationConfig &#123;    @Bean    public FilterRegistrationBean filterRegistrationBean()&#123;        FilterRegistrationBean bean  &#x3D; new FilterRegistrationBean();        bean.setFilter( new MyFilter());        bean.addUrlPatterns(&quot;&#x2F;user&#x2F;*&quot;);        return bean;    &#125;&#125;</code></pre><h2 id="3-4-字符集过滤器"><a href="#3-4-字符集过滤器" class="headerlink" title="3.4 字符集过滤器"></a>3.4 字符集过滤器</h2><p>CharacterEncodingFilter : 解决post请求中乱码的问题</p><p>在SpringMVC框架， 在web.xml 注册过滤器。 配置他的属性。 </p><p>第一种方式：</p><p>使用步骤：</p><ol><li><p>配置字符集过滤器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class WebSystemConfig &#123;    &#x2F;&#x2F;注册Servlet    @Bean    public ServletRegistrationBean servletRegistrationBean()&#123;        MyServlet myServlet &#x3D; new MyServlet();        ServletRegistrationBean reg &#x3D; new ServletRegistrationBean(myServlet,&quot;&#x2F;myservlet&quot;);        return reg;    &#125;    &#x2F;&#x2F;注册Filter    @Bean    public FilterRegistrationBean filterRegistrationBean()&#123;        FilterRegistrationBean reg &#x3D; new FilterRegistrationBean();        &#x2F;&#x2F;使用框架中的过滤器类        CharacterEncodingFilter filter  &#x3D; new CharacterEncodingFilter();        &#x2F;&#x2F;指定使用的编码方式        filter.setEncoding(&quot;utf-8&quot;);        &#x2F;&#x2F;指定request ， response都使用encoding的值        filter.setForceEncoding(true);        reg.setFilter(filter);        &#x2F;&#x2F;指定 过滤的url地址        reg.addUrlPatterns(&quot;&#x2F;*&quot;);        return reg;    &#125;&#125;</code></pre></li><li><p>修改application.properties文件， 让自定义的过滤器起作用</p></li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#SpringBoot中默认已经配置了CharacterEncodingFilter。 编码默认ISO-8859-1#设置enabled&#x3D;false 作用是关闭系统中配置好的过滤器， 使用自定义的CharacterEncodingFilterserver.servlet.encoding.enabled&#x3D;false</code></pre><p>第二种方式</p><p>修改application.properties文件</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;9001server.servlet.context-path&#x3D;&#x2F;myboot#让系统的CharacterEncdoingFilter生效server.servlet.encoding.enabled&#x3D;true#指定使用的编码方式server.servlet.encoding.charset&#x3D;utf-8#强制request，response都使用charset属性的值server.servlet.encoding.force&#x3D;true</code></pre><h1 id="第四章-ORM-操作-MySQL"><a href="#第四章-ORM-操作-MySQL" class="headerlink" title="第四章 ORM 操作 MySQL"></a>第四章 ORM 操作 MySQL</h1><p>使用MyBatis框架操作数据，  在SpringBoot框架集成MyBatis</p><p>使用步骤：</p><ol><li><p>mybatis起步依赖 ： 完成mybatis对象自动配置， 对象放在容器中</p></li><li><p>pom.xml 指定把src&#x2F;main&#x2F;java目录中的xml文件包含到classpath中</p></li><li><p>创建实体类Student</p></li><li><p>创建Dao接口 StudentDao , 创建一个查询学生的方法 </p></li><li><p>创建Dao接口对应的Mapper文件， xml文件， 写sql语句</p></li><li><p>创建Service层对象， 创建StudentService接口和他的实现类。 去dao对象的方法。完成数据库的操作</p></li><li><p>创建Controller对象，访问Service。</p></li><li><p>写application.properties文件</p><p>配置数据库的连接信息。</p></li></ol><h3 id="第一种方式-：-Mapper"><a href="#第一种方式-：-Mapper" class="headerlink" title="第一种方式 ： @Mapper"></a>第一种方式 ： @Mapper</h3><p>@Mapper：放在dao接口的上面， 每个接口都需要使用这个注解。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @Mapper：告诉MyBatis这是dao接口，创建此接口的代理对象。 *     位置：在类的上面 *&#x2F;@Mapperpublic interface StudentDao &#123;    Student selectById(@Param(&quot;stuId&quot;) Integer id);&#125;</code></pre><h3 id="第二种方式-MapperScan"><a href="#第二种方式-MapperScan" class="headerlink" title="第二种方式  @MapperScan"></a>第二种方式  @MapperScan</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @MapperScan: 找到Dao接口和Mapper文件 *     basePackages：Dao接口所在的包名 *&#x2F;@SpringBootApplication@MapperScan(basePackages &#x3D; &#123;&quot;com.bjpowernode.dao&quot;,&quot;com.bjpowernode.mapper&quot;&#125;)public class Application &#123;&#125;</code></pre><h3 id="第三种方式：-Mapper文件和Dao接口分开管理"><a href="#第三种方式：-Mapper文件和Dao接口分开管理" class="headerlink" title="第三种方式： Mapper文件和Dao接口分开管理"></a>第三种方式： Mapper文件和Dao接口分开管理</h3><p> 现在把Mapper文件放在resources目录下</p><p>1）在resources目录中创建子目录 （自定义的） ， 例如mapper</p><p>2）把mapper文件放到 mapper目录中</p><p>3）在application.properties文件中，指定mapper文件的目录</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#指定mapper文件的位置mybatis.mapper-locations&#x3D;classpath:mapper&#x2F;*.xml#指定mybatis的日志mybatis.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><ol start="4"><li>在pom.xml中指定 把resources目录中的文件 ， 编译到目标目录中</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--resources插件--&gt;&lt;resources&gt;   &lt;resource&gt;      &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;      &lt;includes&gt;         &lt;include&gt;**&#x2F;*.*&lt;&#x2F;include&gt;      &lt;&#x2F;includes&gt;   &lt;&#x2F;resource&gt;&lt;&#x2F;resources&gt;</code></pre><h3 id="第四个-事务"><a href="#第四个-事务" class="headerlink" title="第四个  事务"></a>第四个  事务</h3><p>Spring框架中的事务：</p><p>1） 管理事务的对象： 事务管理器（接口， 接口有很多的实现类）</p><p>​      例如：使用Jdbc或mybatis访问数据库，使用的事务管理器：DataSourceTransactionManager</p><p>2 ) 声明式事务：  在xml配置文件或者使用注解说明事务控制的内容</p><p>​     控制事务： 隔离级别，传播行为， 超时时间</p><p>3）事务处理方式：</p><p>​      1） Spring框架中的@Transactional</p><p>​      2)    aspectj框架可以在xml配置文件中，声明事务控制的内容</p><p>​    </p><p>SpringBoot中使用事务： 上面的两种方式都可以。</p><p>1）在业务方法的上面加入@Transactional ,  加入注解后，方法有事务功能了。</p><p>2）明确的在 主启动类的上面 ，加入@EnableTransactionManager</p><p>例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @Transactional: 表示方法的有事务支持 *       默认：使用库的隔离级别， REQUIRED 传播行为； 超时时间  -1 *       抛出运行时异常，回滚事务 *&#x2F;@Transactional@Overridepublic int addStudent(Student student) &#123;    System.out.println(&quot;业务方法addStudent&quot;);    int rows  &#x3D;  studentDao.insert(student);    System.out.println(&quot;执行sql语句&quot;);    &#x2F;&#x2F;抛出一个运行时异常， 目的是回滚事务    &#x2F;&#x2F;int m   &#x3D; 10 &#x2F; 0 ;    return rows;&#125;</code></pre><h1 id="第五章-接口架构风格-—RESTful"><a href="#第五章-接口架构风格-—RESTful" class="headerlink" title="第五章 接口架构风格 —RESTful"></a>第五章 接口架构风格 —RESTful</h1><p>接口： API（Application Programming Interface，应用程序接口）是一些预先定义的接口（如函数、HTTP接口），或指<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/224122">软件系统</a>不同组成部分衔接的约定。 用来提供<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a>与开发人员基于某<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6">软件</a>或硬件得以访问的一组<a href="https://baike.baidu.com/item/%E4%BE%8B%E7%A8%8B/2390628">例程</a>，而又无需访问源码，或理解内部<a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/9905789">工作机制</a>的细节。</p><p>接口（API）： 可以指访问servlet， controller的url，   调用其他程序的 函数</p><p>架构风格： api组织方式（样子）</p><p>   就是一个传统的：    <a href="http://localhost:9002/mytrans/addStudent?name=lisi&amp;age=26">http://localhost:9002/mytrans/addStudent?name=lisi&amp;age=26</a> </p><p>​                                      在地址上提供了 访问的资源名称addStudent, 在其后使用了get方式传递参数。</p><h3 id="5-1-REST"><a href="#5-1-REST" class="headerlink" title="5.1  REST"></a>5.1  REST</h3><p>RESTful架构风格</p><p>1)REST :  （英文： Representational State Transfer , 中文： 表现层状态转移)。</p><p>   REST：是一种接口的架构风格和设计的理念，不是标准。</p><p>   优点： 更简洁，更有层次</p><p>   表现层状态转移: </p><p>​         表现层就是视图层， 显示资源的， 通过视图页面，jsp等等显示操作资源的结果。</p><p>​          状态： 资源变化</p><p>​         转移： 资源可以变化的。 资源能创建，new状态，  资源创建后可以查询资源， 能看到资源的内容，</p><p>这个资源内容 ，可以被修改， 修改后资源 和之前的不一样。  </p><p>2）REST中的要素：</p><p>   用REST表示资源和对资源的操作。  在互联网中，表示一个资源或者一个操作。 </p><p>   资源使用url表示的， 在互联网， 使用的图片，视频， 文本，网页等等都是资源。</p><p>   资源是用名词表示。</p><p>  对资源： </p><p>​        查询资源： 看，通过url找到资源。 </p><p>​        创建资源： 添加资源</p><p>​        更新资源：更新资源 ，编辑</p><p>​        删除资源： 去除</p><p>​       </p><p> 资源使用url表示，通过名词表示资源。</p><p>​     在url中，使用名词表示资源， 以及访问资源的信息,  在url中，使用“ &#x2F; “ 分隔对资源的信息</p><p>​     <a href="http://localhost:8080/myboot/student/1001">http://localhost:8080/myboot/student/1001</a></p><p> 使用http中的动作（请求方式）， 表示对资源的操作（CURD）</p><p>   GET:  查询资源  –  sql select</p><p>​                 处理单个资源： 用他的单数方式</p><p>​                  <a href="http://localhost:8080/myboot/student/1001">http://localhost:8080/myboot/student/1001</a></p><p>​                 <a href="http://localhost:8080/myboot/student/1001/1">http://localhost:8080/myboot/student/1001/1</a></p><p>​                处理多个资源：使用复数形式</p><p>​                  <a href="http://localhost:8080/myboot/students/1001/1002">http://localhost:8080/myboot/students/1001/1002</a></p><p>​                </p><p>   POST: 创建资源  – sql insert</p><p>​                <a href="http://localhost:8080/myboot/student">http://localhost:8080/myboot/student</a></p><p>​                在post请求中传递数据</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;myboot&#x2F;student&quot; method&#x3D;&quot;post&quot;&gt;姓名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; &#x2F;&gt;    年龄：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; &#x2F;&gt;  &lt;&#x2F;form&gt;</code></pre><p>   PUT： 更新资源  –  sql  update</p>   <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;myboot&#x2F;student&#x2F;1&quot; method&#x3D;&quot;post&quot;&gt;姓名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; &#x2F;&gt;    年龄：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; &#x2F;&gt;         &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;PUT&quot; &#x2F;&gt;  &lt;&#x2F;form&gt;</code></pre><p>   DELETE: 删除资源  – sql delete</p><pre><code><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;myboot&#x2F;student&#x2F;1&quot;&gt;删除1的数据&lt;&#x2F;a&gt;</code></pre></code></pre><p> 需要的分页，  排序等参数，依然放在  url的后面， 例如 </p><p> <a href="http://localhost:8080/myboot/students?page=1&amp;pageSize=20">http://localhost:8080/myboot/students?page=1&amp;pageSize=20</a></p><p>   &#96;</p><p>3） 一句话说明REST： </p><p>​    使用url表示资源 ，使用http动作操作资源。</p><ol start="4"><li>注解</li></ol><p>  @PathVariable :  从url中获取数据</p><p>  @GetMapping:    支持的get请求方式，  等同于 @RequestMapping( method&#x3D;RequestMethod.GET)</p><p>  @PostMapping:  支持post请求方式 ，等同于 @RequestMapping( method&#x3D;RequestMethod.POST)</p><p>  @PutMapping:  支持put请求方式，  等同于 @RequestMapping( method&#x3D;RequestMethod.PUT)</p><p>   @DeleteMapping: 支持delete请求方式，  等同于 @RequestMapping( method&#x3D;RequestMethod.DELETE)</p><p>  @RestController:  符合注解， 是@Controller 和@ResponseBody组合。</p><p>​               在类的上面使用@RestController ， 表示当前类者的所有方法都加入了 @ResponseBody</p><ol start="5"><li><p>Postman : 测试工具</p><p>使用Postman : 可以测试 get ，post ， put ，delete 等请求</p></li></ol><h3 id="5-2-在页面中或者ajax中，支持put，delete请求"><a href="#5-2-在页面中或者ajax中，支持put，delete请求" class="headerlink" title="5.2  在页面中或者ajax中，支持put，delete请求"></a>5.2  在页面中或者ajax中，支持put，delete请求</h3><p>在SpringMVC中 有一个过滤器， 支持post请求转为put ,delete</p><p>过滤器： org.springframework.web.filter.HiddenHttpMethodFilter</p><p>作用： 把请求中的post请求转为 put ， delete</p><p>实现步骤：</p><ol><li>application.properties(yml) : 开启使用 HiddenHttpMethodFilter 过滤器</li><li>在请求页面中，包含 _method参数， 他的值是 put， delete  ，  发起这个请求使用的post方式</li></ol><h1 id="第六章-Redis"><a href="#第六章-Redis" class="headerlink" title="第六章 Redis"></a>第六章 Redis</h1><p>Redis ： 一个NoSQL数据库，  常用作 缓存使用 （cache）</p><p>Redis的数据类型： string  ,  hash  ,set  ,zset , list</p><p>Redis是一个中间件： 是一个独立的服务器。</p><p>java中著名的客户端： Jedis ，  lettuce ， Redisson</p><p>Spring,SpringBoot中有 一个RedisTemplate（StringRedisTemplate） ，处理和redis交互  </p><h2 id="6-1-配置Windows版本的redis"><a href="#6-1-配置Windows版本的redis" class="headerlink" title="6.1  配置Windows版本的redis"></a>6.1  配置Windows版本的redis</h2><p>Redis-x64-3.2.100.rar 解压缩到一个 非中文 的目录</p><p>redis-server.exe：服务端， 启动后，不要关闭</p><p>redis-cli.exe：客户端， 访问redis中的数据</p><p>redisclient-win32.x86_64.2.0.jar : Redis图形界面客户端</p><p>执行方式： 在这个文件所在的目录，  执行 java -jar redisclient-win32.x86_64.2.0.jar</p><p>RedisTemplate 使用的  lettuce 客户端库</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--redis起步依赖： 直接在项目中使用RedisTemplate(StringRedisTemplate)--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;data-redis使用的   lettuce 客户端库在程序中使用RedisTemplate类的方法 操作redis数据， 实际就是调用的lettuce 客户端的中的方法</code></pre><h2 id="6-2-对比-StringRedisTemplate-和-RedisTemplate"><a href="#6-2-对比-StringRedisTemplate-和-RedisTemplate" class="headerlink" title="6.2 对比 StringRedisTemplate 和 RedisTemplate"></a>6.2 对比 StringRedisTemplate 和 RedisTemplate</h2><p>StringRedisTemplate ： 把k，v 都是作为String处理， 使用的是String的序列化 ， 可读性好</p><p>RedisTemplate ： 把k，v 经过了序列化存到redis。 k，v 是序列化的内容， 不能直接识别.</p><p>​                                 默认使用的jdk序列化， 可以修改为前提的序列化</p><p> 序列化：把对象转化为可传输的字节序列过程称为序列化。</p><p>反序列化：把字节序列还原为对象的过程称为反序列化。</p><p>为什么需要序列化</p><p>序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。</p><p>什么情况下需要序列化</p><p>通过上面我想你已经知道了凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。</p><p>本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。</p><p>序列化的方式</p><p>序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：</p><p>JDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protofbuff、</p><p>Student( name&#x3D;zs, age&#x3D;20)   —-  { “name”:”zs”, “age”:20 }</p><p>java的序列化： 把java对象转为byte[], 二进制数据</p><p>json序列化：json序列化功能将对象转换为 JSON 格式或从 JSON 格式转换对象。例如把一个Student对象转换为JSON字符串{“name”:”李四”, “age”:29} )，反序列化(将JSON字符串 {“name”:”李四”, “age”:29} 转换为Student对象)</p><p>设置key或者value的序列化方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 使用RedisTemplate ，在存取值之前，设置序列化&#x2F;&#x2F; 设置 key 使用String的序列化redisTemplate.setKeySerializer( new StringRedisSerializer());&#x2F;&#x2F; 设置 value 的序列化redisTemplate.setValueSerializer( new StringRedisSerializer());redisTemplate.opsForValue().set(k,v);</code></pre><h1 id="第七章-SpringBoot集成Dubbo"><a href="#第七章-SpringBoot集成Dubbo" class="headerlink" title="第七章 SpringBoot集成Dubbo"></a>第七章 SpringBoot集成Dubbo</h1><h2 id="7-1-看-SpringBoot继承Dubbo的文档"><a href="#7-1-看-SpringBoot继承Dubbo的文档" class="headerlink" title="7.1  看 SpringBoot继承Dubbo的文档"></a>7.1  看 SpringBoot继承Dubbo的文档</h2><p> <a href="https://github.com/apache/dubbo-spring-boot-project/blob/master/README_CN.md">https://github.com/apache/dubbo-spring-boot-project/blob/master/README_CN.md</a></p><h2 id="7-2-公共项目"><a href="#7-2-公共项目" class="headerlink" title="7.2  公共项目"></a>7.2  公共项目</h2><p>独立的maven项目： 定义了接口和数据类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1901229007746699151L;    private Integer id;    private String name;    private Integer age;&#125;public interface StudentService &#123;    Student queryStudent(Integer id);&#125;</code></pre><h2 id="7-3-提供者"><a href="#7-3-提供者" class="headerlink" title="7.3  提供者"></a>7.3  提供者</h2><p>创建SpringBoot项目</p><p>1） pom.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;   &lt;!--加入公共项目的gav--&gt;   &lt;dependency&gt;      &lt;groupId&gt;com.bjpowernode&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;022-interface-api&lt;&#x2F;artifactId&gt;      &lt;version&gt;1.0.0&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--dubbo依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;      &lt;version&gt;2.7.8&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--zookeeper依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;&#x2F;artifactId&gt;      &lt;version&gt;2.7.8&lt;&#x2F;version&gt;      &lt;type&gt;pom&lt;&#x2F;type&gt;      &lt;exclusions&gt;         &lt;!-- 排除log4j依赖 --&gt;         &lt;exclusion&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;         &lt;&#x2F;exclusion&gt;      &lt;&#x2F;exclusions&gt;   &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><p>2）实现接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 使用dubbo中的注解暴露服务 * @Component 可以不用加 *&#x2F;@DubboService(interfaceClass &#x3D; StudentService.class,version &#x3D; &quot;1.0&quot;,timeout &#x3D; 5000)public class StudentServiceImpl implements StudentService &#123;    @Override    public Student queryStudent(Integer id) &#123;        Student student  &#x3D; new Student();        if( 1001 &#x3D;&#x3D; id)&#123;            student.setId(1001);            student.setName(&quot;------1001-张三&quot;);            student.setAge(20);        &#125; else if(1002  &#x3D;&#x3D; id)&#123;            student.setId(1002);            student.setName(&quot;#######1002-李四&quot;);            student.setAge(22);        &#125;        return student;    &#125;&#125;</code></pre><p>3）application.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#配置服务名称 dubbo:application name&#x3D;&quot;名称&quot;spring.application.name&#x3D;studentservice-provider#配置扫描的包， 扫描的@DubboServicedubbo.scan.base-packages&#x3D;com.bjpowernode.service#配置dubbo协议#dubbo.protocol.name&#x3D;dubbo#dubbo.protocol.port&#x3D;20881#注册中心dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</code></pre><p>4)在启动类的上面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@EnableDubbopublic class ProviderApplication &#123;   public static void main(String[] args) &#123;      SpringApplication.run(ProviderApplication.class, args);   &#125;&#125;</code></pre><h2 id="7-4消费者"><a href="#7-4消费者" class="headerlink" title="7.4消费者"></a>7.4消费者</h2><p>创建SpringBoot项目</p><p>1） pom.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;   &lt;!--加入公共项目的gav--&gt;   &lt;dependency&gt;      &lt;groupId&gt;com.bjpowernode&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;022-interface-api&lt;&#x2F;artifactId&gt;      &lt;version&gt;1.0.0&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--dubbo依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;      &lt;version&gt;2.7.8&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--zookeeper依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;&#x2F;artifactId&gt;      &lt;version&gt;2.7.8&lt;&#x2F;version&gt;      &lt;type&gt;pom&lt;&#x2F;type&gt;      &lt;exclusions&gt;         &lt;!-- 排除log4j依赖 --&gt;         &lt;exclusion&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;         &lt;&#x2F;exclusion&gt;      &lt;&#x2F;exclusions&gt;   &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><ol start="2"><li>创建了Controller 或者 Service都可以</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerpublic class DubboController &#123;    &#x2F;**     * 引用远程服务， 把创建好的代理对象，注入给studentService     *&#x2F;    &#x2F;&#x2F;@DubboReference(interfaceClass &#x3D; StudentService.class,version &#x3D; &quot;1.0&quot;)    &#x2F;**     * 没有使用interfaceClass，默认的就是 引用类型的 数据类型      *&#x2F;    @DubboReference(version &#x3D; &quot;1.0&quot;)    private StudentService studentService;    @GetMapping(&quot;&#x2F;query&quot;)    public String queryStudent(Integer id)&#123;        Student student   &#x3D; studentService.queryStudent(id);        return &quot;调用远程接口，获取对象：&quot;+student;    &#125;&#125;</code></pre><p>3）application.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#指定服务名称spring.application.name&#x3D;consumer-application#指定注册中心dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</code></pre><h2 id="7-5-练习"><a href="#7-5-练习" class="headerlink" title="7.5 练习"></a>7.5 练习</h2><p>使用的技术： SpringBoot ,Dubbo, Redis, MyBatis</p><p>Student表：</p><p><img src="D:\course\25-SpringBoot\笔记\images\image-20210119150418295.png" alt="image-20210119150418295"></p><p>CREATE TABLE <code>student</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>name</code> varchar(255) COLLATE utf8_bin DEFAULT NULL,<br>  <code>phone</code> varchar(11) COLLATE utf8_bin DEFAULT NULL,<br>  <code>age</code> int(11) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;6 DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin;</p><ol><li>注册学生</li></ol><p>​     phone必须唯一， 如果已经存在了手机号， 注册失败的。 </p><p>​                 int addStudent(Student student);</p><p>​                返回值：int</p><p>​                 1： 注册成功</p><p>​                 2 ： 手机号已经存在  </p><p>​                                    </p><p>​      name至少两个字符，</p><p>​      age 必须 大于 0 </p><p>2） 查询学生，根据id查询，此学生。 </p><p>​        先到redis查询学生， 如果redis没有此学生，从数据库查询， 把查询到的学生放入到redis。</p><p>​      后面再次查询这个学生应该从redis就能获取到。</p><p>​        Student  queryStudent(Integer id);</p><ol start="3"><li>使用Dubbo框架，    addStudent, queryStudent 是有服务提供者实现的。</li></ol><p>​    消费者可以是一个Controller ， 调用提供者的两个方法。  实现注册和查询。</p><p>4）页面使用html和ajax，jquery。</p><p>​       在html页面中提供 form 注册学生， 提供文本框输入id，进行查询。</p><p>​      注册和查询都使用ajax技术。</p><p>​    html，jquery.js都放到resources&#x2F;static目录中</p><h1 id="第八章-打包"><a href="#第八章-打包" class="headerlink" title="第八章  打包"></a>第八章  打包</h1><h2 id="8-1-打包war"><a href="#8-1-打包war" class="headerlink" title="8.1 打包war"></a>8.1 打包war</h2><p>1.创建了一个jsp应用</p><p>2.修改pom.xml</p><p> 1)指定打包后的文件名称</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;   &lt;!--打包后的文件名称--&gt;   &lt;finalName&gt;myboot&lt;&#x2F;finalName&gt;&lt;&#x2F;build&gt;</code></pre><p>2)指定jsp编译目录</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--resources插件， 把jsp编译到指定的目录--&gt;&lt;resources&gt;   &lt;resource&gt;      &lt;directory&gt;src&#x2F;main&#x2F;webapp&lt;&#x2F;directory&gt;      &lt;targetPath&gt;META-INF&#x2F;resources&lt;&#x2F;targetPath&gt;      &lt;includes&gt;         &lt;include&gt;**&#x2F;*.*&lt;&#x2F;include&gt;      &lt;&#x2F;includes&gt;   &lt;&#x2F;resource&gt;   &lt;!--使用了mybatis ，而且mapper文件放在src&#x2F;main&#x2F;java目录--&gt;   &lt;resource&gt;      &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;      &lt;includes&gt;         &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;      &lt;&#x2F;includes&gt;   &lt;&#x2F;resource&gt;   &lt;!--把src&#x2F;main&#x2F;resources下面的所有文件，都包含到classes目录--&gt;   &lt;resource&gt;      &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;      &lt;includes&gt;         &lt;include&gt;**&#x2F;*.*&lt;&#x2F;include&gt;      &lt;&#x2F;includes&gt;   &lt;&#x2F;resource&gt;&lt;&#x2F;resources&gt;</code></pre><p>3）执行打包是war</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--打包类型--&gt;&lt;packaging&gt;war&lt;&#x2F;packaging&gt;</code></pre><p>4）主启动类继承SpringBootServletInitializer</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * SpringBootServletInitializer: 继承这个类， 才能使用独立tomcat服务器 *&#x2F;@SpringBootApplicationpublic class JspApplication  extends SpringBootServletInitializer  &#123;   public static void main(String[] args) &#123;      SpringApplication.run(JspApplication.class, args);   &#125;   @Override   protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;      return builder.sources(JspApplication.class);   &#125;&#125;</code></pre><p>5）部署war</p><p> 把war放到tomcat等服务器的发布目录中。  tomcat为例， myboot.war放到tomcat&#x2F;webapps目录。</p><h2 id="8-2-打包为jar"><a href="#8-2-打包为jar" class="headerlink" title="8.2 打包为jar"></a>8.2 打包为jar</h2><p>1.创建了一个包含了jsp的项目</p><p>2.修改pom.xml</p><p>​     1) 指定打包后的文件名称</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;   &lt;!--打包后的文件名称--&gt;   &lt;finalName&gt;myboot&lt;&#x2F;finalName&gt;&lt;&#x2F;build&gt;</code></pre><pre><code>2) 指定springboot-maven-plugin版本</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;plugins&gt;   &lt;plugin&gt;      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;      &lt;!--打包jar， 有jsp文件时，必须指定maven-plugin插件的版本是 1.4.2.RELEASE--&gt;      &lt;version&gt;1.4.2.RELEASE&lt;&#x2F;version&gt;   &lt;&#x2F;plugin&gt;&lt;&#x2F;plugins&gt;</code></pre><p>3）最后执行 maven clean package</p><p>​       在target目录中，生成jar 文件， 例子是myboot.jar</p><p>​       执行独立的springboot项目  在cmd中 java  -jar  myboot.jar</p><h1 id="第九章-Thymeleaf-模板引擎"><a href="#第九章-Thymeleaf-模板引擎" class="headerlink" title="第九章 Thymeleaf 模板引擎"></a>第九章 Thymeleaf 模板引擎</h1><p>Thymeleaf： 是使用java开发的模板技术， 在服务器端运行。 把处理后的数据发送给浏览器。</p><p>​         模板是作视图层工作的。  显示数据的。  Thymeleaf是基于Html语言。 Thymleaf语法是应用在</p><p>​        html标签中 。 SpringBoot框架集成Thymealeaf,  使用Thymeleaf代替jsp。</p><p>Thymeleaf 的官方网站：<a href="http://www.thymeleaf.org/">http://www.thymeleaf.org</a><br>Thymeleaf 官方手册：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a></p><h2 id="9-1-表达式"><a href="#9-1-表达式" class="headerlink" title="9.1 表达式"></a>9.1 表达式</h2><ol><li><p>标准变量表达式 </p><p>语法：  ${key} </p><p>作用： 获取key对于的文本数据，  key 是request作用域中的key ， 使用request.setAttribute(), model.addAttribute()</p><p>在页面中的 html标签中， 使用 th:text&#x3D;”${key}”</p></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;    &lt;h3&gt;标准变量表达式:  $&#123;key&#125;&lt;&#x2F;h3&gt;    &lt;p th:text&#x3D;&quot;$&#123;site&#125;&quot;&gt;key不存在&lt;&#x2F;p&gt;    &lt;br&#x2F;&gt;    &lt;p&gt;获取SysUser对象 属性值&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;$&#123;myuser.id&#125;&quot;&gt;id&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;$&#123;myuser.name&#125;&quot;&gt;姓名&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;$&#123;myuser.sex&#125;&quot;&gt;姓名：m男&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;$&#123;myuser.age&#125;&quot;&gt;年龄&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;$&#123;myuser.getName()&#125;&quot;&gt;获取姓名使用getXXX&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre><ol start="2"><li><p>选择变量表达式（ 星号变量表达式）</p><p>语法：  *{key}</p><p>作用： 获取这个key对应的数据，   *{key}需要和th:object 这个属性一起使用。</p><p>目的是简单获取对象的属性值。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;使用 *&#123;&#125; 获取SysUser的属性值&lt;&#x2F;p&gt;&lt;div th:object&#x3D;&quot;$&#123;myuser&#125;&quot;&gt;    &lt;p th:text&#x3D;&quot;*&#123;id&#125;&quot;&gt;&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;*&#123;name&#125;&quot;&gt;&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;*&#123;sex&#125;&quot;&gt;&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;*&#123;age&#125;&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;p&gt;使用*&#123;&#125;完成的表示 对象的属性值&lt;&#x2F;p&gt;&lt;p th:text&#x3D;&quot;*&#123;myuser.name&#125;&quot; &gt;&lt;&#x2F;p&gt;</code></pre></li><li><p>链接表达式</p><p>语法： @{url}</p><p>作用： 表示链接， 可以</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script src&#x3D;&quot;...&quot;&gt; , &lt;link href&#x3D;&quot;...&quot;&gt; &lt;a href&#x3D;&quot;..&quot;&gt; ,&lt;form action&#x3D;&quot;...&quot;&gt; &lt;img src&#x3D;&quot;...&quot;&gt;</code></pre></li></ol><h2 id="9-2-Thymeleaf属性"><a href="#9-2-Thymeleaf属性" class="headerlink" title="9.2  Thymeleaf属性"></a>9.2  Thymeleaf属性</h2><p>属性是放在html元素中的，就是html元素的属性，加入了th前缀。  属性的作用不变。    加入上th， 属性的值由模板引擎处理了。  在属性可以使用变量表达式</p><p>例如：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;&#x2F;loginServlet&quot; method&#x3D;&quot;post&quot;&gt;&lt;&#x2F;form&gt;&lt;form th:action&#x3D;&quot;&#x2F;loginServlet&quot; th:method&#x3D;&quot;$&#123;methodAttr&#125;&quot;&gt;&lt;&#x2F;form&gt;</code></pre><h2 id="9-3-each"><a href="#9-3-each" class="headerlink" title="9.3 each"></a>9.3 each</h2><p>each循环， 可以循环List，Array</p><p>语法：</p><p>在一个html标签中，使用th:each</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div th:each&#x3D;&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;&gt;    &lt;p th:text&#x3D;&quot;$&#123;集合循环成员&#125;&quot; &gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;</code></pre><p>each循环Map</p><p>在一个html标签中，使用th:each</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div th:each&#x3D;&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;&gt;    &lt;p th:text&#x3D;&quot;$&#123;集合循环成员.key&#125;&quot; &gt;&lt;&#x2F;p&gt;    &lt;p th:text&#x3D;&quot;$&#123;集合循环成员.value&#125;&quot; &gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;key:map集合中的keyvalue：map集合key对应的value值</code></pre><h2 id="9-4-th-if"><a href="#9-4-th-if" class="headerlink" title="9.4 th:if"></a>9.4 th:if</h2><p>“th:if”  : 判断语句， 当条件为true， 显示html标签体内， 反之不显示 没有else语句</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">语法：&lt;div th:if&#x3D;&quot; 10 &gt; 0 &quot;&gt; 显示文本内容 &lt;&#x2F;div&gt;</code></pre><p>还有一个 th:unless  和 th:if相反的行为</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">语法：&lt;div th:unless&#x3D;&quot; 10 &lt; 0 &quot;&gt; 当条件为false显示标签体内容 &lt;&#x2F;div&gt;</code></pre><p>例子：if</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;        &lt;h3&gt; if 使用&lt;&#x2F;h3&gt;        &lt;p th:if&#x3D;&quot;$&#123;sex&#x3D;&#x3D;&#39;m&#39;&#125;&quot;&gt;性别是男&lt;&#x2F;p&gt;        &lt;p th:if&#x3D;&quot;$&#123;isLogin&#125;&quot;&gt;已经登录系统&lt;&#x2F;p&gt;        &lt;p th:if&#x3D;&quot;$&#123;age &gt; 20&#125;&quot;&gt;年龄大于20&lt;&#x2F;p&gt;        &lt;!--&quot;&quot;空字符是true--&gt;        &lt;p th:if&#x3D;&quot;$&#123;name&#125;&quot;&gt;name是“”&lt;&#x2F;p&gt;        &lt;!--null是false--&gt;        &lt;p th:if&#x3D;&quot;$&#123;isOld&#125;&quot;&gt; isOld是null&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;</code></pre><p>例子： unless</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;       &lt;h3&gt;unless: 判断条件为false，显示标签体内容&lt;&#x2F;h3&gt;       &lt;p th:unless&#x3D;&quot;$&#123;sex&#x3D;&#x3D;&#39;f&#39;&#125;&quot;&gt;性别是男的&lt;&#x2F;p&gt;       &lt;p th:unless&#x3D;&quot;$&#123;isLogin&#125;&quot;&gt;登录系统&lt;&#x2F;p&gt;       &lt;p th:unless&#x3D;&quot;$&#123;isOld&#125;&quot;&gt; isOld是null &lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre><h2 id="9-5-th-switch"><a href="#9-5-th-switch" class="headerlink" title="9.5  th:switch"></a>9.5  th:switch</h2><p>th:switch 和 java中的swith一样的</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">语法：&lt;div th:switch&#x3D;&quot;要比对的值&quot;&gt;    &lt;p th:case&#x3D;&quot;值1&quot;&gt;        结果1    &lt;&#x2F;p&gt;    &lt;p th:case&#x3D;&quot;值2&quot;&gt;        结果2    &lt;&#x2F;p&gt;    &lt;p th:case&#x3D;&quot;*&quot;&gt;        默认结果    &lt;&#x2F;p&gt;    以上的case只有一个语句执行    &lt;&#x2F;div&gt;</code></pre><h2 id="9-6-th-inline"><a href="#9-6-th-inline" class="headerlink" title="9.6 th:inline"></a>9.6 th:inline</h2><ol><li><p>内联text：  在html标签外，获取表达式的值</p><p>语法： </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;显示姓名是：[[$&#123;key&#125;]]&lt;&#x2F;p&gt; &lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;        &lt;h3&gt;内联 text, 使用内联表达式显示变量的值&lt;&#x2F;h3&gt;        &lt;div th:inline&#x3D;&quot;text&quot;&gt;            &lt;p&gt;我是[[$&#123;name&#125;]]，年龄是[[$&#123;age&#125;]]&lt;&#x2F;p&gt;            我是&lt;span th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;span&gt;,年龄是&lt;span th:text&#x3D;&quot;$&#123;age&#125;&quot;&gt;&lt;&#x2F;span&gt;        &lt;&#x2F;div&gt;        &lt;div&gt;            &lt;p&gt;使用内联text&lt;&#x2F;p&gt;            &lt;p&gt;我是[[$&#123;name&#125;]],性别是[[$&#123;sex&#125;]]&lt;&#x2F;p&gt;        &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre></li><li><p>内联javascript</p></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">例子： &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:inline&#x3D;&quot;javascript&quot;&gt;         var myname &#x3D; [[$&#123;name&#125;]];         var myage &#x3D; [[$&#123;age&#125;]];         &#x2F;&#x2F;alert(&quot;获取的模板中数据 &quot;+ myname + &quot;,&quot;+myage)        function fun()&#123;            alert(&quot;单击事件，获取数据 &quot;+ myname + &quot;,&quot;+ [[$&#123;sex&#125;]])        &#125;    &lt;&#x2F;script&gt;</code></pre><h2 id="9-7-字面量"><a href="#9-7-字面量" class="headerlink" title="9.7  字面量"></a>9.7  字面量</h2><p>例子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;      &lt;h3&gt;文本字面量: 使用单引号括起来的字符串&lt;&#x2F;h3&gt;      &lt;p th:text&#x3D;&quot;&#39;我是&#39;+$&#123;name&#125;+&#39;,我所在的城市&#39;+$&#123;city&#125;&quot;&gt;数据显示&lt;&#x2F;p&gt;      &lt;h3&gt;数字字面量&lt;&#x2F;h3&gt;       &lt;p th:if&#x3D;&quot;$&#123;20&gt;5&#125;&quot;&gt; 20大于 5&lt;&#x2F;p&gt;       &lt;h3&gt;boolean字面量&lt;&#x2F;h3&gt;       &lt;p th:if&#x3D;&quot;$&#123;isLogin &#x3D;&#x3D; true&#125;&quot;&gt;用户已经登录系统&lt;&#x2F;p&gt;       &lt;h3&gt;null字面量&lt;&#x2F;h3&gt;       &lt;p th:if&#x3D;&quot;$&#123;myuser !&#x3D; null&#125;&quot;&gt;有myuser数据&lt;&#x2F;p&gt;   &lt;&#x2F;div&gt;</code></pre><h2 id="9-8-字符串连接"><a href="#9-8-字符串连接" class="headerlink" title="9.8  字符串连接"></a>9.8  字符串连接</h2><p>连接字符串有两种语法</p><p>1） 语法使用 单引号括起来字符串  ， 使用 + 连接其他的 字符串或者表达式</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p th:text&#x3D;&quot;&#39;我是&#39;+$&#123;name&#125;+&#39;,我所在的城市&#39;+$&#123;city&#125;&quot;&gt;数据显示&lt;&#x2F;p&gt;</code></pre><p>2）语法：使用双竖线， |字符串和表达式|</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p th:text&#x3D;&quot;|我是$&#123;name&#125;,我所在城市$&#123;city|&quot;&gt;    显示数据&lt;&#x2F;p&gt;</code></pre><p>例子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;   &lt;h3&gt;字符串连接方式1：使用单引号括起来的字符串&lt;&#x2F;h3&gt;   &lt;p th:text&#x3D;&quot;&#39;我是&#39;+$&#123;name&#125;+&#39;,我所在的城市&#39;+$&#123;city&#125;&quot;&gt;数据显示&lt;&#x2F;p&gt;    &lt;br&#x2F;&gt;    &lt;br&#x2F;&gt;    &lt;h3&gt;字符串连接方式2：|字符串和表达式|&lt;&#x2F;h3&gt;    &lt;p th:text&#x3D;&quot;|我是$&#123;name&#125;,所在城市$&#123;city&#125;,其他人$&#123;myuser.name&#125;|&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre><h2 id="9-9-运算符"><a href="#9-9-运算符" class="headerlink" title="9.9 运算符"></a>9.9 运算符</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">算术运 算： + , - - , * , &#x2F; , %关系比较 : &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le )相等判断： &#x3D;&#x3D; , !&#x3D; ( eq , ne )&lt;div style&#x3D;&quot;margin-left: 400px&quot;&gt;        &lt;h3&gt;使用运算符&lt;&#x2F;h3&gt;        &lt;p th:text&#x3D;&quot;$&#123;age &gt; 10&#125;&quot;&gt;年龄大于 10 &lt;&#x2F;p&gt;        &lt;p th:text&#x3D;&quot;$&#123; 20 + 30 &#125;&quot;&gt;显示运算结果&lt;&#x2F;p&gt;        &lt;p th:if&#x3D;&quot;$&#123;myuser &#x3D;&#x3D; null&#125;&quot;&gt;myuser是null&lt;&#x2F;p&gt;        &lt;p th:if&#x3D;&quot;$&#123;myuser eq null&#125;&quot;&gt;myuser是null&lt;&#x2F;p&gt;        &lt;p th:if&#x3D;&quot;$&#123;myuser ne null&#125;&quot;&gt;myuser不是null&lt;&#x2F;p&gt;        &lt;p th:text&#x3D;&quot;$&#123;isLogin &#x3D;&#x3D; true ? &#39;用户已经登录&#39; : &#39;用户需要登录&#39;&#125;&quot;&gt;&lt;&#x2F;p&gt;        &lt;p th:text&#x3D;&quot;$&#123;isLogin &#x3D;&#x3D; true ? ( age &gt; 10 ? &#39;用户是大于10的&#39; : &#39;用户年龄比较小&#39;) : &#39;用户需要登录&#39;&#125;&quot;&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;三元运算符： 表达式  ？ true的结果 : false的结果三元运算符可以嵌套</code></pre><h2 id="9-10-内置对象"><a href="#9-10-内置对象" class="headerlink" title="9.10 内置对象"></a>9.10 内置对象</h2><p>文档地址：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc</a>.</p><p>#request 表示 HttpServletRequest</p><p>#session 表示 HttpSession对象</p><p>session 表示Map对象的， 是#session的简单表示方式， 用来获取session中指定的key的值</p><p>​               #session.getAttribute(“loginname”) &#x3D;&#x3D; session.loginname</p><p>这些是内置对象，可以在模板文件中直接使用。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">例子： &lt;div style&#x3D;&quot;margin-left: 350px&quot;&gt;        &lt;h3&gt;内置对象#request,#session，session的使用&lt;&#x2F;h3&gt;        &lt;p&gt;获取作用域中的数据&lt;&#x2F;p&gt;        &lt;p th:text&#x3D;&quot;$&#123;#request.getAttribute(&#39;requestData&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;        &lt;p th:text&#x3D;&quot;$&#123;#session.getAttribute(&#39;sessionData&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;        &lt;p th:text&#x3D;&quot;$&#123;session.loginname&#125;&quot;&gt;&lt;&#x2F;p&gt;        &lt;br&#x2F;&gt;        &lt;br&#x2F;&gt;        &lt;h3&gt;使用内置对象的方法&lt;&#x2F;h3&gt;        getRequestURL&#x3D;&lt;span th:text&#x3D;&quot;$&#123;#request.getRequestURL()&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;        getRequestURI&#x3D;&lt;span th:text&#x3D;&quot;$&#123;#request.getRequestURI()&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;        getQueryString&#x3D;&lt;span th:text&#x3D;&quot;$&#123;#request.getQueryString()&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;        getContextPath&#x3D;&lt;span th:text&#x3D;&quot;$&#123;#request.getContextPath()&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;        getServerName&#x3D;&lt;span th:text&#x3D;&quot;$&#123;#request.getServerName()&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;        getServerPort&#x3D;&lt;span th:text&#x3D;&quot;$&#123;#request.getServerPort()&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;</code></pre><h2 id="9-11-内置工具类"><a href="#9-11-内置工具类" class="headerlink" title="9.11 内置工具类"></a>9.11 内置工具类</h2><p>内置工具类型： Thymeleaf自己的一些类，提供对string， date ，集合的一些处理方法</p><p>#dates: 处理日器的工具类</p><p>#numbers:处理数字的</p><p>#lists: 处理list集合的</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div style&#x3D;&quot;margin-left: 350px&quot;&gt;      &lt;h3&gt;日期类对象 #dates&lt;&#x2F;h3&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.format(mydate )&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.format(mydate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.format(mydate,&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.year(mydate)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.month(mydate)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.monthName(mydate)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#dates.createNow()&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;br&#x2F;&gt;      &lt;h3&gt;内置工具类#numbers，操作数字的&lt;&#x2F;h3&gt;      &lt;p th:text&#x3D;&quot;$&#123;#numbers.formatCurrency(mynum)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#numbers.formatDecimal(mynum,5,2)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;br&#x2F;&gt;      &lt;h3&gt;内置工具类#strings,操作字符串&lt;&#x2F;h3&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.toUpperCase(mystr)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.indexOf(mystr,&#39;power&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.substring(mystr,2,5)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.substring(mystr,2)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.concat(mystr,&#39;---java开发的黄埔军校---&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.length(mystr)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:text&#x3D;&quot;$&#123;#strings.length(&#39;hello&#39;)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:unless&#x3D;&quot;$&#123;#strings.isEmpty(mystr)&#125;&quot;&gt; mystring 不是 空字符串  &lt;&#x2F;p&gt;      &lt;br&#x2F;&gt;      &lt;h3&gt;内置工具类#lists,操作list集合&lt;&#x2F;h3&gt;      &lt;p th:text&#x3D;&quot;$&#123;#lists.size(mylist)&#125;&quot;&gt;&lt;&#x2F;p&gt;      &lt;p th:if&#x3D;&quot;$&#123;#lists.contains(mylist,&#39;a&#39;)&#125;&quot;&gt;有成员a&lt;&#x2F;p&gt;      &lt;p th:if&#x3D;&quot;!$&#123;#lists.isEmpty(mylist)&#125;&quot;&gt; list 集合有多个成员&lt;&#x2F;p&gt;      &lt;br&#x2F;&gt;      &lt;h3&gt;处理null&lt;&#x2F;h3&gt;      &lt;p th:text&#x3D;&quot;$&#123;zoo?.dog?.name&#125;&quot;&gt;&lt;&#x2F;p&gt;  &lt;&#x2F;div&gt;</code></pre><h2 id="9-12-自定义模板"><a href="#9-12-自定义模板" class="headerlink" title="9.12 自定义模板"></a>9.12 自定义模板</h2><p>模板是内容复用， 定义一次，在其他的模板文件中多次使用。</p><p>模板使用：</p><p>1.定义模板</p><p>2.使用模板</p><p>模板定义语法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">th:fragment&#x3D;&quot;模板自定义名称&quot;例如：&lt;div th:fragment&#x3D;&quot;head&quot;&gt;    &lt;p&gt;        动力节点-java开发    &lt;&#x2F;p&gt;    &lt;p&gt;        www.bjpowernode.com    &lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre><p>引用模板语法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">1) ~&#123;templatename :: selector&#125;   templatename:  文件名称   selector： 自定义模板名称2）templatename :: selector   templatename:  文件名称   selector： 自定义模板名称对于使用模板：有包含模板（th:include）， 插入模板(th:insert)</code></pre><h1 id="第十章-总结"><a href="#第十章-总结" class="headerlink" title="第十章 总结"></a>第十章 总结</h1><h2 id="10-1-注解"><a href="#10-1-注解" class="headerlink" title="10.1 注解"></a>10.1 注解</h2><p>Spring + SpringMVC + SpringBoot </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">创建对象的：@Controller: 放在类的上面，创建控制器对象，注入到容器中@RestController: 放在类的上面，创建控制器对象，注入到容器中。             作用：复合注解是@Controller , @ResponseBody, 使用这个注解类的，里面的控制器方法的返回值                   都是数据@Service ： 放在业务层的实现类上面，创建service对象，注入到容器@Repository : 放在dao层的实现类上面，创建dao对象，放入到容器。 没有使用这个注解，是因为现在使用MyBatis框               架，  dao对象是MyBatis通过代理生成的。 不需要使用@Repository、 所以没有使用。@Component:  放在类的上面，创建此类的对象，放入到容器中。 赋值的：@Value ： 简单类型的赋值， 例如 在属性的上面使用@Value(&quot;李四&quot;) private String name          还可以使用@Value,获取配置文件者的数据（properties或yml）。           @Value(&quot;$&#123;server.port&#125;&quot;) private Integer port@Autowired: 引用类型赋值自动注入的，支持byName, byType. 默认是byType 。 放在属性的上面，也可以放在构造             方法的上面。 推荐是放在构造方法的上面@Qualifer:  给引用类型赋值，使用byName方式。               @Autowird, @Qualifer都是Spring框架提供的。@Resource ： 来自jdk中的定义， javax.annotation。 实现引用类型的自动注入， 支持byName, byType.             默认是byName, 如果byName失败， 再使用byType注入。 在属性上面使用其他：@Configuration ： 放在类的上面，表示这是个配置类，相当于xml配置文件@Bean：放在方法的上面， 把方法的返回值对象，注入到spring容器中。@ImportResource ： 加载其他的xml配置文件， 把文件中的对象注入到spring容器中@PropertySource ： 读取其他的properties属性配置文件@ComponentScan： 扫描器 ，指定包名，扫描注解的@ResponseBody: 放在方法的上面，表示方法的返回值是数据， 不是视图@RequestBody : 把请求体中的数据，读取出来， 转为java对象使用。@ControllerAdvice:  控制器增强， 放在类的上面， 表示此类提供了方法，可以对controller增强功能。@ExceptionHandler : 处理异常的，放在方法的上面@Transcational :  处理事务的， 放在service实现类的public方法上面， 表示此方法有事务SpringBoot中使用的注解    @SpringBootApplication ： 放在启动类上面， 包含了@SpringBootConfiguration                          @EnableAutoConfiguration， @ComponentScan    MyBatis相关的注解@Mapper ： 放在类的上面 ， 让MyBatis找到接口， 创建他的代理对象    @MapperScan :放在主类的上面 ， 指定扫描的包， 把这个包中的所有接口都创建代理对象。 对象注入到容器中@Param ： 放在dao接口的方法的形参前面， 作为命名参数使用的。    Dubbo注解@DubboService: 在提供者端使用的，暴露服务的， 放在接口的实现类上面@DubboReference:  在消费者端使用的， 引用远程服务， 放在属性上面使用。@EnableDubbo : 放在主类上面， 表示当前引用启用Dubbo功能。                        </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2022/11/01/spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.什么是Spring框架<br>  它是一个容器.它是整合其它框架的框架.它的核心是IOC和AOP.它由20多个模块构成.它在很多领域都提供优秀的解决方案.</p><p>  我们课程里学Spring , SpringMVC, SpringBoot,  SpringCloud</p><p>2.Spring的特点<br>  1)轻量级<br>  由20多个模块构成,每个jar包都很小,小于1M,核心包也就3M左右.<br>  对代码无污染.</p><p>  2)面向接口编程<br>  使用接口,就是面向灵活,项目的可扩展性,可维护性都极高.接口不关心实现类的类型.使用时接口指向实现类,切换实现类即可切换整个功能.</p><p>  3)AOP:面向切面编程<br>  就是将公共的,通用的,重复的代码单独开发,在需要的时候反织回去.底层的原理是动态代理.</p><p>  4)整合其它框架<br>  它整合后使其它框架更易用.</p><p>3.什么是IOC<br>  控制反转IoC(Inversion of Control)是一个概念，是一种思想。由Spring容器进行对象的创建和依赖注入.程序员在使用时直接取出使用.</p><p>  正转:由程序员进行对象的创建和依赖注入称为正转.程序员说了算.<br>  Student stu &#x3D; new Student();   &#x3D;&#x3D;&#x3D;&gt;程序员创建对象<br>  stu.setName(“张三”);           &#x3D;&#x3D;&#x3D;&gt;程序员进行赋值<br>  stu.setAge(22);</p><p>  反转:由Spring容器创建对象和依赖注入称为反转,将控制权从程序员手中夺走,由给Spring容器,称为反转. 容器说了算.<br>  <bean id="stu" class="com.bjpowernode.pojo.Student">     &#x3D;&#x3D;&#x3D;&gt;Spring容器负责对象的创建<br>    <property name="name" value="张三">                    &#x3D;&#x3D;&#x3D;&gt;Spring容器依赖注入值<br>    <property name="age" value="22"><br>  </bean></p><p>  切记:Spring容器在启动时,就创建所有的对象stu….</p><p>4.基于xml的IOC<br>  1)创建对象<br>  <bean id="stu" class="com.bjpowernode.pojo.Student"></bean></p><p>  2)给创建的对象赋值<br>    A.使用setter注入<br>      注入分为简单类型注入和引用类型注入<br>      简单类型注入值使用value属性<br>      引用类型注入值使用ref属性<br>      必须要注意:使用setter注入必须提供无参的构造方法,必须提供setXXX()方法.</p><pre><code>&lt;!--创建学生对象--&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.bjpowernode.pojo2.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;    ===&gt;简单类型注入    &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;school&quot; ref=&quot;school&quot;&gt;&lt;/property&gt;  ===&gt;引用类型注入&lt;/bean&gt;&lt;!--创建学校对象--&gt;&lt;bean id=&quot;school&quot; class=&quot;com.bjpowernode.pojo2.School&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;address&quot; value=&quot;海淀区&quot;&gt;&lt;/property&gt;&lt;/bean&gt;B.使用构造方法注入Student stu = new Student(&quot;张三&quot;,22);   a.使用构造方法的参数名称进行注入值        &lt;bean id=&quot;school&quot; class=&quot;com.bjpowernode.pojo3.School&quot;&gt;            &lt;constructor-arg name=&quot;name1&quot; value=&quot;清华大学&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg name=&quot;address1&quot; value=&quot;海淀区&quot;&gt;&lt;/constructor-arg&gt;        &lt;/bean&gt;   b.使用构造方法参数的下标注入值        &lt;bean id=&quot;stu&quot; class=&quot;com.bjpowernode.pojo3.Student&quot;&gt;            &lt;constructor-arg index=&quot;0&quot; value=&quot;钱七&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg index=&quot;1&quot; value=&quot;22&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg index=&quot;2&quot; ref=&quot;school&quot;&gt;&lt;/constructor-arg&gt;        &lt;/bean&gt;   c.使用默认的构造方法的参数的顺序注入值           &lt;bean id=&quot;stuSequence&quot; class=&quot;com.bjpowernode.pojo3.Student&quot;&gt;            &lt;constructor-arg value=&quot;陈十&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg value=&quot;22&quot;&gt;&lt;/constructor-arg&gt;            &lt;constructor-arg ref=&quot;school&quot;&gt;&lt;/constructor-arg&gt;        &lt;/bean&gt;</code></pre><p>5.项目案例<br>  使用三层架构进行用户的插入操作.<br>  界面层,业务逻辑层,数据访问层(模拟).</p><p>  Spring会接管三层架构中哪些对象的创建?界面层的对象,业务逻辑层的对象,数据访问层的对象.</p><p>  非Spring接管下的三层项目构建:<br>  实体类<br>  com.bjpowernode.pojo  Users<br>  数据访问层<br>  com.bjpowernode.dao   UsersMapper.java(接口)<br>                          UsersMapperImpl.java(实现类)<br>  业务逻辑层<br>  com.bjpowernode.service   UsersService.java(接口)<br>                              UsersServiceImpl.java(实现类 )<br>  界面层<br>  com.bjpowernode.controller  UsersController.java</p><p>6.基于注解的IOC<br>  也称为DI(Dependency Injection),它是IOC的具体实现的技术.</p><p>  基于注解的IOC,必须要在Spring的核心配置文件中添加包扫描.<br>  &lt;context:component-scan base-package&#x3D;”com.bjpowernode.s01”&gt;</context:component-scan></p><p>  药:  创建对象并依赖注入<br>  汤:   xml    注解annotation<br>  1)创建对象的注解<br>    @Component:可以创建任意对象.创建的对象的默认名称是类名的驼峰命名法.也可以指定对象的名称@Component(“指定名称”).<br>    @Controller:专门用来创建控制器的对象(Servlet),这种对象可以接收用户的请求,可以返回处理结果给客户端.<br>    @Service:专门用来创建业务逻辑层的对象,负责向下访问数据访问层,处理完毕后的结果返回给界面层.<br>    @Repository:专门用来创建数据访问层的对象,负责数据库中的增删改查所有操作.</p><pre><code>案例:@Component(&quot;stu&quot;)  //交给Spring去创建对象,就是在容器启动时创建public class Student &#123;    @Value(&quot;张三&quot;)  ===&gt;简单类型的值注入    private String name;    @Value(&quot;22&quot;)    private int age;    ...&#125;</code></pre><p>  2)依赖注入的注解<br>    简单类型(8种基本类型+String)的注入<br>    @Value:用来给简单类型注入值</p><pre><code>引用类型的注入A.@Autowired:使用类型注入值,从整个Bean工厂中搜索同源类型的对象进行注入.同源类型也可注入.什么是同源类型:  a.被注入的类型(Student中的school)与注入的类型是完全相同的类型  b.被注入的类型(Student中的school父)与注入的类型(子)是父子类  c.被注入的类型(Student中的school接口)与注入的类型(实现类)是接口和实现类的类型注意:在有父子类的情况下,使用按类型注入,就意味着有多个可注入的对象.此时按照名称进行二次筛选,选中与被注入对象相同名称的对象进行注入.  B.@Autowired  @Qualifier(&quot;名称&quot;):使用名称注入值,从整个Bean工厂中搜索相同名称的对象进行注入.注意:如果有父子类的情况下,直接按名称进行注入值.</code></pre><p>7.添加包扫描的方式<br>  1)单个包扫描(推荐使用)<br>    &lt;context:component-scan base-package&#x3D;”com.bjpowernode.controller”&gt;</context:component-scan><br>    &lt;context:component-scan base-package&#x3D;”com.bjpowernode.service.impl”&gt;</context:component-scan><br>    &lt;context:component-scan base-package&#x3D;”com.bjpowernode.dao”&gt;</context:component-scan><br>  2)多个包扫描,多个包之间以逗号或空格或分号分隔<br>    &lt;context:component-scan base-package&#x3D;”com.bjpowernode.controller com.bjpowernode.service ,com.bjpowernode.dao”&gt;</context:component-scan><br>  3)扫描根包(不推荐)<br>    &lt;context:component-scan base-package&#x3D;”com.bjpowernode”&gt;</context:component-scan><br>    会降低容器启动的速度,导致多做无用功.</p><p>8.为应用指定多个 Spring 配置文件<br>  当项目越来越大,需要多人合作开发,一个配置就存在很大隐患.<br>  1)拆分配置文件的策略<br>    A.按层拆<br>      applicationContext_controller.xml<br>        <bean id="uController" class="com.bjpowernode.controller.UsersController"><br>        <bean id="bController" class="com.bjpowernode.controller.BookController"><br>      applicationContext_service.xml<br>        <bean id="uService" class="com.bjpowernode.controller.UsersService"><br>        <bean id="bService" class="com.bjpowernode.controller.BookService"><br>      applicationContext_mapper.xml<br>        <bean id="uMapper" class="com.bjpowernode.controller.UsersMapper"><br>        <bean id="bMapper" class="com.bjpowernode.controller.BookMapper"></p><pre><code>B.按功能拆  applicationContext_users.xml            &lt;bean id=&quot;uController&quot; class=&quot;com.bjpowernode.controller.UsersController&quot;&gt;    &lt;bean id=&quot;uService&quot; class=&quot;com.bjpowernode.controller.UsersService&quot;&gt;    &lt;bean id=&quot;uMapper&quot; class=&quot;com.bjpowernode.controller.UsersMapper&quot;&gt;  applicationContext_book.xml          &lt;bean id=&quot;bController&quot; class=&quot;com.bjpowernode.controller.BookController&quot;&gt;    &lt;bean id=&quot;bService&quot; class=&quot;com.bjpowernode.controller.BookService&quot;&gt;    &lt;bean id=&quot;bMapper&quot; class=&quot;com.bjpowernode.controller.BookMapper&quot;&gt;</code></pre><p>9.spring配置文件的整合<br>  1)单个文件导入<br>    <import resource="applicatoinContext_mapper.xml"></import><br>    <import resource="applicatoinContext_service.xml"></import><br>    <import resource="applicatoinContext_controller.xml"></import><br>  2)批量导入<br>    <import resource="applicatoinContext_*.xml"></import><br>10.面向切面编程AOP<br>  AOP（Aspect Orient Programming），面向切面编程。<br>  切面:公共的,通用的,重复的功能称为切面,面向切面编程就是将切面提取出来,单独开发,在需要调用的方法中通过动态代理的方式进行织入.</p><p>11.手写AOP框架<br>  业务:图书购买业务<br>  切面:事务<br>  1)第一个版本:业务和切面紧耦合在一起,没有拆分.<br>  2)第二个版本:使用子类代理的方式拆分业务和切面.<br>  3)第三个版本:使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.<br>  4)第四个版本:使用静态代理拆分业务和业务接口,切面和切面接口.<br>  5)第五个版本:使用动态代理完成第四个版本的优化.</p><p>12.Spring支持的AOP的实现<br>  Spring支持AOP的编程，常用的有以下几种：<br>  1)Before通知：在目标方法被调用前调用，涉及接口org.springframework.aop.MethodBeforeAdvice;<br>  2)After通知：在目标方法被调用后调用，涉及接口为org.springframework.aop.AfterReturningAdvice;<br>  3)Throws通知：目标方法抛出异常时调用，涉及接口org.springframework.aop.ThrowsAdvice;<br>  4)Around通知：拦截对目标对象方法调用，涉及接口为org.aopalliance.intercept.MethodInterceptor。</p><p>13.AOP常用的术语<br>  1)切面:就是那些重复的,公共的,通用的功能称为切面,例如:日志,事务,权限.<br>  2)连接点:就是目标方法.因为在目标方法中要实现目标方法的功能和切面功能.<br>  3) 点(Pointcut):指定切入的位置,多个连接点构成切入点.切入点可以是一个目标方法,可以是一个类中的所有方法,可以是某个包下的所有类中的方法.</p><pre><code>4)目标对象:操作谁,谁就是目标对象.5)通知(Advice):来指定切入的时机.是在目标方法执行前还是执行后还是出错时,还是环绕目标方法切入切面功能.</code></pre><p>14.什么是AspectJ框架<br>  AspectJ 是一个优秀面向切面的框架，它扩展了 Java 语言，提供了强大的切面实现。它因为是基于java语言开发的,所以无缝扩展.easy to learn and use（易学易用）.</p><p>15.AspectJ常见通知类型<br>  AspectJ 中常用的通知有四种类型：<br>  1)前置通知@Before<br>  2)后置通知@AfterReturning<br>  3)环绕通知@Around<br>  4)最终通知@After<br>  5)定义切入点@Pointcut(了解)</p><p>16.AspectJ 的切入点表达式(掌握)<br>  规范的公式:<br>  execution(访问权限 方法返回值 方法声明(参数) 异常类型)<br>  简化后的公式:<br>  execution( 方法返回值 方法声明(参数) )</p><p>  用到的符号:</p><ul><li>代码任意个任意的字符(通配符)<br>..  如果出现在方法的参数中,则代表任意参数<br>如果出现在路径中,则代表本路径及其所有的子路径</li></ul><p>  示例:<br>  execution(public * <em>(..)) :任意的公共方法<br>  execution(</em> set*(..)):任何一个以“set”开始的方法<br>  execution(* com.xyz.service.impl.<em>.</em>(..)):任意的返回值类型,在com.xyz.service.impl包下的任意类的任意方法的任意参数<br>  execution(* com.xyz.service..<em>.</em>(..)):任意的返回值类型 ,在com.xyz.service及其子包下的任意类的任意方法的任意参数<br>                                           com.xyz.service.a.b.<em>.</em>(..)  com.xyz.service.<em>.</em>(..)<br>  execution(* <em>..service.</em>.<em>(..)):service之前可以有任意的子包<br>  execution(</em> <em>.service.</em>.*(..)):service之前只有一个包<br>17.AspectJ的前置通知@Before<br>  在目标方法执行前切入切面功能.在切面方法中不可以获得目标方法的返回值,只能得到目标方法的签名.</p><p>  实现的步骤:<br>  添加依赖<br>   <dependency><br>      <groupId>org.springframework</groupId><br>      <artifactId>spring-aspects</artifactId><br>      <version>5.2.5.RELEASE</version><br>    </dependency><br>  1)创建业务接口<br>  2)创建业务实现<br>  3)创建切面类,实现切面方法<br>  4)在applicationContext.xml文件中进行切面绑定</p><p>  项目案例:<br>  @Aspect  &#x2F;&#x2F;交给AspectJ的框架去识别切面类<br>@Component<br>public class MyAspect {<br>    &#x2F;**<br>     * 所有切面的功能都是由切面方法来实现的<br>     * 可以将各种切面都在此类中进行开发<br>     *<br>     * 前置通知的切面方法的规范<br>     * 1)访问权限是public<br>     * 2)方法的返回值是void<br>     * 3)方法名称自定义<br>     * 4)方法没有参数,如果有也只能是JoinPoint类型<br>     * 5)必须使用@Before注解来声明切入的时机是前切功能和切入点<br>     *   参数:value  指定切入点表达式<br>     *<br>     * 业务方法<br>     * public String doSome(String name, int age)<br>     <em>&#x2F;<br>    @Before(value &#x3D; “execution(public String com.bjpowernode.s01.SomeServiceImpl.</em>(String,int))”)<br>    public void myBefore(){<br>        System.out.println(“切面方法中的前置通知功能实现…………”);<br>    }</p><pre><code>@Before(value = &quot;execution(public * com.bjpowernode.s01.SomeServiceImpl.*(..))&quot;)public void myBefore()&#123;    System.out.println(&quot;切面方法中的前置通知功能实现............&quot;);&#125;@Before(value = &quot;execution( * com.bjpowernode.s01.*.*(..))&quot;)public void myBefore(JoinPoint jp)&#123;    System.out.println(&quot;切面方法中的前置通知功能实现............&quot;);    System.out.println(&quot;目标方法的签名:&quot;+jp.getSignature());    System.out.println(&quot;目标方法的参数:&quot;+ Arrays.toString(jp.getArgs()));&#125;@Before(value = &quot;execution( * com.bjpowernode.s01..*(..))&quot;)public void myBefore()&#123;    System.out.println(&quot;切面方法中的前置通知功能实现............&quot;);&#125;@Before(value = &quot;execution( * *(..))&quot;)public void myBefore()&#123;    System.out.println(&quot;切面方法中的前置通知功能实现............&quot;);&#125;</code></pre><p>}</p><p>18.AspectJ框架切换JDK动态代理和CGLib动态代理<br>    &lt;aop:aspectj-autoproxy &gt;</aop:aspectj-autoproxy>  &#x3D;&#x3D;&#x3D;&gt;默认是JDK动态代理,取时必须使用接口类型<br>    &lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&gt;</aop:aspectj-autoproxy>  &#x3D;&#x3D;&gt;设置为CGLib子类代理,可以使用接口和实现类接<br>    记住:使用接口来接,永远不出错.</p><p>19.@AfterReturning后置通知<br>   后置通知是在目标方法执行后切入切面功能,可以得到目标方法的返回值.如果目标方法的返回值是简单类型(8种基本类型+String)则不可改变.如果目标方法的返回值是引用类型则可以改变.<br>    @Aspect<br>    @Component<br>    public class MyAspect {<br>        &#x2F;**<br>         * 后置通知的方法的规范<br>         * 1)访问权限是public<br>         * 2)方法没有返回值void<br>         * 3)方法名称自定义<br>         * 4)方法有参数(也可以没有参数,如果目标方法没有返回值,则可以写无参的方法,但一般会写有参,这样可以处理无参可以处理有参),这个切面方法的参数就是目标方法的返回值<br>         * 5)使用@AfterReturning注解表明是后置通知<br>         *   参数:<br>         *      value:指定切入点表达式<br>         *      returning:指定目标方法的返回值的名称,则名称必须与切面方法的参数名称一致.<br>         <em>&#x2F;<br>        @AfterReturning(value &#x3D; “execution(</em> com.bjpowernode.s02.<em>.</em>(..))”,returning &#x3D; “obj”)<br>        public void myAfterReturning(Object obj){<br>            System.out.println(“后置通知功能实现…………..”);<br>            if(obj !&#x3D; null){<br>                if(obj instanceof String){<br>                    obj &#x3D; obj.toString().toUpperCase();<br>                    System.out.println(“在切面方法中目标方法的返回值:”+obj);<br>                }<br>                if(obj instanceof Student){<br>                    Student stu &#x3D; (Student) obj;<br>                    stu.setName(“李四”);<br>                    System.out.println(“在切面方法中目标方法的返回值:”+stu);<br>                }<br>            }<br>        }<br>    }</p><p>20.环绕通知@Around<br>  它是通过拦截目标方法的方式 ,在目标方法前后增强功能的通知.它是功能最强大的通知,一般事务使用此通知.它可以轻易的改变目标方法的返回值.<br>  @Aspect<br>@Component<br>public class MyAspect {<br>    &#x2F;**<br>     * 环绕通知方法的规范<br>     * 1)访问权限是public<br>     * 2)切面方法有返回值,此返回值就是目标方法的返回值<br>     * 3)方法名称自定义<br>     * 4)方法有参数,此参数就是目标方法<br>     * 5)回避异常Throwable<br>     * 6)使用@Around注解声明是环绕通知<br>     *   参数:<br>     *      value:指定切入点表达式<br>     *&#x2F;</p><pre><code>@Around(value = &quot;execution(* com.bjpowernode.s03.*.*(..))&quot;)public Object myAround(ProceedingJoinPoint pjp) throws Throwable &#123;    //前切功能实现    System.out.println(&quot;环绕通知中的前置功能实现............&quot;);    //目标方法调用    Object obj = pjp.proceed(pjp.getArgs());    //后切功能实现    System.out.println(&quot;环绕通知中的后置功能实现............&quot;);    return obj.toString().toUpperCase();  //改变了目标方法的返回值&#125;</code></pre><p>}<br>21.最终通知@After<br>  无论目标方法是否正常执行,最终通知的代码都会被执行.</p><p>22.给切入点表达式起别名@Pointcut<br>  如果多个切面切入到同一个切入点,可以使用别名简化开发.<br>  使用@Pointcut注解,创建一个空方法,此方法的名称就是别名.<br>    @Aspect<br>    @Component<br>    public class MyAspect {<br>        &#x2F;**<br>         * 最终通知方法的规范<br>         * 1)访问权限是public<br>         * 2)方法没有返回值<br>         * 3)方法名称自定义<br>         * 4)方法没有参数,如果有也只能是JoinPoint<br>         * 5)使用@After注解表明是最终通知<br>         *   参数:<br>         *     value:指定切入点表达式<br>         *&#x2F;<br>        @After(value &#x3D; “mycut()”)<br>        public void myAfter(){<br>            System.out.println(“最终通知的功能……..”);<br>        }</p><pre><code>    @Before(value = &quot;mycut()&quot;)    public void myBefore()&#123;        System.out.println(&quot;前置通知的功能........&quot;);    &#125;    @AfterReturning(value = &quot;mycut()&quot;,returning = &quot;obj&quot;)    public void myAfterReturning(Object obj)&#123;        System.out.println(&quot;后置通知的功能........&quot;);    &#125;    @Around(value = &quot;mycut()&quot;)    public Object myAround(ProceedingJoinPoint pjp) throws Throwable &#123;        System.out.println(&quot;环绕通知中的前置通知的功能........&quot;);        Object obj = pjp.proceed(pjp.getArgs());        System.out.println(&quot;环绕通知中的后置通知的功能........&quot;);        return obj;    &#125;    @Pointcut(value = &quot;execution(* com.bjpowernode.s04.*.*(..))&quot;)    public void mycut()&#123;&#125;&#125;</code></pre><p>23.SM整合的步骤<br>  1)建表<br>  2)新建项目,选择quickstart模板<br>  3)修改目录<br>  4)修改pom.xml文件,添加相关的依赖(使用老师提供)<br>  5)添加MyBatis相应的模板(SqlMapConfig.xml和XXXMapper.xml文件)<br>  6)添加SqlMapConfig.xml文件(MyBatis核心配置文件),并拷贝jdbc.propertiest属性文件到resources目录下<br>  7)添加applicationContext_mapper.xml<br>  8)添加applicationContext_service.xml<br>  9)添加Users实体类,Accounts实体类<br>  10)添加mapper包,添加UsersMapper接口和UsersMapper.xml文件并开发<br>  11)添加service包,添加UsersService接口和UsersServiceImpl实现类<br>  12)添加测试类进行功能测试</p><p>24.基于注解的事务添加步骤<br>  1)在applicationContext_service.xml文件中添加事务管理器<br>    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <!--因为事务必须关联数据库处理,所以要配置数据源--><br>        <property name="dataSource" ref="dataSource"></property><br>     </bean></p><p>  2)在applicationContext_service.xml文件中添加事务的注解驱动<br>    &lt;tx:annotation-driven transaction-manager&#x3D;”transactionManager”&gt;</tx:annotation-driven><br>  3)在业务逻辑的实现类上添加注解@Transactional(propagation &#x3D; Propagation.REQUIRED)<br>    REQUIRED表示增删改操作时必须添加的事务传播特性</p><p>25.@Transactional注解参数详解<br>    @Transactional(propagation &#x3D; Propagation.REQUIRED,&#x2F;&#x2F;事务的传播特性<br>            noRollbackForClassName &#x3D; “ArithmeticException”, &#x2F;&#x2F;指定发生什么异常不回滚,使用的是异常的名称<br>            noRollbackFor &#x3D; ArithmeticException.class,&#x2F;&#x2F;指定发生什么异常不回滚,使用的是异常的类型<br>            rollbackForClassName &#x3D; “”,&#x2F;&#x2F;指定发生什么异常必须回滚<br>            rollbackFor &#x3D; ArithmeticException.class,&#x2F;&#x2F;指定发生什么异常必须回滚<br>            timeout &#x3D; -1, &#x2F;&#x2F;连接超时设置,默认值是-1,表示永不超时<br>            readOnly &#x3D; false, &#x2F;&#x2F;默认是false,如果是查询操作,必须设置为true.<br>            isolation &#x3D; Isolation.DEFAULT&#x2F;&#x2F;使用数据库自已的隔离级别<br>    )<br>26.Spring的两种事务处理方式<br>  1)注解式的事务<br>    使用@Transactional注解完成事务控制,此注解可添加到类上,则对类中所有方法执行事务的设定.此注解可添加到方法上,只是对此方法执行事务的处理.</p><p>  2)声明式事务(必须掌握),在配置文件中添加一次,整个项目遵循事务的设定.</p><p>27.Spring中事务的五大隔离级别<br>  1).未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据<br>  2).提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)<br>  3).可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读<br>  4).串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞<br>  5).使用数据库默认的隔离级别isolation &#x3D; Isolation.DEFAULT<br>    MySQL：mysql默认的事务处理级别是’REPEATABLE-READ’,也就是可重复读<br>    Oracle：oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。默认系统事务隔离级别是READ COMMITTED,也就是读已提交</p><p>28.为什么添加事务管理器<br>  JDBC:  Connection   con.commit();   con.rollback();<br>  MyBatis:  SqlSession   sqlSession.commit();  sqlSession.rollback();<br>  Hibernate:  Session    session.commit();   session.rollback();</p><p>  事务管理器用来生成相应技术的连接+执行语句的对象.<br>  如果使用MyBatis框架,必须使用DataSourceTransactionManager类完成处理<br>     <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <!--因为事务必须关联数据库处理,所以要配置数据源--><br>        <property name="dataSource" ref="dataSource"></property><br>     </bean></p><p>  项目中的所有事务,必须添加到业务逻辑层上.</p><p>29.Spring事务的传播特性<br>  多个事务之间的合并,互斥等都可以通过设置事务的传播特性来解决.<br>  常用<br>  PROPAGATION_REQUIRED：必被包含事务(增删改必用)<br>  PROPAGATION_REQUIRES_NEW：自己新开事务，不管之前是否有事务<br>  PROPAGATION_SUPPORTS：支持事务，如果加入的方法有事务，则支持事务，如果没有，不单开事务<br>  PROPAGATION_NEVER：不能运行中事务中，如果包在事务中，抛异常<br>  PROPAGATION_NOT_SUPPORTED：不支持事务，运行在非事务的环境<br>  不常用<br>  PROPAGATION_MANDATORY：必须包在事务中，没有事务则抛异常<br>  PROPAGATION_NESTED：嵌套事务</p><p>30.为了测试传播特性改造项目<br>    @Service  &#x2F;&#x2F;交给Spring去创建对象<br>    @Transactional(propagation &#x3D; Propagation.REQUIRED)<br>    public class UsersServiceImpl implements UsersService {<br>        @Autowired<br>        UsersMapper usersMapper;</p><pre><code>    @Autowired    AccountsService accountsService;    @Override    public int insert(Users users) &#123;        int num = usersMapper.insert(users);        System.out.println(&quot;用户增加成功!num=&quot;+num);        //调用帐户的增加操作,调用的帐户的业务逻辑层的功能        num = accountsService.save(new Accounts(300,&quot;王五&quot;,&quot;帐户好的呢!&quot;));        return num;    &#125;&#125;</code></pre><p>31.声明式事务<br>  Spring非常有名的事务处理方式.声明式事务.<br>  要求项目中的方法命名有规范<br>  1)完成增加操作包含    add  save  insert  set<br>  2)更新操作包含   update   change  modify<br>  3)删除操作包含   delete   drop    remove  clear<br>  4)查询操作包含   select   find    search  get </p><p>  配置事务切面时可以使用通配符*来匹配所有方法<br>  <!--添加事务管理器--><br>    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"></property><br>    </bean></p><pre><code>&lt;!--配置事务切面--&gt;&lt;tx:advice id=&quot;myadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;*select*&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;*find*&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;*search*&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;*get*&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;*insert*&quot; propagation=&quot;REQUIRED&quot; no-rollback-for=&quot;ArithmeticException&quot;/&gt;        &lt;tx:method name=&quot;*add*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*save*&quot; propagation=&quot;REQUIRED&quot; no-rollback-for=&quot;ArithmeticException&quot;/&gt;        &lt;tx:method name=&quot;*set*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*update*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*change*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*modify*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*remove*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*drop*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*clear*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--绑定切面和切入点--&gt;&lt;aop:config&gt;    &lt;aop:pointcut id=&quot;mycut&quot; expression=&quot;execution(* com.bjpowernode.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;    &lt;aop:advisor  advice-ref=&quot;myadvice&quot; pointcut-ref=&quot;mycut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;</code></pre><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript笔记</title>
      <link href="/2022/11/01/javascript%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/javascript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>java是一种强类型语言，强类型怎么理解？<br>java语言存在编译阶段，假设有代码int i;<br>那么在java中有一个特点是：java程序编译阶段就已经确定了i变量的数据类型，该变量的数据类型是int类型<br>那么该变量直到最终内存释放，一直是int类型，不可能变成其他类型。<br>除非强转，否则无法改变变量类型，只能传值。还存在着精度丢失。<br>javascript中的变量？<br>    怎么声明变量？<br>        var 变量名;<br>    怎么给变量赋值？<br>        变量名&#x3D;值;<br>    JavaScript是一种弱类型语言，没有编译阶段，一个变量可以随意赋值；<br>重点：JavaScript是一种弱类型编程语言。<br>undefined在JS中是一个具体存在的值。<br>当一个变量没有被手动赋值的时候，系统默认复制undefined。</p><p>JS的函数定义方式：<br>    第一种方式：<br>        function 函数名(形式参数列表){<br>            函数体;<br>        }<br>    第二种方式：<br>        函数名&#x3D;function(形式参数列表){<br>            函数体;<br>        }<br>    function sum(a,b){<br>        a和b都是局部变量，他们都是形参（a和b都是变量名，变量名随意）<br>    }<br>定义了函数之后必须调用才会执行。<br>NaN是一个具体存在的值，该值表示不是数字，Not a Number</p><p>JS当中的方法有重载机制，JS中的函数能重载吗？<br>&#x2F;&#x2F;什么叫方法重载：同一类中相同方法名但参数不同的方法称为方法重载。<br>答：JS当中的函数在调用的时候，参数的类型没有限制，并且参数的个数也没有限制，JS就是这么的随意。<br>在JS当中，函数的名字不能重名，当函数重名的时候，后声明的函数会将之前声明的函数覆盖。<br>因为JS的弱类型特点，不严格区别参数类型，所以参数个数，类型，几个都可以，<br>而且只要是同名的函数，后写的会把前面的覆盖掉，相当于只能存在一个，而参数又不做严格区分，相当于自带重载机制<br>而java是严格区分的，所以想要传不同参数必须再写一个同名方法，但多个同名方法可以共存，系统会选择对应参数的方法去执行。</p><p>&#x2F;&#x2F;什么叫方法重写：<br>如果子类不想原封不动的继承父类中的方法，可以对方法进行重写。<br>子类继承父类中的所有方法，当需要方法重写时，需要子类中新的方法与父类中的方法名，参数类型和个数，返回值均相同。<br>方法体可根据需要任意编写，但注意返回值需要相同。</p><p>JS中的全局变量：<br>    在函数体之外声明的变量属于全局变量，全局变量的生命周期是：浏览器打开时声明，浏览器关闭时销毁，尽量少用。<br>    因为全局变量会一直存在浏览器的内存当中，耗费内存空间。<br>    能使用局部变量就用局部变量。<br>JS中的局部变量：<br>    在函数体当中声明的变量。包括一个函数的形参都属于局部变量。<br>    局部变量的生命周期是，函数开始执行局部变量的内存空间开辟，函数执行结束之后，局部变量的内存空间释放。</p><p>虽然JS中的变量在声明时不需要指定数据类型，但是在赋值时每一个数据还是有类型的<br>    JS中的数据类型包括原始类型和引用类型。<br>    EcmaScript（ES） ES6之前和ES6之后的数据类型不一样<br>    原始类型：Undefined,number,String,Boolean,Null<br>    引用类型：Object以及Object的子类</p><pre><code>ES6之后在以上的六种之外添加了一个新的类型：SymbolJS中有一个运算符叫typeof，这个运算符可以在程序的运行阶段动态的获取变量的数据类型。typeof运算符的语法格式：    typeof 变量名typeof运算符的运算结果是以下六个字符串之一，注意字符串小写undefined，number，string，boolean，object，function在js当中比较字符串使用==，没有equals</code></pre><p>求和，要求a变量和b变量将来的数据类型必须是数字，不能是其他类型<br>因为以下定义的sum函数是为了完成两个数字的求和<br>    function sum(a,b){</p><pre><code>&#125;</code></pre><p>别人去调用以上函数，可以这样写<br>    function sum(a,b){<br>        if(typeof a &#x3D;&#x3D; “number” &amp;&amp; typeof b &#x3D;&#x3D; “number”<br>        return a + b;<br>    }</p><p>Undefined类型只有一个值，这个值就是undefined<br>当一个变量没有手动赋值，系统默认赋值undefined<br>或者也可以给一个变量手动赋值undefined</p><p>Number类型包括哪些值？<br>    -1,1,2,3.14,100,….NaN Infinitiy<br>    整数，浮点数，正数负数，不是数字，无穷大都属于Number类型。<br>        什么情况下结果是NaN呢？<br>        当运算结果本应是一个数字，但最后算完不是一个数字的时候<br>    Infinity（当除数为0的时候，结果为无穷大）</p><pre><code>1.关于isNaN函数？用法isNaN(数据),结果是true表示这不是一个数字，false表示这是一个数字2.parseInt()函数 可以将字符串自动转换成数字，并且取整数位3.parseFloat()函数 可以将字符串自动转换成数字，4.Math.ceil()函数（Math是数学类，数学类当中有一个函数ceil()，作用是向上取整</code></pre><p>Boolean类型<br>    两个值，true和false<br>    在Boolean类型中有一个函数叫Boolean(),该函数的作用是将非布尔类型转成布尔类型。<br>    1 true<br>    0 false<br>    “” false<br>    “abc” true<br>    null false<br>    NaN false<br>    undefined false<br>    Infinity true</p><p>Null类型只有一个值，null</p><p>String类型<br>    在JS当中字符串可以使用单引号，也可以使用双引号<br>        var s1 &#x3D; ‘abcdef’;<br>        var s2 &#x3D; “abcdef”;<br>    在JS当中，怎么创建字符串对象呢？<br>        两种方式<br>        第一种：var s&#x3D; “abc”;<br>        第二种（使用JS内置的支持类String，可以直接用，String的父类是Object</p><pre><code>小string（属于原始类型String）var s= &quot;abc&quot;;调用内置函数的一般称为大String（属于Object类型）var y = new String(&quot;abc&quot;);无论小string还是大String，他们的属性和函数都是通用的。常用函数：    length 获取字符串长度    indexof 获取指定字符串在在当前字符串中第一次出现处的索引    lastindexof 获取指定字符串在当前字符串中最后一次出现处的索引    replace 替换    substr 截取子字符串    substring 截取子字符串    toLowerCase 转换小写    toUpperCase 转换大写    split 拆分字符串获取字符串长度    alert(x.length);    alert(&quot;http://www.baidu.com&quot;.indexof(&quot;http&quot;));//0    alert(&quot;http://www.baidu.com&quot;.indexof(&quot;https&quot;));//-1判断一个字符串中是否包含某个子字符串？    alert(&quot;http://www.baidu.com&quot;.indexof(&quot;https&quot;) &gt;=0 ? &quot;包含&quot; : &quot;不包含&quot; );//不包含replace&quot;name=value%name=value%name=value&quot;.replace(&quot;%&quot;,&quot;&amp;&quot;);//只替换了一个想全部替换需要正则表达式考点：经常问，substr和substring的区别？//substr(startIndex,length)alert(&quot;abcdefxyz&quot;.substr(2.4));//cdef//substring(startIndex,endIndex)注意：不包含endIndexalert(&quot;abcdefxyz&quot;.substring(2,4);//cdObject类型：    Object类型是所有类型的超类，自定义的任何类型，默认继承Object    Object类包括哪些属性？    复习：Java的Object类中的方法    clone方法，toString方法，equals方法，toString方法，hashcode方法，getClass方法，notify唤醒线程方法，notifyAll方法，wait等待线程方法，finalize方法（gc回收器）。    JS的Object类属性        prototype属性（最常用的）：作用是给类动态的扩展属性和函数。        constructor属性    Object类包括哪些函数？        toString方法        toLocalString方法        valueOf方法    在JS当中定义的类默认继承Object，会继承Object类当中所有的属性以及函数。    换句话说，自己定义的类当中也有prototype属性。    在JS当中怎么定义类？怎么new对象？        定义类的方法：        第一种方法：            function 类名(形参)&#123;                        &#125;        第二种方法：            类名 function(形参)&#123;                        &#125;        创建对象的语法：            new 构造方法名(实参);//构造方法名和类名一致。举个例子：有函数        function sayHello()&#123;                &#125;                sayHello();        //这种方式就表示把sayHello当做一个类来创建对象        var obj = new sayHello();//obj是一个引用，保存内存地址指向堆中的对象。JS当中类的定义，同时又是一个构造函数的定义在JS中类的定义和构造函数的定义是放在一起来定义的。</code></pre><p>可以通过prototype这个属性来给类动态扩展属性以及函数<br>    function Production(pno,pname,price){<br>        this.pno&#x3D;pno;<br>        this.pname&#x3D;pname;<br>        this.price&#x3D;price;<br>        this.getPrice &#x3D; function(){<br>            return this.price;<br>        }<br>    }</p><pre><code>var XiGua = new Product(111,&quot;西瓜&quot;,4.0)Product.prototype.getPname = function()&#123;    return this.pname;&#125;上述代码作用为假设有一个product类，通过他的prototype属性可以直接新建一个函数getPname传给product类来扩展。调用后期扩展的getPname函数    var pname=XiGua.getPname();</code></pre><p>番外：null undefined NaN有什么区别？<br>    null NaN undefined数据类型不一致。<br>    null（Object） NaN（Number） undefined（Undefined）</p><pre><code>//null和undefined可以等同。null == NaN //falsenull == undefined // trueundefined ==NaN //false    在JS当中有两个比较特殊的运算符    ==（等同运算符，只判断值是否相等）    ===（全等运算符，既判断是否相等，又判断数据类型是否相等）把上方三个例子拿下来换成三个等号，三个结果都是false</code></pre><p>JS中的常用事件<br>    blur失去焦点<br>    change下拉列表选中项改变，或文本框内容改变<br>    click鼠标单击<br>    dblclick鼠标双击<br>    focus获得焦点<br>    keydown键盘按下<br>    keyup键盘弹起<br>    load页面加载完毕<br>    mousedown鼠标按下<br>    mouseover鼠标经过<br>    mousemove鼠标移动<br>    mouseout鼠标离开<br>    mouseup鼠标弹起<br>    reset表单重置<br>    select文本被选定<br>    submit表单提交</p><pre><code>任何一个事件都会对应一个事件句柄，事件句柄是在事件前添加ononXXX这个事件句柄出现在一个标签的属性位置上。（事件句柄以属性的形式存在。）</code></pre><p>注册事件的第一种方式，直接在标签中使用事件句柄<br>    对于当前程序来说，sayHello函数被称为回调函数（callback函数）<br>    回调函数的特点：自己把这个函数代码写出来了，但是这个函数不是自己负责调用，由其他程序负责调用这个函数<br>    function sayHello(){<br>        alert(“hello js!”)<br>    }</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;hello&quot; onclick=&quot;sayHello()&quot;/&gt;java中也有回调函数，假定有一个主函数调用run方法，站在主函数的角度看run方法叫正向调用站在run方法编写者角度来看这个方法，把run方法叫做回调函数。</code></pre><p>第二种注册事件的方式，是使用纯JS代码完成事件的注册。<br>    <input type="button" value="hello2" id=mybtn /></p><pre><code>&lt;input type=&quot;button&quot; value=&quot;hello3&quot; id=mybtn1 /&gt;第一步：先获取这个按钮对象&lt;script type=text/javascript&gt;    function doSome()&#123;        alert(&quot;do some!&quot;);    &#125;(document全部小写，内置对象，可以直接用，document就代表整个html页面)    var btnObj = document.getElementById(&quot;mybtn&quot;);第二步：给按钮对象的onclick属性赋值。    btnObj.onclick = doSome;//注意，千万别加小括号，btnObj.onclick = doSome();这是错误的写法。        var mybtn1 = document.getElementById(&quot;mybtn1&quot;);    mybtn1.onclick=function()&#123;//这个函数没有名字，叫做匿名函数，这个匿名函数也是一个回调函数。        alert(&quot;test....&quot;);//这个函数在页面打开的时候只是注册上，不会被调用，在click事件发生之后才会被调用。    &#125;一行代码能不能全写出来？能    document.getElementById(&quot;mybtn2&quot;).onclick = function()&#123;        alert(&quot;test22222.....&quot;);    &#125;&lt;/script&gt;</code></pre><p>关于JS代码的执行顺序<br>    有时会遇到需要先获取对象才能绑定事件的情况，这样的话代码就必须按顺序编写，但是这样比较麻烦<br>    可以考虑使用onload句柄，等待页面全部元素加载完毕之后才会发生load事件。<br>    例子<br>    <body><br>        <script type="text/javascript"><br>            window.onload = function(){<br>                document.getElementById("mybtn2").onclick = function(){<br>                    alert("test22222.....");<br>                }<br>            }<br>        </script><br>    </body><br>    当页面加载完毕时才会发生load事件</p><p>捕捉键盘输入<br>    举例，输入账户名密码，捕捉enter键直接登录<br>        window.onload &#x3D; function(){<br>                var usernameElt &#x3D; document.getElementById(“username”).onclick &#x3D; function(){<br>                &#x2F;&#x2F;回车键的键值是13<br>                &#x2F;&#x2F;ESC的键值是27<br>                    usernameElt.onkeydown &#x3D; function(event&#x2F;&#x2F;局部变量，随便写){<br>                        &#x2F;&#x2F;获取键值<br>                        &#x2F;&#x2F;对于“键盘事件对象”来说，都有keyCode属性用来获取键值<br>                        if(event.keyCode &#x3D;&#x3D;&#x3D; 13){<br>                            alert(“正在进行验证”);<br>                        }<br>                    }</p><pre><code>            &#125;        &lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt;</code></pre><p>JS的void运算符<br>    void运算符的语法：void(表达式)<br>    运算原理：执行表达式，但不返回任何结果。<br>    javascript:void(0)<br>    其中javascript:作用是告诉浏览器后面是一段JS代码。<br>    以下程序的javascript是不能省略的。<br>    &lt;a href&#x3D;”javascript:void(0)” onclick&#x3D;”window.alert(‘test code’)&gt;<br>        既保留住超链接的样式，同时用户点击该超链接的时候执行一段JS代码，但页面还不能跳转。<br>    </a></p><p>JS的控制语句<br>    if switch while do..while.. for break continue</p><pre><code>JS特有的：for..in语句    with语句java中的数组：int[] arr=&#123;1,2,3,4,5,6&#125;;js中的数组：var arr=&#123;false,true,1,2,&quot;abc&quot;,3.14&#125;;JS数组中的元素类型随意，个数随意遍历数组    for(var i = 0;arr.length;i++)&#123;            &#125;for.. in语句for(var i in arr)&#123;    alert(arr[i]);&#125;这个i是下标for..in语句可以遍历对象的属性在JavaScript中，可以使用.和[]来访问对象的属性。二者的区别：.表示一般作为静态对象使用时来存取属性，而[]表示在动态存取属性是非常有用例：var object = &#123;name:&#39;zhangsan&#39;,age:29&#125;;var name1 = object.name;var name2 = object[&#39;name&#39;];假设这有个user函数，里面有用户名和密码两个属性。for (var shuXingMing in u)&#123;&#125;此时shuXingMing是属性名，类型为字符串with(u)&#123;    username+&quot;,&quot;+password;&#125;改变作用域，可以在指定的代码区域，直接通过节点名称调用对象就是可以不用写u.username;u.password;了，写一起比较省事但是不常用，因为你把不在这当中的属性写进去他也会一起。</code></pre><p>DOM部分<br>        JavaScript包括三大块：<br>            ECMAScript：JS的核心语法（ES规范&#x2F;ECMA-262标准）<br>            DOM：Document Object Model（文档对象模型：对网页当中的节点进行增删改的过程。）HTML文档被当成一颗DOM树来看待。<br>            BOM：Browser Object Model（浏览器对象模型）<br>        DOM和BOM的区别和联系？<br>            BOM的顶级对象是：window<br>            DOM的顶级对象是：document<br>            实际上BOM是包括DOM的<br>    获取文本框的value<br>        &lt;script type&#x3D;”text&#x2F;javascript“&gt;<br>            window.onload &#x3D; function(){<br>                document.getElementById(“setBtn”).onclick &#x3D; function(){<br>                    document.getElementById(“username2”).value &#x3D; document.getElementById(“username1”).value;<br>                }<br>            }<br>        </script></p><pre><code>    &lt;int type=&quot;text&quot; id=&quot;username1&quot; /&gt;    &lt;int type=&quot;button&quot; value=&quot;将第一个文本框中的value赋值到第二个文本框上&quot; id=&quot;setBtn&quot; /&gt;    &lt;br&gt;    &lt;int type=&quot;text&quot; id=&quot;username2&quot; /&gt;    按一下按键就把第一个文本框中输入的值复制到第二个框中</code></pre><p>innerHTML和innerText操作div和span<br>        &lt;script type&#x3D;”text&#x2F;javascript”&gt;<br>            window.onload &#x3D; function(){<br>                var btn &#x3D; document.getElementById(“btn”);<br>                btn.onclick &#x3D; function(){<br>                    &#x2F;&#x2F;设置div的内容<br>                    &#x2F;&#x2F;第一步：获取div对象<br>                    var divElt &#x3D; document.getElementById(“div1”);<br>                    &#x2F;&#x2F;第二步：使用innerHTML属性来设置元素内部的内容<br>                    &#x2F;&#x2F;divElt.innerHTML &#x3D; “asdasfssggsgdg”;<br>                    &#x2F;&#x2F;divElt.innerHTML &#x3D; “<font color='red'>用户名不能为空！</font>“; innerHTML可以解释执行后面的HTML代码<br>                    divElt.innerText &#x3D; “<font color='red'>用户名不能为空！</font>“; innerText只会把内容以文本的形式输出<br>                }<br>            }<br>        </script></p><pre><code>    &lt;input type=&quot;button&quot; value=&quot;设置div中的内容&quot; id=&quot;btn&quot;/&gt;    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;    这俩都不是方法，是属性！</code></pre><p>关于正则表达式<br>    什么是正则表达式，有什么用？<br>        正则表达式：Regular Expression<br>        正则表达式主要用在字符串格式匹配方面<br>        正则表达式实际上是一门独立的学科，在各种语言中都有支持<br>    常见的正则表达式符号？<br>        .匹配除换行符以外的任意字符<br>        \w 匹配字母或数字或下划线或汉字<br>        \s 匹配任意的空白符<br>        \d 匹配数字<br>        \b 匹配单词的开始或结束<br>        ^ 匹配字符串的开始<br>        $ 匹配字符串的结束</p><pre><code>    * 重复零次或更多次    + 重复一次或更多次    ? 重复零次或一次    &#123;n&#125; 重复n次    &#123;n,&#125; 重复n次或更多次    &#123;n,m&#125; 重复n到n次    \W 匹配任意不是字母，数字，下划线，汉字的字符    \S 匹配任意不是空白符的字符    \D 匹配任意非数字的字符    \B 匹配不是单词开头或结束的位置    [^x] 匹配除了x以外的任意字符    [^aeiou] 匹配除了aeiou这几个字母以外的任意字符    正则表达式当中的小括号()优先度较高    [1-9]表示1到9的任意一个数字（次数是一次）    [A-Za-z0-9]表示A-Za-z0-9中的任意一个字符    [A-Za-z0-9-]表示A-Z，a-z，0-9，-，以上所有字符中的任意一个字符简单的正则表达式要会写    QQ号的正则表达式：^[1-9][0-9]&#123;4,&#125;$他人编写的正则表达式要能看懂    email正则：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$怎么创建正则表达式对象，怎么调用正则表达式对象的方法？    第一种创建方式：        var regExp = /正则表达式/flags;    第二种创建方式：使用内置支持类RegExp        var regExp = new RegExP(&quot;正则表达式&quot;,&quot;flags&quot;);这里也可以写字符串，就只检索字符串    关于flags：        g：全局匹配        i：忽略大小写        m：多行搜索（ES规范制定之后才支持m），如果使用正则表达式则不能使用m    正则表达式对象的test()方法？        true / false = 正则表达式对象.test(用户填写的字符串);        true : 字符串格式匹配成功        false :字符串格式匹配失败    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function()&#123;            //给按钮绑定click            document.getElementById(&quot;btn&quot;).onclick=function()&#123;                var email = document.getElementById(&quot;email&quot;).value;                var emailRegExp = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/                var ok = emailRegExp.test(email);                if(ok)&#123;                    document.getElementById(&quot;emailError&quot;).innerText = &quot;邮箱地址合法！&quot;;                &#125;else&#123;                    document.getElementById(&quot;emailError&quot;).innerText = &quot;邮箱地址不合法！&quot;;                &#125;            &#125;            //给文本框绑定focus            document.getElementById(&quot;email&quot;).onfocus = function()&#123;                document.getElementById(&quot;emailError&quot;).innerText = &quot;&quot;;            &#125;        &#125;    &lt;/script&gt;    &lt;input type=&quot;text&quot; id=&quot;email&quot;/&gt;    &lt;span id=&quot;emailError&quot; style=&quot;color:red;font-size:12px;&quot;&gt;&lt;/span&gt;    &lt;br&gt;    &lt;input type=&quot;button&quot; value=&quot;验证邮箱&quot; id=&quot;btn&quot;/&gt;</code></pre><p>去除字符串的前后空白trim<br>    字符串类型的变量默认继承String类的一个函数trim()，作用是可以去除字符串的前后空白，但低版本的IE不支持trim函数<br>    那此时怎么办呢？<br>        可以自己对String类扩展一个全新的trim()函数<br>        String.prototype.trim &#x3D; function(){<br>            &#x2F;&#x2F;在当前的方法中的this代表的就是当前字符串<br>            this.replace<br>            return this.replace(&#x2F;^\s+),””).replace(&#x2F;\s+&amp;,””);<br>        }</p><pre><code>    注意！div独占行，span可以跟在行后边！！</code></pre><p>从这里开始接写的几个HTML看</p><p>js中直接创建数组，可以随便塞，塞多少都行，自动扩容且数据类型无限制<br>如果采用另一种方式，new Array()<br>参数什么也不写数组长度是0，写一个数代表给定长度，写更多代表直接塞元素，此时长度为参数的个数</p><p>总结：有哪些方式可以通过浏览器向服务器发送请求？<br>    1.表单form的提交<br>    2.超链接<br>    3.document.location<br>    4.window.location<br>    5.window,open(“url”)<br>    6.直接在浏览器地址栏上输入url</p><pre><code>以上所有 请求方式均可以携带数据给服务器，只有通过表单提交的数据才是动态的</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis笔记</title>
      <link href="/2022/11/01/Mybatis%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/Mybatis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.什么是三层架构<br>  在项目开发中,遵循的一种形式模式.分为三层.<br>  1)界面层:用来接收客 户端的输入,调用业务逻辑层进行功能处理,返回结果给客户端.过去的servlet就是界面层的功能.<br>  2)业务逻辑层:用来进行整个项目的业务逻辑处理,向上为界面层提供处理结果,向下问数据访问层要数据.<br>  3)数据访问层:专门用来进行数据库的增删改查操作,向上为业务逻辑层提供数据.</p><p>  各层之间的调用顺序是固定的,不允许跨层访问.<br>  界面层&lt;——-&gt;业务逻辑层&lt;——&gt;数据访问层</p><p>2.生活中的三层架构</p><p>3.常用的框架SSM.<br>  Spring:它是整合其它框架的框架.它的核心是IOC和AOP.它由20多个模块构成.在很多领域都提供了很好的解决方案.是一个大佬级别的存在.<br>  SpringMVC:它是Spring家族的一员.专门用来优化控制器(Servlet)的.提供了极简单数据提交,数据携带,页面跳转等功能.<br>  MyBatis:是持久化层的一个框架.用来进行数据库访问的优化.专注于sql语句.极大的简化了JDBC的访问.</p><p>4.什么是框架<br>  它是一个半成品软件.将所有的公共的,重复的功能解决掉,帮助程序快速高效的进行开发.它是可复用,可扩展的.<br>5.什么是MyBatis框架<br>  MyBatis 本是 apache 的一个开源项目iBatis, 2010 年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis  。2013 年 11 月迁移到 Github,最新版本是 MyBatis 3.5.7 ，其发布时间是 2021 年 4月 7日。<br>  MyBatis完成数据访问层的优化.它专注于sql语句.简化了过去JDBC繁琐的访问机制. </p><p>6.添加框架的步骤<br>  1)添加依赖<br>  2)添加配置文件</p><p>  具体步骤:<br>  1.新建库建表<br>  2.新建maven项目,选quickstart模板<br>  3.修改目录,添加缺失的目录,修改目录属性<br>  4.修改pom.xml文件,添加MyBatis的依赖,添加mysql的依赖<br>     <!--添加MyBatis框架的依赖--><br>    <dependency><br>      <groupId>org.mybatis</groupId><br>      <artifactId>mybatis</artifactId><br>      <version>3.5.6</version><br>    </dependency><br>    <!--添加mysql依赖--><br>    <dependency><br>      <groupId>mysql</groupId><br>      <artifactId>mysql-connector-java</artifactId><br>      <version>5.1.32</version><br>    </dependency><br>  5.修改pom.xml文件,添加资源文件指定<br>  6.在idea中添加数据库的可视化<br>  7.添加jdbc.properties属性文件(数据库的配置)<br>  8.添加SqlMapConfig.xml文件,MyBatis的核心配置文件<br>  9.创建实体类Student,用来封装数据<br>  10.添加完成学生表的增删改查的功能的StudentMapper.xml文件<br>  11.创建测试类,进行功能测试</p><p>  StudentMapper.xml文件<br>  <mapper namespace="zar"><br>    <!--      完成查询全部学生的功能      List<Student> getALL();         resultType:指定查询返回的结果集的类型,如果是集合,则必须是泛型的类型         parameterType:如果有参数,则通过它来指定参数的类型    --><br>    <select id="getAll" resultType="com.bjpowernode.pojo.Student" ><br>       select id,name,email,age<br>       from student<br>    </select></p><pre><code>&lt;!--  按主键id查询学生信息  Student getById(Integer id);--&gt;&lt;select id=&quot;getById&quot; parameterType=&quot;int&quot; resultType=&quot;com.bjpowernode.pojo.Student&quot;&gt;    select id,name,email,age    from student    where id=#&#123;id&#125;&lt;/select&gt;&lt;!--  按学生名称模糊查询  List&lt;Student&gt; getByName(String name);--&gt;&lt;select id=&quot;getByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.bjpowernode.pojo.Student&quot;&gt;    select id,name,email,age    from student    where name like &#39;%$&#123;name&#125;%&#39;&lt;/select&gt;&lt;!--  增加学生  int insert(Student stu);  实体类:    private Integer id;    private String name;    private String email;    private Integer age;--&gt;&lt;insert id=&quot;insert&quot; parameterType=&quot;com.bjpowernode.pojo.Student&quot;&gt;    insert into student (name,email ,age) values(#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;!--  按主键删除学生  int delete(Integer id);--&gt;&lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot; &gt;    delete from student where id=#&#123;id&#125;&lt;/delete&gt;&lt;!--  更新学生  int update(Student stu);--&gt;&lt;update id=&quot;update&quot; parameterType=&quot;com.bjpowernode.pojo.Student&quot;&gt;    update student set name=#&#123;name&#125;,email=#&#123;email&#125;,age=#&#123;age&#125;    where id=#&#123;id&#125;&lt;/update&gt;</code></pre>  </mapper><p>  测试类<br>  @Test<br>    public void testUpdate()throws IOException {<br>        &#x2F;&#x2F;1.使用流读取核心配置文件<br>        InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>        &#x2F;&#x2F;2.创建SqlSessionFactory工厂对象<br>        SqlSessionFactory factory &#x3D; new SqlSessionFactoryBuilder().build(in);<br>        &#x2F;&#x2F;3.取出SqlSession<br>        SqlSession sqlSession &#x3D; factory.openSession();<br>        &#x2F;&#x2F;4.调用方法<br>        int num &#x3D; sqlSession.update(“zar.update”,new Student(3,”hehe”,”<a href="mailto:&#x68;&#101;&#x68;&#101;&#64;&#x31;&#50;&#x36;&#x2e;&#99;&#111;&#x6d;">&#x68;&#101;&#x68;&#101;&#64;&#x31;&#50;&#x36;&#x2e;&#99;&#111;&#x6d;</a>“,30));<br>        System.out.println(num);<br>        sqlSession.commit();<br>        sqlSession.close();<br>    }</p><p>7.3MyBatis对象分析<br>  1)Resources类<br>  就是解析SqlMapConfig.xml文件,创建出相应的对象<br>  InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);</p><p>  2)SqlSessionFactory接口<br>  使用ctrl+h快捷键查看本接口的子接口及实现类<br>  DefaultSqlSessionFactory是实现类<br>  SqlSessionFactory factory &#x3D; new SqlSessionFactoryBuilder().build(in);</p><p>  3)SqlSession接口<br>  DefaultSqlSession实现类</p><p>8.为实体类注册别名<br>  1)单个注册<br>     <typeAlias type="com.bjpowernode.pojo.Student" alias="student"></typeAlias><br>  2)批量注册<br>     <!--<typeAlias type="com.bjpowernode.pojo.Student" alias="student"></typeAlias>--><br>        <!--批量注册别名          别名是类名的驼峰命名法(规范)        --><br>    <package name="com.bjpowernode.pojo"></package></p><p>9.设置日志输出<br>  <!--设置日志输出底层执行的代码--><br>    <settings><br>        <setting name="logImpl" value="STDOUT_LOGGING"/><br>    </settings><br>10.动态代理存在意义<br>  在三层架构中,业务逻辑层要通过接口访问数据访问层的功能.动态代理可以实现.</p><p>  动态代理的实现规范:<br>  1)UsersMapper.xml文件与UsersMapper.java的接口必须同一个目录下.<br>  2)UsersMapper.xml文件与UsersMapper.java的接口的文件名必须一致,后缀不管.<br>  3)UserMapper.xml文件中标签的id值与与UserMapper.java的接口中方法的名称完全一致.<br>  4)UserMapper.xml文件中标签的parameterType属性值与与UserMapper.java的接口中方法的参数类型完全一致.<br>  5)UserMapper.xml文件中标签的resultType值与与UserMapper.java的接口中方法的返回值类型完全一致.<br>  6)UserMapper.xml文件中namespace属性必须是接口的完全限定名称com.bjpowernode.mapper.UsersMapper<br>  7)在SqlMapConfig.xml文件中注册mapper文件时,使用class&#x3D;接口的完全限定名称com.bjpowernode.mapper.UsersMapper.</p><p>11.动态代理访问的步骤<br>  1)建表Users<br>  2)新建maven工程,刷新可视化<br>  3)修改目录<br>  4)修改pom.xml文件,添加依赖<br>  5)添加jdbc.propertis文件到resources目录下<br>  6)添加SqlMapConfig.xml文件<br>  7)添加实体类<br>  8)添加mapper文件夹,新建UsersMapper接口<br>  9)在mapper文件夹下,新建UsersMapper.xml文件,完成增删改查功能<br>  10)添加测试类,测试功能</p><p>12.优化mapper.xml文件注册<br>   <!--注册mapper.xml文件--><br>    <mappers><br>        <!--绝对路径注册--><br>        <mapper url="/////"></mapper><br>        <!--非动态代理方式下的注册--><br>        <mapper resource="StudentMapper.xml"></mapper><br>        <!--动态代理方式下的单个mapper.xml文件注册--><br>        <mapper class="com.bjpowernode.mapper.UsersMapper"></mapper><br>        <!--批量注册--><br>        <package name="com.bjpowernode.mapper"></package><br>    </mappers> </p><p>13.#{}占位符<br>  传参大部分使用#{}传参,它的底层使用的是PreparedStatement对象,是安全的数据库访问 ,防止sql注入.<br>  #{}里如何写,看parameterType参数的类型<br>  1)如果parameterType的类型是简单类型(8种基本(封装)+String),则#{}里随便写.<br>    <select id="getById" parameterType="int" resultType="users">  &#x3D;&#x3D;&#x3D;&gt;入参类型是简单类型<br>        select id,username,birthday,sex,address<br>        from users<br>        where id&#x3D;#{zar}  &#x3D;&#x3D;&#x3D;&gt;随便写<br>    </select><br>  2)parameterType的类型是实体类的类型,则#{}里只能是类中成员变量的名称,而且区分大小写.<br>    <insert id="insert" parameterType="users" >  &#x3D;&#x3D;&#x3D;&gt;入参是实体类<br>        insert into users (username, birthday, sex, address) values(#{userName},#{birthday},#{sex},#{address})  &#x3D;&#x3D;&gt;成员变量名称<br>    </insert><br>14.${}字符串拼接或字符串替换<br>  1)字符串拼接,一般用于模糊查询中.建议少用,因为有sql注入的风险.<br>    也分两种情况,同样的看parameterType的类型<br>    A. 如果parameterType的类型是简单类型,则${}里随便写,但是分版本,如果是3.5.1及以下的版本,只以写value.<br>    <select id="getByName" parameterType="string" resultType="users">  &#x3D;&#x3D;&#x3D;&gt;入参是简单类型<br>        select id,username,birthday,sex,address<br>        from users<br>        where username like ‘%${zar}%’   &#x3D;&#x3D;&#x3D;&gt;随便写<br>    </select><br>    B. 如果parameterType的类型是实体类的类型,则${}里只能是类中成员变量的名称.(现在已经少用)<br>    C. 优化后的模糊查询(以后都要使用这种方式)<br>    <select id="getByNameGood" parameterType="string" resultType="users"><br>        select id,username,birthday,sex,address<br>        from users<br>        where username like concat(‘%’,#{name},’%’)<br>    </select></p><p>  2)字符串替换<br>  需求:模糊地址或用户名查询<br>  select * from users where username like ‘%小%’;<br>  select * from users where address like ‘%市%’</p>  <!--    //模糊用户名和地址查询    //如果参数超过一个,则parameterType不写    List<Users> getByNameOrAddress(            @Param("columnName")  ===>为了在sql语句中使用的名称            String columnName,            @Param("columnValue")   ===>为了在sql语句中使用的名称            String columnValue);    --><pre><code>&lt;select id=&quot;getByNameOrAddress&quot; resultType=&quot;users&quot;&gt;    select id,username,birthday,sex,address    from users    where $&#123;columnName&#125; like concat(&#39;%&#39;,#&#123;columnValue&#125;,&#39;%&#39;)  ==&gt;此处使用的是@Param注解里的名称&lt;/select&gt;</code></pre><p>15.返回主键值<br>  在插入语句结束后, 返回自增的主键值到入参的users对象的id属性中.<br>  <insert id="insert" parameterType="users" ><br>        <selectKey  keyProperty="id" resultType="int" order="AFTER"><br>            select last_insert_id()<br>        </selectKey><br>        insert into users (username, birthday, sex, address) values(#{userName},#{birthday},#{sex},#{address})<br>  </insert><br>  <selectKey>标签的参数详解:<br>    keyProperty: users对象的哪个属性来接返回的主键值<br>    resultType:返回的主键的类型<br>    order:在插入语句执行前,还是执行后返回主键的值<br>16.UUID<br>  这是一个全球唯一随机字符串,由36个字母数字中划线组.<br>  UUID uuid &#x3D; UUID.randomUUID();<br>  System.out.println(uuid.toString().replace(“-“,””).substring(20));</p><p>17.什么是动态sql<br>  可以定义代码片断,可以进行逻辑判断,可以进行循环处理(批量处理),使条件判断更为简单.<br>  1)<sql>:用来定义代码片断,可以将所有的列名,或复杂的条件定义为代码片断,供使用时调用.<br>  2)<include>:用来引用<sql>定义的代码片断.<br>   <!--定义代码片断--><br>    <sql id="allColumns"><br>        id,username,birthday,sex,address<br>    </sql><br>   &#x2F;&#x2F;引用定义好的代码片断<br>   <select id="getAll" resultType="users" ><br>        select <include refid="allColumns"></include><br>        from users<br>    </select><br>  3)<if>:进行条件判断<br>    test条件判断的取值可以是实体类的成员变量,可以是map的key,可以是@Param注解的名称.<br>  4)<where>:进行多条件拼接,在查询,删除,更新中使用.<br>    <select id="getByCondition" parameterType="users" resultType="users"><br>        select <include refid="allColumns"></include><br>        from users<br>        <where><br>            <if test="userName != null and userName != ''"><br>               and username like concat(‘%’,#{userName},’%’)<br>            </if><br>            <if test="birthday != null"><br>               and birthday &#x3D; #{birthday}<br>            </if><br>            <if test="sex != null and sex != ''"><br>               and sex &#x3D; #{sex}<br>            </if><br>            <if test="address != null and address != ''"><br>                and address like concat(‘%’,#{address},’%’)<br>            </if><br>        </where><br>    </select><br>  5)<set>:有选择的进行更新处理,至少更新一列.能够保证如果没有传值进来,则数据库中的数据保持不变.<br>  <update id="updateBySet" parameterType="users"><br>        update users<br>        <set><br>            <if test="userName != null and userName != ''"><br>               username &#x3D; #{userName},<br>            </if><br>            <if test="birthday != null"><br>                birthday &#x3D; #{birthday},<br>            </if><br>            <if test="sex != null and sex != ''"><br>                sex &#x3D; #{sex},<br>            </if><br>            <if test="address != null and address != ''"><br>                address &#x3D;#{address} ,<br>            </if><br>        </set><br>        where id &#x3D; #{id}<br>    </update><br>  6)<foreach>:用来进行循环遍历,完成循环条件查询,批量删除,批量增加,批量更新.<br>    查询实现<br>    <select id="getByIds" resultType="users"><br>        select <include refid="allColumns"></include><br>        from users<br>        where id in<br>           <foreach collection="array" item="id" separator="," open="(" close=")"><br>               #{id}<br>           </foreach><br>    </select><br>      <foreach>参数详解:<br>        collection:用来指定入参的类型,如果是List集合,则为list,如果是Map集合,则为map,如果是数组,则为array.<br>        item:每次循环遍历出来的值或对象<br>        separator:多个值或对象或语句之间的分隔符<br>        open:整个循环外面的前括号<br>        close:整个循环外面的后括号</p><pre><code>批量删除实现&lt;delete id=&quot;deleteBatch&quot; &gt;    delete from users    where id in    &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;批量增加实现&lt;insert id=&quot;insertBatch&quot;&gt;    insert into users(username, birthday, sex, address) values    &lt;foreach collection=&quot;list&quot; item=&quot;u&quot; separator=&quot;,&quot; &gt;        (#&#123;u.userName&#125;,#&#123;u.birthday&#125;,#&#123;u.sex&#125;,#&#123;u.address&#125;)    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><p>18.指定参数位置<br>  如果入参是多个,可以通过指定参数位置进行传参. 是实体包含不住的条件.实体类只能封装住成员变量的条件.如果某个成员变量要有区间范围内的判断,或者有两个值进行处理,则实体类包不住.<br>  例如:查询指定日期范围内的用户信息.<br>    <!--      //查询指定日期范围内的用户    List<Users> getByBirthday(Date begin, Date end);    --><br>    <select id="getByBirthday" resultType="users"><br>        select <include refid="allColumns"></include><br>        from users<br>        where birthday between #{arg0} and #{arg1}<br>    </select><br>19.入参是map(重点掌握)<br>  如果入参超过一个以上,使用map封装查询条件,更有语义,查询条件更明确.<br>    <!--       //入参是map    List<Users> getByMap(Map map);    #{birthdayBegin}:就是map中的key    --><br>    <select id="getByMap" resultType="users" ><br>        select <include refid="allColumns"></include><br>        from users<br>        where birthday between #{birthdayBegin} and #{birthdayEnd}<br>    </select><br>    测试类中<br>    @Test<br>    public void testGetByMap() throws ParseException {<br>        Date begin &#x3D; sf.parse(“1999-01-01”);<br>        Date end &#x3D; sf.parse(“1999-12-31”);<br>        Map map &#x3D; new HashMap&lt;&gt;();<br>        map.put(“birthdayBegin”,begin);<br>        map.put(“birthdayEnd”, end);<br>        List<Users> list &#x3D; uMapper.getByMap(map);<br>        list.forEach(users -&gt; System.out.println(users));<br>    }</p><p>20.返回值是map<br>  如果返回的数据实体类无法包含,可以使用map返回多张表中的若干数据.返回后这些数据之间没有任何关系.就是Object类型.返回的map的key就是列名或别名.<br>   <!--       //返回值是map(一行)    Map getReturnMap(Integer id);    --><br>    <select id="getReturnMap" parameterType="int" resultType="map"><br>        select username nam,address a<br>        from users<br>        where id&#x3D;#{id}<br>    </select></p><pre><code>&lt;!--  //返回多行的mapList&lt;Map&gt; getMulMap();--&gt;&lt;select id=&quot;getMulMap&quot; resultType=&quot;map&quot;&gt;    select username,address    from users&lt;/select&gt;</code></pre><p>21.表之间的关联关系<br>  关联关系是有方向的.<br>  1)一对多关联:一个老师可以教多个学生,多个学生只有一个老师来教,站在老师方,就是一对多关联.<br>  2)多对一关联:一个老师可以教多个学生,多个学生只有一个老师来教,站在学生方,就是多对一关联.<br>  3)一对一关联:一个老师辅导一个学生,一个学生只请教一个老师.学生和老师是一对一.<br>  4)多对多关联:园区划线的车位和园区的每一辆车.任意一个车位可以停任意一辆车.任意一车辆车可以停在任意一个车位上.</p><p>22.一对多关联关系<br>  客户和订单就是典型的一对多关联关系.<br>  一个客户名下可以有多个订单.<br>  客户表是一方,订单表是多方.客户一中持有订单的集合.<br>  使用一对多的关联关系,可以满足查询客户的同时查询该客户名下的所有订单.<br>  <mapper namespace="com.bjpowernode.mapper.CustomerMapper"><br>   <!--     //根据客户的id查询客户所有信息并同时查询该客户名下的所有订单    Customer getById(Integer id)    实体类:    //customer表中的三个列    private Integer id;    private String name;    private Integer age;    //该客户名下的所有订单的集合    private List<Orders> ordersList;   --><br>    <resultMap id="customermap" type="customer"><br>        <!--主键绑定--><br>        <id property="id" column="cid"></id><br>        <!--非主键绑定--><br>        <result property="name" column="name"></result><br>        <result property="age" column="age"></result></p><pre><code>    &lt;!--多出来的一咕噜绑定ordersList    Orders实体类:    private Integer id;    private String orderNumber;    private Double orderPrice;    --&gt;    &lt;collection property=&quot;ordersList&quot; ofType=&quot;orders&quot;&gt;        &lt;!--主键绑定--&gt;        &lt;id property=&quot;id&quot; column=&quot;oid&quot;&gt;&lt;/id&gt;        &lt;!--非主键绑定--&gt;        &lt;result property=&quot;orderNumber&quot; column=&quot;orderNumber&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;orderPrice&quot; column=&quot;orderPrice&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getById&quot; parameterType=&quot;int&quot; resultMap=&quot;customermap&quot;&gt;    select c.id cid,name,age,o.id oid,orderNumber,orderPrice,customer_id    from customer c left  join orders o on c.id = o.customer_id    where c.id=#&#123;id&#125;&lt;/select&gt;</code></pre></mapper><p>23.多对一关联关系.<br>  订单和客户就是多对一关联.<br>  站在订单的方向查询订单的同时将客户信息查出.<br>  订单是多方,会持有一方的对象.客户是一方.<br>  <mapper namespace="com.bjpowernode.mapper.OrdersMapper"><br>    <!--      //根据主键查询订单,并同时查询下此订单的客户信息    Orders getById(Integer id);    --></p><pre><code>&lt;!--  手工绑定数据  实体类    private Integer id;    private String orderNumber;    private Double orderPrice;    //关联下此订单的客户信息,多方持有一方的对象    private Customer customer;--&gt;&lt;resultMap id=&quot;ordersmap&quot; type=&quot;orders&quot;&gt;    &lt;!--主键绑定--&gt;    &lt;id property=&quot;id&quot; column=&quot;oid&quot;&gt;&lt;/id&gt;    &lt;!--非主键绑定--&gt;    &lt;result property=&quot;orderNumber&quot; column=&quot;orderNumber&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;orderPrice&quot; column=&quot;orderPrice&quot;&gt;&lt;/result&gt;    &lt;!--多出来的一咕噜绑定        private Integer id;        private String name;        private Integer age;        //该客户名下的所有订单的集合,一方持有多方的集合        private List&lt;Orders&gt; ordersList; //不用管    --&gt;    &lt;association property=&quot;customer&quot; javaType=&quot;customer&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;cid&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getById&quot; parameterType=&quot;int&quot; resultMap=&quot;ordersmap&quot;&gt;    select o.id oid,orderNumber,orderPrice,customer_id,c.id cid,name,age    from orders o inner join customer c on o.customer_id = c.id    where o.id=#&#123;id&#125;&lt;/select&gt;</code></pre>  </mapper>24.一对一关联25.多对多关联  总结：无论是什么关联关系，如果某方持有另一方的集合，则使用<collection>标签完成映射，如果某方持有另一方的对象，则使用<association>标签完成映射。<p>26.事务<br>  多个操作同时完成,或同时失败称为事务处理.<br>  事务有四个特性:一致性,持久性,原子性,隔离性.</p><p>  下订单的业务:<br>  1)订单表中完成增加一条记录的操作<br>  2)订单明细表中完成N条记录的增加<br>  3)商品数据更新(减少)<br>  4)购物车中已支付商品删除<br>  5)用户积分更新(增加)</p><p>  在MyBatis框架中设置事务<br>  <transactionManager type="JDBC"></transactionManager>  &#x3D;&#x3D;&#x3D;&gt;程序员自己控制处理的提交和回滚</p><p>  可设置为自动提交<br>  sqlSession &#x3D; factory.openSession();  &#x3D;&#x3D;&#x3D;&gt;默认是手工提交事务,设置为false也是手工提交事务,如果设置为true,则为自动提交.<br>  sqlSession &#x3D; factory.openSession(true);  &#x3D;&#x3D;&#x3D;&gt;设置为自动提交,在增删改后不需要commit();</p><p>27.缓存<br>  MyBatis框架提供两级缓存,一级缓存和二级缓存.默认开启一级缓存.</p><p>  缓存就是为了提交查询效率.</p><p>  使用缓存后,查询的流程:<br>  查询时先到缓存里查,如果没有则查询数据库,放缓存一份,再返回客户端.下次再查询的时候直接从缓存返回,不再访问数据库.如果数据库中发生commit()操作,则清空缓存.</p><p>  一级缓存使用的是SqlSession的作用域,同一个sqlSession共享一级缓存的数据.<br>  二级缓存使用的是mapper的作用域,不同的sqlSession只要访问的同一个mapper.xml文件,则共享二级缓存作用域.<br>28.什么是ORM<br>  ORM(Object Relational Mapping):对象关系映射<br>  MyBatis框架是ORM非常优秀的框架.<br>  java语言中以对象的方式操作数据,存到数据库中是以表的方式进行存储,对象中的成员变量与表中的列之间的数据互换称为映射.整个这套操作就是ORM.</p><p>  持久化的操作：将对象保存到关系型数据库中 ,将关系型数据库中的数据读取出来以对象的形式封装</p><p>  MyBatis是持久化层优秀的框架.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于把博客搬迁到服务器上遇到的一些坑</title>
      <link href="/2022/10/25/%E5%85%B3%E4%BA%8E%E6%8A%8A%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2022/10/25/%E5%85%B3%E4%BA%8E%E6%8A%8A%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="关于把博客搬迁到服务器上遇到的一些坑"><a href="#关于把博客搬迁到服务器上遇到的一些坑" class="headerlink" title="关于把博客搬迁到服务器上遇到的一些坑"></a>关于把博客搬迁到服务器上遇到的一些坑</h1><p>首先，想要把博客搬到服务器上，顾名思义，你需要一台服务器，我这里选的是阿里云的ECS，因为最近跟做的项目基本上都是基于阿里云的，所以对这边的相对熟悉一些，但是也还是踩了不少的坑（怪我学艺不精。现在还有一些亟需解决的问题，所以在这里把我遇到的坑在这里总结一下</p><h2 id="第一步：买一台服务器吧"><a href="#第一步：买一台服务器吧" class="headerlink" title="第一步：买一台服务器吧~"></a>第一步：买一台服务器吧~</h2><p>在阿里云上选择ECS服务，在这里我们买最便宜的1core 2G 就足够我们使用了，在此处有一个小小的坑需要注意！如果你想给自己搞个域名的话，比如像baidu.com一样简单又好记的名字，那你在购买云服务器的时候记得把地区选到中国香港！！！否则的话如果你选的是国内的节点，在你使用域名的时候会有诸多的限制十分不方便，首先就是根据相关法律法规规定，你必须对你的网站进行备案，还有你购买的服务器必须是包年包月的付费模式且时长至少在三个月以上，之后还要经过复杂的手续在注册局备案，可以说是相当麻烦了，所以尽量把你的服务器选在香港！</p><p>买好了服务器，且你选的是中国香港，那你可以考虑去买一个域名，像我这个域名一年只要9块钱，总比一串又长又难记的IP地址好吧？</p><p>方法同样，在阿里云搜索域名即可，选择你你喜欢的域名进行购买即可。</p><h2 id="第二步：配置自己本地的博客到服务器上"><a href="#第二步：配置自己本地的博客到服务器上" class="headerlink" title="第二步：配置自己本地的博客到服务器上"></a>第二步：配置自己本地的博客到服务器上</h2><h3 id="连接到自己的服务器"><a href="#连接到自己的服务器" class="headerlink" title="连接到自己的服务器"></a>连接到自己的服务器</h3><p>相信看过我之前博客的同学已经搭建好了自己的博客，但是面对一台服务器还是有点儿蒙，这东西该怎么用？其实你大可不必那么紧张，你完全可以把服务器理解成是一台7X24小时不间断工作的电脑，你的女朋友可能不能24小时不间断的配在你身边，可你的服务器可是24小时随时待命的哟~好啦，玩笑话到此为止，当你购买好自己的服务器之后，创建一个新的实例，之后在密码中选择重置密码，输入一个你喜欢的密码。在详细信息里可以看到你服务器的IP地址，这里的IP地址分为两个，一个是公网IP，一个是内网IP，既然要你的博客能被大家访问到，那我们这里当然是要选择公网IP啦，复制下来这段IP，在你自己的电脑上打开cmd或者xshell或其他什么鬼的连接工具，只要他能连接到其他计算机就可以，输入下列指令</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">ssh root@公网IP</code></pre><p>此时会要求你输入密码，密码就是你刚才重置的实例密码。这时你就连接到了自己的服务器。</p><h3 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h3><p>百度宝塔面板，打开宝塔面板的官网，在官网中寻找安装方式，把安装的命令复制下来，之后粘贴进你连接到的服务器中。</p><p>等待他刷刷刷滚屏之后，出现宝塔面板的默认地址以及账号密码，此时就可以访问宝塔面板了，此时若无法访问，开放服务器的对应端口即可，使用安装完成后的提示信息给你的账号密码，这个是用来登录宝塔面板的账号密码，（这里比较推荐自己重置一下账号密码。如果没有重置不小心忘记了也不用担心，在连接到我们的服务器之后使用bt命令即可查看默认的账号和密码）。</p><p>登陆之后会提示你安装已经成功，是否安装推荐软件，选择左侧的软件然后极速安装。   耐心等待，此过程可能时间较长，等他全部安装完成，这个时候准备工作就基本完成了。</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>我们切换到连接工具，连接好服务器后，</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">yum install -y gityum install -y nodejs</code></pre><p>执行命令安装git和node.js</p><pre class="line-numbers language-none"><code class="language-none">adduser gitchmod 740 &#x2F;etc&#x2F;sudoersvi &#x2F;etc&#x2F;sudoers</code></pre><p>找到root       ALL&#x3D;(ALL)          ALL这一行</p><p>按i进入插入模式，输入git         ALL&#x3D;(ALL)          ALL</p><p>esc，输入:wq保存并退出</p><pre class="line-numbers language-none"><code class="language-none">chmod 400 &#x2F;etc&#x2F;sudoerssudo passwd git</code></pre><p>把权限改回去</p><p>切换到git用户，继续操作</p><pre class="line-numbers language-none"><code class="language-none">su git     cd ~mkdir .sshcd .sshvi authorized_keyschmod 600 ~&#x2F;.ssh&#x2F;authorized_keyschmod 700 ~&#x2F;.ssh</code></pre><p>建立ssh连接，在此之前需要在你自己的电脑上获取ssh秘钥，（路径在C:\Users\ASUS.ssh，以记事本格式打开id_rsa.pub文件，复制全部内容）把获取的秘钥粘贴进服务器的authorized_keys文件中</p><p>创建git仓库</p><pre class="line-numbers language-none"><code class="language-none">git init --bare blog.gitvi &#x2F;blog.git&#x2F;hooks&#x2F;post-receive</code></pre><p>有时可能会提示权限不足，切换为root用户进行操作也是可以的。</p><p>路径不完整，记得放在&#x2F;www&#x2F;wwwroot&#x2F;你的域名下</p><p>之后在post-receive文件中输入</p><pre class="line-numbers language-none"><code class="language-none">git --work-tree&#x3D;&#x2F;www&#x2F;wwwroot&#x2F;你的域名 --git-dir&#x3D;&#x2F;www&#x2F;wwwroot&#x2F;你的域名&#x2F;blog.git checkout -f</code></pre><p>保存退出</p><pre class="line-numbers language-none"><code class="language-none">chmod +x ~&#x2F;blog.git&#x2F;hooks&#x2F;post-receive</code></pre><p>接下来的操作需要在root用户下执行，先把用户重新切换回root用户</p><pre class="line-numbers language-none"><code class="language-none">su root输入密码cd &#x2F;www&#x2F;wwwroot&#x2F;你的域名修改文件夹权限 这步很重要 chmod 777 &#x2F;www&#x2F;wwwroot&#x2F;你的域名chmod 777 &#x2F;www&#x2F;wwwroot</code></pre><p>在本地电脑输入</p><pre class="line-numbers language-none"><code class="language-none">ssh -v git@服务器的公网ip</code></pre><p>如出现welcome to alibaba elastic service!即为成功。</p><p>修改博客配置</p><p>打开本地博客的配置文件_config.yml</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: git@你的服务器公网ip:&#x2F;www&#x2F;wwwroot&#x2F;你的域名&#x2F;git&#x2F;blog.git</code></pre><h2 id="第三步：大功告成！"><a href="#第三步：大功告成！" class="headerlink" title="第三步：大功告成！"></a>第三步：大功告成！</h2><p>至此，你已经完成了博客搬迁的全部工作，接下来只需要像以前一样，使用hexo三件套</p><p>进入你博客的目录下，右键选择GUI BASH here，经典一键三连</p><pre class="line-numbers language-none"><code class="language-none">hexo clhexo ghexo d</code></pre><p>不过此时访问你的ip地址还是会有一些问题，大概率是404 not found，因为我们还没有修改nginx的设置，打开宝塔面板，软件商店-&gt;Nginx 设置-&gt;配置修改,找到</p><pre class="line-numbers language-none"><code class="language-none">server    &#123;        listen 80;                   &#x2F;&#x2F;推荐修改为80端口        server_name myblog;          &#x2F;&#x2F;这个名字随意        index index.html index.htm index.php;        root  &#x2F;www&#x2F;wwwroot&#x2F;jyfzbznoy.top;     &#x2F;&#x2F;根据你自己服务器的设置            location ~ &#x2F;tmp&#x2F; &#123;                return 403;            &#125;</code></pre><p>修改监听端口为80端口，然后root目录为你博客的目录即可。</p><p>ps:可能会遇到的一些问题，比如修改之后依旧是404，可能是你没有开放对应的端口，当我们访问ip地址时默认访问的是80端口也就是对应的http协议的端口，https对应的端口为443，你可能需要开放这些端口，在安全组设置当中可以找到你需要的设置。还有就是你可能无法push你的博客到云服务器上，此时可以尝试删除你本地电脑博客目录下的.deploy_git文件夹再重新hexo三件套即可。</p><h2 id="一些后话（域名配置）"><a href="#一些后话（域名配置）" class="headerlink" title="一些后话（域名配置）"></a>一些后话（域名配置）</h2><p>此时你已经可以通过你的服务器公网IP访问你的博客了，但公网ip这种一串数字+字母的组合十分难记又复杂，这里推荐配置一个域名来让我们的网站更加好记和便于访问。</p><p>首先，你需要购买一个域名，在阿里云上有许多域名在售卖。他们的价格也并不昂贵，.com的域名较为昂贵，但.cn,.top等域名的价格较为廉价，选择一个你心仪的域名进行购买之后，就可以来进行配置了。</p><p>你只需要进入你刚买好的域名，然后解析DNS到你的服务器即可，但由于相关法律法规的规定，网站域名需要备案后才可以进行使用，在你关联好域名之后，需要你进行备案，我们选择个人用户非盈利目的，上传相关证件和填写信息进行备案，之后就可以使用你的域名了。</p><p>需要注意的是，使用域名的服务器需要在你购买服务器时选择包年包月模式，且剩余时长大于三个月才可进行操作。</p><h2 id="一些额外的工作"><a href="#一些额外的工作" class="headerlink" title="一些额外的工作"></a>一些额外的工作</h2><p>因为之前博客使用的是免费图床，可能加载速度非常不尽如人意，导致加载出来的图片非常的糊，这里可以选择使用阿里云的OSS对象存储服务，把我们博客需要使用的图片存储在里面，对于博客使用的图片来说，这个代价是十分小的，反正直到现在我还没有为此付费过，但是体验上的提升是十分巨大的，可以让图片的加载速度获得飞一般的提升。</p><p>如果想要博客拥有炫酷的主题，推荐自行百度hexo主题配置。篇幅过长，在本篇概不赘述，本站所使用的为butterfly主题。</p><p>最后如果觉得我的文章有用的话，请在下方的评论里让我看到你的身影哦~</p><p>期待见到各位的博客搭建成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来搭一个属于自己的博客吧</title>
      <link href="/2022/06/08/%E6%9D%A5%E6%90%AD%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/"/>
      <url>/2022/06/08/%E6%9D%A5%E6%90%AD%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建心得"><a href="#个人博客搭建心得" class="headerlink" title="个人博客搭建心得"></a>个人博客搭建心得</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>想要搭建一个像我这样的个人博客吗？其实你只需要大概三十分钟左右的时间就可以拥有这样一个和我一样的博客了，我的这个博客是基于运行在Node.js上的hexo框架运行在github pages上的，Hexo是一个基于 node.js的快速生成静态博客的开源框架,支持 Markdown和大多数 Octopress插件,一个命令即可部署到 Github页面、 Giteee、 Heroku等,强大的APl,可无限扩展,拥有<br>数百个主题和插件。但他也不是完美的，它本质上是一个静态网页生成器，每次更新内容都需要你重新把他push上去才可以，但是它是免费的啊！对于免费的东西再怎么苛责都是无意义的，那么话不多说，我们就开始吧！</p><p>你需要准备的东西：</p><p>1.Node.js</p><p>2.Git Bash</p><p>3.一个Github账号</p><p>4.一台能上网的电脑和你勤劳的小手</p><h2 id="部署Node-js"><a href="#部署Node-js" class="headerlink" title="部署Node.js"></a>部署Node.js</h2><p>这一步其实没什么好说的，根据官网引导一步一步下载安装就是，这可能是你整个步骤当中最为轻松的一步了，你所需要的就是点击<a href="https://nodejs.org/en/">Node.js官网</a>然后根据引导安装。哦对了，如果你是Windows系统的电脑，别忘了配置环境变量~</p><p>具体的教程可以参考<a href="https://blog.csdn.net/qq_48485223/article/details/122709354">NodeJS安装教程</a>。</p><p>npm下载慢的话也可以下载淘宝下载源cnpm.</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre><p>安装完成后，你就可以使用以下的命令来判断是否安装成功了。</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">node -vnpm -v</code></pre><h2 id="部署Git-Bash"><a href="#部署Git-Bash" class="headerlink" title="部署Git Bash"></a>部署Git Bash</h2><p>同样的，下载安装即可，百度搜索Gitbash下载，然后找一个下载网站提供的安装包就行，这里推荐用腾讯软件中心的，虽然版本并不能和官网同步更新，但是最起码你用他下载很快（不用翻墙）。这里是<a href="https://pc.qq.com/detail/13/detail_22693.html">GitBash下载地址</a>，点击普通下载就可以啦，具体的安装教程可以参考 <a href="https://blog.csdn.net/u010348546/article/details/124280236">GitBash安装教程</a>，基本上就是无脑下一步即可。</p><p>安装完成后，你可以通过以下dos命令查看是否安装成功。</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">git --version</code></pre><h2 id="搭建HEXO"><a href="#搭建HEXO" class="headerlink" title="搭建HEXO"></a>搭建HEXO</h2><p>到了这一步，恭喜你基本上的准备工作已经完成了。接下来你需要在你想要的地方创建一个空目录，例如D：&#x2F;myblog，然后在这个空目录右键，选择Git Bash Here。在弹出来的窗口输入以下命令。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli或者cnpm install -g hexo-cli</code></pre><p>如果此时报错你没有足够的权限，那么需要你手动以管理员身份运行GitBash，然后自行切换到对应的目录下。</p><p>安装完成后即可使用hexo -v检验是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">hexo -v</code></pre><p>然后，初始化hexo</p><pre class="line-numbers language-none"><code class="language-none">hexo init</code></pre><p>然后，安装npm</p><pre class="line-numbers language-none"><code class="language-none">npm install</code></pre><p>然后，激动人心的时候来啦，</p><pre class="line-numbers language-none"><code class="language-none">hexo server或者hexo s</code></pre><p>如果一切正常的话，在完成这一步之后，你就可以在浏览器地址栏里输入(<a href="http://localhost:4000/)%EF%BC%8C%E6%95%B2%E4%B8%8B%E5%9B%9E%E8%BD%A6%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%BC%9A%E7%9C%8B%E5%88%B0%EF%BC%8C%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B7%B2%E7%BB%8F%E6%90%AD%E5%BB%BA%E5%A5%BD%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%98%E6%90%AD%E5%BB%BA%E5%9C%A8%E6%9C%AC%E5%9C%B0%EF%BC%8C%E8%BF%98%E6%B2%A1%E6%9C%89%E8%A2%AB%E4%BC%A0%E5%88%B0%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8A%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%A6%81%E6%80%8E%E4%B9%88%E5%81%9A%E5%91%A2%EF%BC%9F">http://localhost:4000/)，敲下回车，你就会看到，你的博客已经搭建好了，但是此时我们的博客还搭建在本地，还没有被传到互联网上，那么接下来要怎么做呢？</a></p><h2 id="在Github上的工作"><a href="#在Github上的工作" class="headerlink" title="在Github上的工作"></a>在Github上的工作</h2><p>首先你需要有一个Github账号（这不是废话吗），注册完成后，点击右上角的新建仓库（New Repository），注意！给仓库起名字的时候最好全都选择成和你的用户名一样，例如填写McFranco.github.io，这样的话你就可以把这段URL当做你的域名来使用了。</p><p>创建完成后，你需要设置好SSH连接和验证你的邮箱，准备完成后，在你的博客目录下gitbash</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save</code></pre><p>这个步骤可能会非常的漫长，不要慌，耐心等待即可，或是喝杯咖啡？</p><p>好了之后，进入你的仓库的settings，给你的github pages名字设置成 你的用户名.github.io。</p><p>但是这个时候，你进入你的用户名.github.io只能看到404消息，因为这时只是建立好了连接，我们还没有真正的把我们的代码push到github仓库里，重新进入你的博客目录，然后打开该目录下的_config.yml文件，在这里进行配置。</p><h2 id="yml文件配置"><a href="#yml文件配置" class="headerlink" title="yml文件配置"></a>yml文件配置</h2><p>直接拉到文件末尾，在deploy type上输入git，然后复制你github的clone&#x2F;download下的SSH地址，填进deploy repo中。</p><p>回到上面，在url中输入你博客的地址 XXX.github.io。</p><h2 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h2><p>至此，你的博客的准备工作已经完全做好了，接下来你只需要简单的几个命令，就可以在互联网上见到你的博客了！</p><p>第一个！</p><pre class="line-numbers language-none"><code class="language-none">hexo cleanorhexo cl</code></pre><p>这一步是清理你的文件缓存，建议每次upload的时候都清一下</p><p>第二个</p><pre class="line-numbers language-none"><code class="language-none">hexo g</code></pre><p>顾名思义，hexo generate，生成你的博客页面</p><p>第三个</p><pre class="line-numbers language-none"><code class="language-none">hexo s</code></pre><p>这一步的作用是生成一个本地的预览用静态页面，可以在这里确认你的改动确实生成了之后再push到internet上，输入localhost：4000即可查看本地博客页面。</p><p>最后一步！</p><pre class="line-numbers language-none"><code class="language-none">hexo d</code></pre><p>终于到了最后一步，前面所有的努力都是值得的，这一步是让hexo deploy内容到你的github仓库，把本地的修改全部overwrite到你的仓库中。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，一个简单的博客就搭建好了，虽然他看起来没什么特别的，简单的界面，复杂的上传操作，但是基于github的免费仓库保管功能和pages的静态展示功能，你已经货真价实的拥有了一个属于自己的博客，而且这也不代表你的博客之路就到此结束了，你可以深度的魔改hexo的主题，给他加上各种花里胡哨的功能，你也可以把他搬迁到国内的gitee上，让他拥有更快的响应速度，总而言之，一切刚刚开始，现在，就动手搭建你的博客吧，期待见到各位的博客早日上线，拜拜~！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你去了英国</title>
      <link href="/2022/06/07/%E4%BD%A0%E5%8E%BB%E4%BA%86%E8%8B%B1%E5%9B%BD/"/>
      <url>/2022/06/07/%E4%BD%A0%E5%8E%BB%E4%BA%86%E8%8B%B1%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="你去了英国-x2F-文：里则林"><a href="#你去了英国-x2F-文：里则林" class="headerlink" title="你去了英国&#x2F;文：里则林"></a>你去了英国&#x2F;文：里则林</h1><p>你去了英国<br>文&#x2F;里则林<br>我再见到她时，她提着LV，一身名牌，戴着一个金贵的女式表；多了一分女人味和几分成熟。<br>一<br>15岁时，我站在楼道里，跟所有的小伙伴挥着手，送他们升入了初三，决定留下来，再读一年初二，但不是由我决定的。<br>老师对我说：“别人不交作业一次，扣5分操行分，可是我对你已经很宽容了，你每次不交作业，我只扣你0.5分，可你还是不及格。只能留级了。”说完忧愁地看向窗外。<br>我穿着中山装校服，随着他的目光，一起忧愁地看向窗外，灰蒙蒙的天空，点缀着几片当年的霾。<br>几秒过后，我点点头，觉得老师说得是有道理的，毕竟学校有学校的规章制度，况且学校不可能把我永远留在初二吧，想通这点以后，我欣然留级。<br>又一年初二，我又被安排在靠近后门的卫生角。刚刚留级下来那段时间，侥幸升上了初三的那群不知道为什么操行分能及格的校内知名“不良少年”，常常会逃课下来，在我们班后门的玻璃上，探着脑袋来围观我。围观完后，会一起大声喊我的名字，让我出去抽烟。<br>每当此时，同学们都会集体转过身来看着我，老师的眼神更是让我觉得能喷出一道闪电秒杀我。我无辜地看着他们每一个人，然后低下头，弯下腰，默默打开后门，溜了出去。<br>几个星期过后，班主任就跟年级主任反映，因为我的留级从而影响了他们班级的正常教学，经常有人在上课时间敲打后门。然后我站在教导处跟主任保证以后不会了；再站在操场求小伙伴们不要再来敲门了。被我晓之以理动之以情的他们，一时竟不知如何是好，觉得突然生命中少了一件好玩的事情，但经过思考，他们最终还是答应了。<br>之后我如去年般，开始了每天睡觉的生活。<br>二<br>老师和我都以为，我又会将一整个初二睡过去。<br>但在一个风和日丽的早上，冷清的卫生角忽然人潮涌动，热火朝天起来，我带着起床气正准备怒斥大清早就想要来拿工具搞卫生的同学，结果抬头一看，是个身材高挑的女生，小眼睛小鼻子小嘴巴，可怕的是，连胸也小。她正在搬着桌椅和书本。<br>我毫无兴致地问她：“你怎么坐到这里来了？”<br>她答：“我在前面太闹了，老师嫌我影响其他同学。”<br>我顿了顿，有种同是天涯沦落人的感觉，打了个长哈欠说：“你别在我这儿闹，好好做人，争取早日回到前排知道吗？”她点点头。我马上又“砰”的一声，狠狠地砸在课桌上，倒头睡去。<br>只是谁也没料到，从此以后，我永远都能在上课时间随时听到小声而快速的叽喳细语，讨论的全是些我听不懂的东西，从不间断，一度让我感觉全世界都是这女生的声音；下课时更经常被一阵阵狂妄的笑声惊醒。<br>这女生的声音又尖又细。我从客气地提醒她到破口大骂怒目而视，但她就是忍不住地要说话和聊天。面对这么一台聊天永动机，我甚至有时会有不知所措的委屈。<br>在一天放学时，我和老狗走在路上，我说：“狗哥，前面来了一个傻逼，每天叽叽喳喳，搞得我觉都睡不了。”<br>老狗说：“打他啊。”<br>我：“女的。”<br>老狗一听，停下脚步，点起一支烟，特别严肃地看着我说：“你这样想就不对了，你告诉我什么叫作男女平等？”<br>我心想：男女平等？<br>老狗：“你晓不晓得？人要讲究男女平等？”<br>我皱着眉头问：“怎么说？”<br>老狗把烟往地上一砸：“女的还不是一样打！而且打得更重！”<br>听完，我整个人都石化了，在那么一个明明大家都没有三观的年纪里，一旦身边的某个人假装有，那么身边的人就会全被传染。我刹那间就恍然大悟，觉得确实是这么个道理。<br>所以那天之后，我们班的卫生角经常能看到一个少女聊天聊着聊着，整个人突然往前一倒，然后惊愕地转过头去看着身后的少年。她椅子后背，全是我的脚印。<br>过了几天之后，我发现她开始背着书包上课，为了减震。我抬起一脚蹬去，她也就停顿那么几秒，回头看看书包，然后继续跟身旁的人聊天，我看着天花板，感到很无助。<br>我逐渐变本加厉，每逢下课就组织一大群小伙伴，用纸团围攻她，她虽势单力薄，也仍然一手护头一手捡起砸向她的纸团还击。<br>欺负她就成了我们的一个乐趣。每逢下课，一些发疯的小伙伴蹦蹦跳跳地到我面前来问我：“开始了吗，开始了吗！”<br>但实际上，由于她的顽强和不屈服，我心里有一股强烈的挫败感，平时大家都对我毕恭毕敬，觉得多看我一看就会被我杀掉，对此，她却丝毫不理睬。<br>在又一个课间，我一改往日的嚣张跋扈，我说我们一起下去买东西吃吧。看我第一次对她那么客气，她突然露了一点羞涩的表情，然后默默地站起来，跟我走出了教室。<br>走过阴暗的医务室楼道时，我忽然大喊一声：“弄死她！！！”一瞬间两边涌出十几个人，无数个纸团飞向她，她愣在原地被砸得劈头盖脸，看得我兴高采烈地哈哈大笑。<br>老狗抓着一个纸团飞向她，“啪”的一声，正好砸在脸上。<br>直到这时，大家才发现她一反常态地没有还击，也没有说话。突然楼道变得安静下来。<br>她突然抬脚飞向老狗，老狗整个人摔了出去——老狗以强壮著称，五年级丢实心球比体育老师还远，初中以后还创造了校纪录。打球时面对最激烈的碰撞，也从不倒下，从不动弹的他这一摔让我们叹为观止，全站在原地，张着嘴。<br>然后她从我身边走过，瞟了我一眼，这时才发现她眼睛是红的，满是委屈，我怔住了。她收回目光，低下头走了。而那个对视让我有一种说不出的奇怪感觉。<br>我那时其实是一个调皮而善良的男生。调皮过后，才突然想到，其实她也是个女生。但因为交友不慎，听信了所谓的“男女平等，女打更重”理论，导致我差点丧失了人性。一股内疚感涌上我心头。<br>我对老狗说：“其实她刚刚哭的时候还挺可爱的啊。”<br>老狗一句话都没说，估计还沉浸在那无法解释的一脚中。那天之后她得了一个外号叫“大力佼”，佼是她的名字，大力是因为她很大力。<br>那天过后，我再也没欺负过她了，虽然还是经常会骂她，但她也敢还口了，因为她大概知道，我对她有歉疚之情。<br>三<br>有一天老狗开玩笑跟我说：“你也该找个女朋友了啊。”那时我才15岁，但他对我说了35岁才会说的话。我呵呵傻笑着；想象着女朋友的画面，脑海里闪出的却是大力佼；这让我开始生自己的气，然后还得每天去克制自己去想这件事，于是我就每天都想着这件事了。<br>想着想着，我就觉得她其实挺耐看的，有时候还挺可爱的，特别是她放着一大堆零食在抽屉里，接着打开抽屉告诉我：“看到没，这么多零食，你别偷吃！”我点点头，于是她的零食基本上都被我偷吃了。<br>后来，我们之间聊天越来越频繁，有时突然沉默下来，我盯着她，她盯着我，我就尴尬地脸红了起来。<br>一段时间过后，连老狗也能看出来我喜欢上大力佼了。<br>又是一个放学的黄昏，我说：“狗哥，我喜欢一个女的。”<br>老狗：“嗯，大力佼。”<br>我连忙红着脸手舞足蹈起来：“放屁啊，老子怎么可能。”<br>老狗点起烟：“那你脸红什么？”<br>老狗又说：“别装逼，喜欢她又不丢脸，而且你要去对她说，别对我说。”说完对我眯着眼坏笑。<br>自习课上，老狗的话不断地在我脑海里回响，我趴在桌子上边睡觉边研究如何借鉴《流星花园》《还珠格格》《情深深雨蒙蒙》里的桥段进行表白。<br>正研究间，大力佼忽然转过来，用手指弹我。<br>我懒得理她。<br>她又卷起一个纸筒假装喇叭，凑到我耳边问我：“你睡着了吗？”<br>我还是一动不动。<br>接着她“喂”了两声，然后我感觉到她转过来，仔细地观察着我。<br>我依然不动。<br>然后她又把纸筒凑过来，一字一句地对我说出了我毕生难忘的一句话：“我——喜——欢——你……”<br>我耳朵能感觉到从纸筒里传来的她的气息，我头脑空白了一下，然后整个人吓了一跳，下意识地弹起来，撕心裂肺地大喊一句：“哈哈哈哈哈，你居然喜欢老子！！！”<br>同学们都被吓了一跳，转过来看着我们，大力佼还保持着用纸筒连接她嘴巴和我耳朵的状态，于是空气就凝固了，大家瞬间就明了了，我突然觉得自己可能失态了，行为太任性了。<br>大力佼力气很大，她红着脸，没有说话，抓起一本书低着头追着我就开始打，一直打到我躲进男厕所。<br>我们就这样一起早恋了。<br>四<br>早恋后的某天，我们经过一个宠物超市，看到一只猪，她很喜欢，然后我就买了。她抱着那头猪声称要好好爱护它。但在当天，那头猪对着我们哈了一口气，很臭，于是她就从来没有带那头猪回家过，一直放在我家。那是一头白天睡觉、晚上活动的猪；而它活动的内容就是在大厅瞎跑，到处撞房间的门，搞得我们都睡不着觉。有一天半夜那头猪叫得跟杀猪似的，我才发现它撞进了大厅的厕所，在坑里苦苦挣扎，我救了它，但早已心力交瘁。<br>后来，爸爸偷偷让保姆把它卖到了菜市场……为此，大力佼假装伤心了很久。那些日子里，我和大力佼时常放学走在市中心的步行街，到处瞎逛；还在情人节一起吃了个“跑堂”。有一段时间我们决定买两个本子一起写日记，过段时间再交换来看。她还常常和老狗拼酒，老狗觉得压力很大。<br>当有一天，我爸看到她时，问我：“她是不是个弱智？”当时没有“萌”这个词，我很难解释。因为她经常会说一些现在想起来很傻的话，也会做一些现在想起来很傻的事。比如找不到一直抓在手上的电话，又比如找不到电话一着急用力地甩甩手，电话飞了出去。我们一起看余文乐和高圆圆演的《男才女貌》时，我哭得不能自已，她在旁边一直无奈地看着我。<br>有一天晚修结束，一个中年魁梧男人把我截住在了校门口，我不耐烦地看着他，他用手机指着我的头，让我别再跟大力佼来往了。我心中一怔，妈的情敌都排到这个年纪了？<br>我正准备挽起袖口，决一死战，大力佼跑到旁边问了一句：“爸爸，你怎么来了？”然后大力佼的爸爸训斥了我很久，大概内容是你这么一个不务正业平常上课都找不到人的少年别带坏了我家女儿。我义正词严地说：“你不能因为成绩好坏判定一个人好坏。”<br>他爸爸反问我：“那用什么来判定？”<br>对啊，那用什么来判定？那个年纪里。我倔强地扭头就走。<br>我和大力佼仍偷偷交往。他爸后来也无可奈何，只能尽到作为一个父亲的责任，在暗处保护大力佼。比如说我和大力佼一起看电影，散场时，猛然发现她爹蹲在最后一排，偷偷窥视我们，吓得我惊出了一身冷汗。<br>十五六岁时，其实没有人懂爱是什么，但大家都以为自己懂。至于未来是什么，没有一个人知道，由于没心没肺，所以两个人才能出于最单纯的动机待在一起。<br>也因此，我们从来没想过初中毕业时会怎么样。<br>初中毕业后，爹娘决定把我送去海口上高中，因为他们希望我远离那里的环境，看能不能好好做人。<br>那个暑假，我们心里都像压着一块石头，却又像早已达成了默契，在那段日子里，绝口不提将要分隔两地的事实。我们只是如往常一样和朋友们待在一起，欢度最后的时光。<br>那个暑假，是我唯一一次感觉要倒数着过日子的日子。<br>终于到了临走前的一天晚上，我们站在路边，我假装潇洒地把脖子上的玉佩取下来，掰成两半，一人一半，我说：“这样日后我们就能相认了。”<br>她点了点头，把那半块玉放在手里，看着我，跟拍戏似的问我：“那以后我们怎么办。”<br>我故作潇洒地说：“有电话啊。”<br>她又问：“那怎么见面。”<br>我又傻笑着说：“放假我就回来了啊。”<br>我们就再也说不出一句话了。最后我送她上了回家的车。我看着那辆黄色的的士，越走越远，眼睛就红了。<br>那天回到家，父母看着我没有如往常般手舞足蹈载歌载舞地飘进门来，而是沉默不语双眼通红，姐姐拍了拍我的肩膀，说：“毕竟还小。”<br>走那天，一起长大的小伙伴们都在路边哭着把我送走了。但我唯独没让她来。<br>在海南岛，我常常面朝大海，看着对岸。幻想时间飞逝，能早日放假，见到朋友和她。<br>但实际上，那年放寒假的时候，回到重庆，和大力佼见面，却是另一次更漫长的告别。<br>爸爸厌倦了漂泊，说人总是要回到故乡的，便决定举家回到广东。心中虽然很舍不得，但看着爸爸恳求的眼神，我就没再说什么。<br>我打电话告诉完大力佼这个消息以后，她什么也没说，就挂了电话。彼此心照不宣地知道这意味着什么。<br>我一个人坐在楼下的长江边，叹了少年时代第一口也是最后一口气。感觉自己有一种全世界都不懂的无奈与悲哀。<br>那年，重庆下一了场久违的雪，细碎的雪花，触手即融。坐上回海口上学的飞机，看着江北机场，想到下一次回来，不再是某个特定的寒暑假时。觉得整个少年时代从此被一分为二。<br>回到海口，紧接而来的就是我的生日。我收到一大箱大力佼从重庆寄来的东西。上面写着：“要从下面打开”。于是我从下面把那个很重的纸箱剪开的瞬间，有几百颗糖果像水一样倾泻而下，“哗啦啦”落了一地。里面的信中写着：“要的就是这种效果。”<br>而我的初恋，莫名其妙地开始，也莫名其妙地结束了。就像这糖果一样，许多甜蜜倾泻而下，但却只能仅此一次。之后许多年，我们再也没见过。<br>五<br>时光飞逝，大四时，我去了北京实习。有一个从小一起长大的朋友来看我，我们去了南锣鼓巷，喝着酒，听着不知道哪传来的一个沙哑声音，唱了一晚上不知名的情歌。<br>也不知从哪接入的话题，她跟我聊起了我的初恋，她说：“后来她经常去酒吧，她高中时交了一个男朋友，对她不好。再后来，你也知道，她考上了川外，你最后一次见她是去年咪咪哥结婚的时候吧？那之后，她去了英国，在机场大哭着走的。”<br>我点点头，没有说话，我能想象到那个画面和她心中的惶恐。<br>那天回去的路上，坐在车上，我觉得很孤独。那种孤独并非来自异地他乡孤身一人，而是来自你在异地他乡孤身一人时想起曾经。<br>我记得咪咪哥结婚那天，我在大圆桌的一角坐着，低头玩手机，忽然听到小伙伴们几声做作的咳嗽，我抬起头，猛然看见了她，我曾设想过再见到她时，她会是什么样的，那天她提着LV，一身名牌，戴着一个金贵的女式表；多了一分女人味和几分成熟。<br>我们彼此对视了一眼，我忽然笑了，说：“你这傻逼。”然后大家都笑了。我们两个人又尴尬地看向了别处。<br>那时我想，我们只是这样而已：没有过什么激烈的争吵，没有过三观不合，没有过性格不符，也无关物质，只是纯粹的在一起。分开仅仅是因为那个年纪里，注定了没有结果和不了了之。<br>你去了英国，我却在世界的另一头想起了你，就像想起一个老朋友。时间带走的那些单纯日子，如今偶尔还会和朋友笑着谈起，只是早上再照镜子时，发现已是另外一张成熟的脸。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Articles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>姐姐</title>
      <link href="/2022/06/07/%E5%A7%90%E5%A7%90/"/>
      <url>/2022/06/07/%E5%A7%90%E5%A7%90/</url>
      
        <content type="html"><![CDATA[<h1 id="姐姐"><a href="#姐姐" class="headerlink" title="姐姐"></a>姐姐</h1><p>四季总是有一次凋零。结果无数次凋零。</p><p>相爱总是有一次分离。结果无数次分离。</p><p>1</p><p>到了大学，才发现世界上居然有超过五百块的衣服。大学毕业，才发现世界上居然有标牌子的内裤。</p><p>我在初中的时候，自己偷偷买了条二十块的短裤，结果被全家人“双规”。</p><p>曾经以为，真维斯什么的就是名牌啊，非常牛逼。突然逛街发现阿迪、耐克，大惊失色：这是金丝做的吗？</p><p>从那天开始，抢劫杀人放火的念头，我每天都有的。</p><p>一切敌不过时光。</p><p>工作之后，始终坚持认为，女人，就应该有好的化妆品，好的服饰，花再多的钱也应该。</p><p>因此我依旧穿不超过五百块的衣服、没有牌子的内裤，希望能赚到钱给女人买最好的化妆品，最好的服饰。</p><p>后来发现，女人找得到好化妆品，找得到好衣服，就是找不到好男人。</p><p>而我赚了钱也没人可以花。</p><p>赚到钱了，就慢慢开始不是好男人。</p><p>好男人，大多买不起最好的化妆品，最好的服饰。</p><p>朋友看不起身边的女人，挑三拣四。</p><p>我说：“你又不是一条好狗，凭什么要吃一块好肉？”</p><p>朋友：“男人不是狗，女人也不是肉。”</p><p>我说：“女人的确不是肉，但你真的是一条狗。”</p><p>朋友：“为什么？”</p><p>我说：“我怎么知道，我随便侮辱你。”</p><p>后来朋友结婚了。</p><p>我送Gucci（意大利时装品牌）给弟妹。</p><p>Gucci属于弟妹，那满阳台晾晒的衣服、裤子、毛巾、床单、拖把，也属于弟妹。</p><p>我和朋友说：“以后弟妹要什么，尽量买给她。就算她不要，偷偷买给她。”</p><p>朋友问：“为什么？”</p><p>我说：“因为你的阳台晒满衣服、裤子、毛巾、床单、拖把。她消耗在阳台上的每一分钟青春，你都要补偿给她。”</p><p>朋友半年后离婚。喝醉后，他趴在桌上嘀咕：“怎么就离婚了？”</p><p>我说：“有结才有离，谁让你结的？”</p><p>朋友：“是不是以前我们都搞错了？”</p><p>我说：“嗯，应该是。”</p><p>男人不是狗，女人也不是肉。</p><p>生活除了Gucci，以及满阳台的衣服、裤子、毛巾、床单、拖把，还有另外重要的东西。</p><p>什么东西？</p><p>好多啊。比如斗地主、扎金花、吃消夜什么的。</p><p>2</p><p>在电视栏目工作的时候，有个女编导。</p><p>我问她：“男人有一千万，给你一百万。或者男人有十万，给你十万，哪个更重要？”</p><p>女编导说：“一百万。”</p><p>我说：“难道全部还不如十分之一？”</p><p>女编导点头。</p><p>第二天，女编导突然急忙来找我，说：“我昨天想了一夜，觉得十万重要。”</p><p>我好奇：“你真的想了一夜？”</p><p>她点头：“嗯。”</p><p>如果你真的想了一夜，说明你有太多的心事。</p><p>既然你有心事，又何必再去想这个问题。</p><p>无论一百万还是十万，不如自己挣来的一万。</p><p>有一百万，你就是一块肉。</p><p>有十万，你就吃不到肉。</p><p>有一万，你就不用再去想一夜。</p><p>3</p><p>有关男女的问题，很小的时候，我问过姐姐。</p><p>我：“姐姐，什么叫淫荡？”</p><p>姐姐：“……热情奔放，活泼开朗。”</p><p>我：“姐姐你真淫荡。”</p><p>“啪。”我的左脸被抽肿。</p><p>我：“姐姐，什么叫下贱？”</p><p>姐姐：“……就是谦恭有礼，勤劳节约。”</p><p>我：“姐姐你真下贱。”</p><p>“啪。”我的右脸被抽肿。</p><p>我：“姐姐，什么叫爱情？”</p><p>姐姐：“……就是淫荡加下贱。”</p><p>我：“姐姐你一点儿也不爱情。”</p><p>过了半天，姐姐“嗯”了一声。</p><p>过了十年，我才明白，为什么泪水突然在她的眼眶里打转。</p><p>4</p><p>十年之后。</p><p>我坐在写字桌前，泪水在眼眶里打转。精神恍惚，脑海空白，痛到不能呼吸。</p><p>姐姐过来，鼓励我：“小伙子把胸膛挺起来。”</p><p>我：“我们都没有胸，挺个屁。”</p><p>姐姐出奇地没有愤怒，一甩头发说：“帮我下碗面条去，人一忙就没空胡思乱想。”</p><p>我垂头丧气：“吃什么面，用舌头舔舔牙床好了。”</p><p>“啪啪。”我被连抽两个耳光。</p><p>“好了好了，我去下面我去下面。”</p><p>忙活一会儿，把面递给她。姐姐笑嘻嘻地端着面，看着我。</p><p>她吃了几口，突然回到自己房间。</p><p>三年之后，我看到她的日记。</p><p>“弟弟下的面里，连盐都没有加，我想，如果不是非常非常难过，也就不会做出这么难吃的面。我也很难过。”</p><p>我突然嘴角有点儿咸。</p><p>我想，如果这滴眼泪穿过时光，回到三年前，回到那个碗里，姐姐一定不觉得面很淡，那么她就不会难过。</p><p>5</p><p>“抓小偷啊！”街头传来凄厉的尖叫。</p><p>我跟姐姐互相推诿。</p><p>“弟弟你上！你懂不懂五讲四美？”</p><p>“姐姐你上！你懂不懂三从四德？”</p><p>“推脱什么，抓小偷不是请客吃饭，上！”</p><p>“好，上！”</p><p>两个人迅速往前冲。冲到一半，我往左边路口拐，姐姐往右边路口拐。</p><p>两个人躲在巷子口大眼瞪小眼。小偷从两人之间狂奔而过。</p><p>呼，差点儿被撞到。两个人同时拍拍胸口。</p><p>这时紧跟小偷后面，狂奔过去另一个人。</p><p>我们一看……是老妈。</p><p>老妈一边追一边喊：“抓小偷啊！”</p><p>两个人拼死抓住了老妈，没抓到小偷……回家之后，一人赔给老妈五百块。</p><p>第二天醒来，姐姐在枕头底下发现了五百块。</p><p>我在枕头底下发现了五百块，闹钟底下发现了五百块。</p><p>我一直搞不清楚，为什么放走一个小偷，我凭空赚了五百块。</p><p>等到学会四则混合运算之后，我终于计算明白。</p><p>很久之后，我想，如果我还有机会把五百块放回姐姐枕头底下，那么即使小偷手里有刀，我也会冲上去的。</p><p>嗯，是这样。</p><p>6</p><p>小时候家里只有一辆自行车。28吋大杠永久。</p><p>爸爸说生日那天给我骑。</p><p>我仰天大笑：“哈哈哈哈，爸爸你终于不爱姐姐只爱我了。”</p><p>爸爸说：“你姐姐早就骑过了。”</p><p>过了几年，姐姐有了一辆自行车。每天上学都是她骑车带我。</p><p>我：“姐姐我骑车带你吧。”</p><p>姐姐：“滚。”</p><p>我：“妈的，老子力气太多了用不完。”</p><p>姐姐：“滚。”</p><p>得到这样的回复，我很生气，就在车子后面滚来滚去。</p><p>“啊！”“砰！”两个人从小桥上摔下去了。</p><p>姐姐：“呜呜呜呜，我以后再也不带你了。”</p><p>我：“呜呜呜呜，你骑车水平跟阿黄一样。”</p><p>姐姐：“阿黄是谁？”</p><p>我：“阿黄是舅舅家养的狗。”</p><p>姐姐：“你是浑蛋。”</p><p>我：“你是母浑蛋。”</p><p>就如此吵了很久，直接导致上学迟到。</p><p>又过了几年，我们去大城市的舅舅家玩。</p><p>姐姐又骑车带我。有人喊，下车。哇，是交警耶。</p><p>我：“警察叔叔你抓她，是她骑车带我的，我是小孩子你不能抓。”</p><p>姐姐：“警察哥哥你抓他，是他要坐我车的，我是中学生你不能抓。”</p><p>警察一身冷汗。</p><p>我：“警察叔叔你抓她，我不认识她。”</p><p>姐姐：“警察哥哥你抓他，他是我在路边拣的。”</p><p>我：“拣个鬼，你要不要脸。”</p><p>姐姐：“要个魂，马上要罚款了，还要什么脸。”</p><p>警察：“你们走吧……以后不要骑车带人了。”</p><p>姐姐终于要去外地上大学了，把那辆自行车留给了我。我很开心。</p><p>一晚上没睡着。</p><p>我们全家送姐姐。</p><p>姐姐上了火车。</p><p>我突然眼泪哗啦啦流，一边流还一边追火车。</p><p>姐姐我把车子还给你，你不要走啦。</p><p>姐姐隔着车玻璃喊。</p><p>我听不见，但是可以从她的口型认出来：</p><p>不要哭。</p><p>我拼命追，用手背抹眼泪，拼命喊：“狗才哭，我没有哭！”</p><p>从那个时候开始，我最害怕听到火车的汽笛。</p><p>听到汽笛，就代表要分离。</p><p>送走姐姐之后，我骑车去上学，被很多很多同学笑话。</p><p>因为那是一辆女式自行车。</p><p>大家说我是人妖，说我娘娘腔。</p><p>我依旧骑，因为感觉姐姐就在自己身边。</p><p>到了现在，我走到储藏间，看到这辆自行车，还是会不停掉眼泪，小声说，掉你大爷，掉你大爷。</p><p>7</p><p>1988年，舅舅送给我一个从未见识过的东西，邮票年册。</p><p>我很愤怒：“姐姐，舅舅太小气了，送一堆纸片给我。”</p><p>姐姐：“那你十块钱卖给我。”</p><p>我：“太狡诈了！你当我白痴哪，这堆纸片后面写着定价，一百九十八。”</p><p>姐姐：“纸片越来越不值钱，你现在不卖，明年就只值一块。”</p><p>我：“为什么？”</p><p>姐姐：“你没看到这里写着：保值年册，收藏极品。什么叫保值？就是越来越不值钱。卖不卖？”</p><p>我：“……二十块。”</p><p>姐姐：“成交。”</p><p>于是每年的邮票年册，我都以二十块的价格卖给姐姐。</p><p>一直卖到1992年，四本一共八十块。由于压岁钱都要上缴，所以这八十块成了我无比珍贵的私房钱。而且从这一年起，舅舅不再送了，小气鬼。</p><p>当年姐姐去外地上大学。</p><p>第二天她就要离去。我在床上滚了一夜，十六张五块钱，你一张，我一张，数了一夜。</p><p>一直在想：她去外地，会不会被人欺负？哎呀，以前她被人欺负，都是给我两毛钱，让我骂人家的。</p><p>那她去了那么远的地方，一定要带钱。</p><p>嗯，给她十块。可以请人骂……骂五十次。</p><p>万一被人打怎么办？她上次被婶婶打，她说给五毛钱，我都不愿意帮她打，外面人肯定价格更高！</p><p>打手请一次算一块好了，给她二十。</p><p>我心疼地看着钱被分成了两沓，而且她那沓慢慢比我这沓还高。</p><p>算着算着我睡着了。</p><p>最后我塞在姐姐包里的，是八十块。</p><p>送走姐姐那个瘟神，我人财两空，回到家里，忽然非常沮丧，就躲进被子睡觉。</p><p>在被子里，我发现了四本年册。</p><p>每本年册里，都夹着二十块。</p><p>我躲在被子里，一边哭，一边骂，姐姐和舅舅一样小气，一本只夹二十块，人都走了，起码夹五十块对不对？</p><p>到了今天，这些夹着二十块的年册，整四本，还放在我的书架上。</p><p>一天我擦擦灰尘，突然翻到1988年的那本，封背有套金的小字，写着定价一百九十八。</p><p>“那你十块钱卖给我。”</p><p>“太狡诈了！你当我白痴哪，这堆纸片后面写着定价，一百九十八。”</p><p>“纸片越来越不值钱，你现在不卖，明年就只值一块。”</p><p>“为什么？”</p><p>“你没看到这里写着：保值年册，收藏极品。什么叫保值？就是越来越不值钱。卖不卖？”</p><p>眼泪滴滴答答，把一百九十八，变得那么模糊。</p><p>8</p><p>姐姐：“坏人才抽烟。”</p><p>我：“那舅舅是坏人。”</p><p>姐姐：“做到教授再抽烟，就是好人。”</p><p>我：“你有没有逻辑。你会算log函数，你懂风雅颂，你昨天把黑格尔说成格外黑，你是逻辑大王。”</p><p>吵了好几天，姐姐回大学了。</p><p>我在抽屉里找到报纸包好的一条香烟，里面是一条中华。</p><p>姐姐写着纸条：如果一定要抽，那也抽好一点儿的，至少对身体伤害少一点儿。</p><p>我至今还记得，那是一张《扬子晚报》，1997年5月22日。</p><p>后来我遇到了一个姑娘叫姜微。</p><p>姜微：“你喜欢抽什么烟？”</p><p>我：“我喜欢抽好一点儿的。”</p><p>姜微：“为什么？”</p><p>我：“对身体伤害少一点儿。”</p><p>寒假结束之后，她带了一包烟给我。一包中华。里面只有十一根烟。四根中华，四根玉溪，三根苏烟。</p><p>总比没有好。</p><p>我：“你哪里来的烟？”</p><p>姜微：“过年家里给亲戚发烟，我偷偷一根根收集起来的。”</p><p>我：“寒假二十天，你只收集到十一根？”</p><p>姜微：“还有七根，被我爸爸发现没收了。”</p><p>后来姜微消失了。《扬子晚报》在我的书架上。那张《扬子晚报》里，我夹着一个中华香烟的烟壳。</p><p>只有这两个女人，以为抽好一点儿的烟，会对身体的伤害少一点儿。</p><p>突然听到winamp（一种音乐播放器）里在放《电台情歌》。</p><p>一个美丽的女子要伸手熄灭天上的月亮，一个哭泣的女子牵挂不曾搭起的桥梁，自此一枕黄粱，一时荒凉，疼辄不能自已，掌纹折断。</p><p>这里是无所不痛的旋律。</p><p>姐姐再也不会痛，姜微不知道在哪里。希望她比我快乐。并且永远快乐。</p><p>9</p><p>姐姐教我打字花了半年的时间。打字课程，1998年8月27日开始教授，9月1日她回大学，自动转为函授。</p><p>我：“A后面不是B吗，为什么排的是S？B后面不是C吗，为什么排的是N？”</p><p>姐姐：“Christopher（打字机之父）发明的，跟我没有关系。”</p><p>我：“字母这么乱一伦，姨妈和叔叔凑在一起，它们家谱和希腊神话一个教养。”</p><p>姐姐：“你他妈的学不学？”</p><p>我：“字母太乱一伦了，玷污我的视线！”</p><p>姐姐：“让你掌握键盘的顺序，和乱一伦有什么关系？”</p><p>我：“己所不欲，勿施于人，要是我摸你胸你一定用刀杀了我。”</p><p>“啪啪”。我左脸和右脸全部肿了。</p><p>姐姐：“学会打字对你有好处的，可以泡妞。”</p><p>我：“泡什么妞，我不如把钱省下来买三级片。”</p><p>姐姐：“你看你看，这叫作QQ，可以让远方的MM脱胸罩。”</p><p>我：“是黛安芬的吗？”</p><p>姐姐：“你学会了不就可以自己问了吗？”</p><p>于是姐姐帮我申请了一个QQ号，然后两个人搜索各地的MM。在姐姐指导下，我加了一个北京MM，ID是无花果。</p><p>我有了点儿兴趣。</p><p>发了句话：Girl, fuck fuck，哈哈。</p><p>一点儿反应也没有。</p><p>我又发了句话：Dog sun, please,fuck！</p><p>一点儿反应也没有。</p><p>我发火了，一下发了三句话：MBD, MBD, MBD。</p><p>姐姐发火了，说：人家头像是灰色的，说明不在线。</p><p>不在线，还Q什么，Q他妈蛋。</p><p>我立刻失去兴趣。</p><p>姐姐诱惑我，如果学会打字，就可以用流畅的语言勾引她。这被我断然拒绝，正直的青年，一定和我一样会拒绝的。</p><p>这些乱一伦的字母，不是好东西。</p><p>1998年9月1日，姐姐回大学，把电脑带回去了。</p><p>我唯一遗憾的是，《仙剑奇侠传》没有通关，月如刚刚死在镇妖塔。</p><p>但姐姐不会这么小气吧？我就开始翻姐姐的房间。</p><p>我在她房间翻到的东西有：席绢的《交错时空的爱恋》，沈亚、于晴全集……这是什么玩意儿？星座是什么玩意儿？把所有东西摔出来，箱子底下是一张纸制键盘。</p><p>键盘上有一张字条：我知道你会翻到这里，麻烦你学习一下字母的顺序。</p><p>我大惊失色，全世界的姐姐都这么狡猾吗？</p><p>结果我就在纸质的键盘和电话里督促的声音中，过了一个学期。</p><p>我：“A后面为什么是S，而不是B？”</p><p>姐姐：“A后面是S，B后面是N。”</p><p>我：“复杂得要死。”</p><p>整整半年，我依旧不能理解字母为何如此乱一伦。乱一伦的东西，如我般正直，都不会学习的。</p><p>1999年2月7日深夜11点47分。</p><p>我依然等在火车站。</p><p>因为姐姐说她那一分钟回到家。</p><p>结果等到1999年2月8日4点30分。</p><p>姐姐和一辆轿车拼命，瞬间损失了所有HP（生命值）。</p><p>1999年2月8日17点48分，我赶到了北京。</p><p>房间一片雪白。</p><p>使者的翅膀雪白。天堂的空间雪白。病房的床单雪白。姐姐的脸色雪白。</p><p>她全身插满管子。</p><p>脸上盖着透明的呼吸器。</p><p>我快活地奔过去：“哈哈，不能动了吧？”</p><p>她脸上没有一丝表情，紧闭双眼，为什么我看到她仿佛在微笑？</p><p>要么我眼花了，要么她又偷了我写给隔壁班花的情书。</p><p>旁边一个穿白大褂的人说：“她不能说话，希望有力气写字给你。”</p><p>可是，姐姐抓不住笔。</p><p>这货，从来就没有过力气。</p><p>坐她自行车她没有力气上坡，和她打架她没有力气还手，争电视节目她没有力气抢遥控器。</p><p>她不写字，我就不会知道她要说什么。我想，她应该有力气写字的呀！</p><p>她帮我在考卷上冒充妈妈签字。她帮我在《过好寒假》上写作文。</p><p>她帮我在作业本子上写上名字。</p><p>我呆呆地看着她，怎么突然就没有力气了呢？</p><p>我去抓住她的手。</p><p>她用手指在我掌心戳了几下。</p><p>1，2，3，4，5，6。</p><p>一共六下。</p><p>她戳我六下干什么？</p><p>六六大顺？她祝我早日发财？</p><p>六月飞雪？她有着千古奇冤？</p><p>六神无主？她又被男人甩了？</p><p>六道轮回？她想看圣斗士冥王篇？</p><p>我拼命猜测的时候，突然冲进来一群人，把她推走了。</p><p>我独自待在这病房里，看着一切雪白，努力戳着自己的手掌。</p><p>1，2，3，4，5，6。</p><p>一共六下。</p><p>上面戳一下，右边戳一下，上面再戳一下，下面戳一下，上面再戳一下，又戳一下。</p><p>我拼命回忆着有关键盘的记忆。</p><p>一张纸质的键盘，看了半年，也开始浮现在脑子里。</p><p>A后面是S，B后面是N，C后面是V……我一下一下地在这张键盘里敲击过去。</p><p>1，2，3，4，5，6。</p><p>键盘慢慢清晰起来。</p><p>我终于明白了这六下分别戳在什么地方。</p><p>I LOVE U。</p><p>眼泪夺眶而出，一滴滴滚下来，滴下来，扑下来。</p><p>1999年2月8日19点10分，我终于掌握了键盘的用法，学会了打字。</p><p>并且刻骨铭心，永不忘记。</p><p>I LOVE U。</p><p>我缩在走廊里面。</p><p>在很久之后，我才有勇气把姐姐留下的电脑装起来。</p><p>装起来之后，又过了很久，我才打开了那个QQ号码。</p><p>只有一个联系用户。</p><p>无花果。</p><p>虽然是灰色，据说是灰色，是因为不在线。</p><p>可这个头像是跳动的。</p><p>我双击它。</p><p>无花果说：</p><p>笨蛋，我是你老姐。</p><p>我哭得像一个孩子，可是无论多少泪水，永远不能把无花果变成彩色。</p><p>无花果永不在线。</p><p>如果还有明天，小孩子待在昨天，明天没有姐姐，姐姐在昨天用着Windows98。</p><p>到了今天，MSN退役，弄潮儿对着摄像头跳脱衣舞，我书房电脑的显示屏上，依旧挂着五位数的QQ，永远只有一个联系用户，并且头像灰色，永不在线，ID叫作无花果。</p><p>生育总是有一次阵痛。结果无数次阵痛。</p><p>相爱总是有一次分离。结果无数次分离。</p><p>四季总是有一次凋零。结果无数次凋零。</p><p>自转总是有一次日落。结果无数次日落。</p><p>然而无花果永远是灰色。</p><p>伤心欲笑，痛出望外，泪无葬身之地，哀莫过大于心不死。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Articles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb笔记</title>
      <link href="/2022/06/07/javaweb%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/07/javaweb%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet-JSP笔记"><a href="#Servlet-JSP笔记" class="headerlink" title="Servlet-JSP笔记"></a>Servlet-JSP笔记</h1><ol><li>Hello，你好！这是我的第一篇博客！很高兴你能看到这些内容，这说明我的网站建设成功了。</li><li>这是我最近记录的一些笔记，今后我也会在这上面分享更多的编程、剪辑、摄影、游戏技巧和心得。</li><li>希望能和大家共同进步。</li></ol><h1 id="需要提前准备了哪些技术，才能理解接下来的内容？"><a href="#需要提前准备了哪些技术，才能理解接下来的内容？" class="headerlink" title="需要提前准备了哪些技术，才能理解接下来的内容？"></a>需要提前准备了哪些技术，才能理解接下来的内容？</h1><ul><li>JavaSE（Java语言的标准版，Java提供的最基本的类库）<ul><li>Java的开发环境搭建</li><li>Java的基础语法</li><li>Java的面向对象</li><li>数组</li><li>常用类</li><li>异常</li><li>集合</li><li>多线程</li><li>IO流</li><li>反射机制</li><li>注解Annotation</li><li>…..</li></ul></li><li>MySQL（数据库）<ul><li>最基本的要求是：能够编写增删改查等简单的SQL语句即可。</li></ul></li><li>JDBC（Java语言链接数据库）<ul><li>这是一套Java语言链接数据库的接口。</li></ul></li><li>WEB前端（会一些）<ul><li>HTML（网页）</li><li>CSS（层叠样式表语言，修饰HTML）</li><li>JavaScript（一种脚本语言，运行在浏览器当中，让浏览器中的元素可以增删改。让网页产生更强的交互效果）</li></ul></li><li>WEB后端<ul><li>Servlet（Server Applet：服务器端的Java小程序）</li><li>JSP</li><li>AJAX</li><li>jQuery</li><li>MyBatis</li><li>Spring</li><li>SpringMVC</li><li>SpringBoot</li><li>SpringCloud</li><li>……</li></ul></li></ul><h1 id="Typora软件介绍"><a href="#Typora软件介绍" class="headerlink" title="Typora软件介绍"></a>Typora软件介绍</h1><ul><li><p>Markdown文本编辑器（可以编辑xxx.md文件）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;Test code!&quot;);    &#125;&#125;</code></pre></li></ul><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="关于系统架构"><a href="#关于系统架构" class="headerlink" title="关于系统架构"></a>关于系统架构</h2><ol><li>系统架构包括什么形式？<ul><li>C&#x2F;S架构</li><li>B&#x2F;S架构</li></ul></li><li>C&#x2F;S架构？<ul><li>Client &#x2F; Server（客户端 &#x2F; 服务器）</li><li>C&#x2F;S架构的软件或者说系统有哪些呢？<ul><li>QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就可以和你的朋友聊天了，就可以使用这个软件了。）</li></ul></li><li>C&#x2F;S架构的特点：需要安装特定的客户端软件。</li><li>C&#x2F;S架构的系统优点和缺点分别是什么？<ul><li>优点：<ul><li>速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C&#x2F;S结构的系统速度快）</li><li>体验好（速度又快，界面又酷炫，当然体验好了。）</li><li>界面酷炫（专门的语言去实现界面的，更加灵活。）</li><li>服务器压力小（因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小。）</li><li>安全（因为大量的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C&#x2F;S结构的系统比较安全。）</li><li>…..</li></ul></li><li>缺点：<ul><li>升级维护比较差劲。（升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。）</li></ul></li></ul></li></ul></li><li>B&#x2F;S架构？<ul><li>B&#x2F;S（Browser &#x2F; Server，浏览器 &#x2F; 服务器）</li><li><a href="http://www.baidu.com/">http://www.baidu.com</a></li><li><a href="http://www.jd.com/">http://www.jd.com</a></li><li><a href="http://www.126.com/">http://www.126.com</a></li><li>B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统？<ul><li>实际上B&#x2F;S结构的系统还是一个C&#x2F;S，只不过这个C比较特殊，这个Client是一个固定不变浏览器软件。</li></ul></li><li>B&#x2F;S结构的系统优点和缺点是：<ul><li>优点：<ul><li>升级维护方便，成本比较低。（只需要升级服务器端即可。）</li><li>不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。</li></ul></li><li>缺点：<ul><li>速度慢（不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。）</li><li>体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。）</li><li>不安全（所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。）</li><li>….</li></ul></li></ul></li></ul></li><li>C&#x2F;S和B&#x2F;S结构的系统，哪个好，哪个不好？<ul><li>这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。</li><li>娱乐性软件建议使用？<ul><li>C&#x2F;S 结构</li></ul></li><li>公司内部使用的一些业务软件建议使用？<ul><li>公司内部使用的系统，需要维护成本低。</li><li>公司内部使用的系统，不需要很酷炫。</li><li>公司内部使用的企业级系统主要是能够进行数据的维护即可。</li><li>B&#x2F;S 结构。</li></ul></li></ul></li><li>注意了：开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。<ul><li>开发一个WEB系统你需要会哪些技术？<ul><li>WEB前端（运行在浏览器上的程序。）<ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul></li><li>WEB后端（WEB服务器端的程序。）<ul><li>Java可以（Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范：Servlet【Server Applet服务器端的Java小程序。】）</li><li>C语言也可以</li><li>C++也可以</li><li>Python也行</li><li>PHP也可以</li><li>….</li></ul></li></ul></li></ul></li><li>JavaEE是什么？<ul><li>Java包括三大块：<ul><li>JavaSE<ul><li>Java标准版（一套类库：别人写好的一套类库，只不过这个类库是标准类库，走EE，或者走ME，这个SE一定是基础，先学。）</li></ul></li><li>JavaEE（WEB方向，WEB系统。）<ul><li>Java企业版（也是一套类库：也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。）</li><li>别人写好的，你用就行了，用它可以开发企业级项目。</li><li>可以开发web系统。</li><li>Java比较火爆的就是这个JavaEE方向。</li></ul></li><li>JavaME<ul><li>Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发）</li><li>机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。。。</li></ul></li></ul></li><li>JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。</li></ul></li></ol><h2 id="B-x2F-S结构的系统通信原理（没有涉及到Java小程序）"><a href="#B-x2F-S结构的系统通信原理（没有涉及到Java小程序）" class="headerlink" title="B&#x2F;S结构的系统通信原理（没有涉及到Java小程序）"></a>B&#x2F;S结构的系统通信原理（没有涉及到Java小程序）</h2><ul><li>WEB系统的访问过程<ul><li>第一步：打开浏览器</li><li>第二步：找到地址栏</li><li>第三步：输入一个合法的网址</li><li>第四步：回车</li><li>第五步：在浏览器上会展示响应的结果。</li></ul></li><li>关于域名：<ul><li><a href="https://www.baidu.com/">https://www.baidu.com/</a> （网址）</li><li><a href="http://www.baidu.com/">www.baidu.com</a> 是一个域名</li><li>在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。</li><li>解析结果也许是：<a href="http://110.242.68.3/index.html">http://110.242.68.3:80/index.html</a></li></ul></li><li>IP地址是啥？<ul><li>计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。</li><li>A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。</li></ul></li><li>端口号是啥？<ul><li>一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务）。</li><li>一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。</li><li>在同一个计算机上，端口号具有唯一性。</li></ul></li><li>一个WEB系统的通信原理？通信步骤：<ul><li>第一步：用户输入网址（URL）</li><li>第二步：域名解析器进行域名解析：<a href="http://110.242.68.3/index.html">http://110.242.68.3:80/index.html</a></li><li>第三步：浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。</li><li>第四步：定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。</li><li>第五步：80端口对应的服务器软件得知浏览器想要的资源名是：index.html</li><li>第六步：服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。</li><li>第七步：浏览器接收到来自服务器的代码（HTML CSS JS）</li><li>第八步：浏览器渲染，执行HTML CSS JS代码，展示效果。</li></ul></li><li>什么是URL？<ul><li>统一资源定位符（<a href="http://www.baidu.com)/">http://www.baidu.com）</a></li></ul></li><li>什么是请求，什么是响应？<ul><li>请求和响应实际上说的是数据的流向不同。</li><li>从Browser端发送数据到Server端，我们称为请求。英语单词：request</li><li>从Server端向浏览器Browser端发送数据，我们称为响应。英语单词：response</li><li>B –&gt; S （请求request）</li><li>S –&gt; B （响应response）</li></ul></li></ul><h2 id="关于WEB服务器软件"><a href="#关于WEB服务器软件" class="headerlink" title="关于WEB服务器软件"></a>关于WEB服务器软件</h2><ul><li><p>WEB服务器软件都有哪些呢？（这些软件都是提前开发好的。）</p><ul><li>Tomcat（WEB服务器）</li><li>jetty（WEB服务器）</li><li>JBOSS（应用服务器）</li><li>WebLogic（应用服务器）</li><li>WebSphere（应用服务器）</li></ul></li><li><p>应用服务器和WEB服务器的关系？</p><ul><li>应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。)</li><li>WEB服务器只实现了JavaEE中的Servlet + JSP两个核心的规范。</li><li>通过这个讲解说明了：应用服务器是包含WEB服务器的。</li><li>用过JBOSS服务器的同学应该很清楚，JBOSS中内嵌了一个Tomcat服务器。</li></ul></li><li><p>Tomcat下载</p><ul><li>apache官网地址：<a href="https://www.apache.org/">https://www.apache.org/</a></li><li>tomcat官网地址：<a href="https://tomcat.apache.org/">https://tomcat.apache.org</a></li><li>tomcat开源免费的轻量级WEB服务器。</li><li>tomcat还有另外一个名字：catalina（catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina）</li><li>tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范）</li><li>tomcat是java语言写的。</li><li>tomcat服务器要想运行，必须先又jre（Java的运行时环境）</li></ul></li><li><p>Tomcat服务器要想运行，需要先有jre，所以要先安装JDK，配置java运行环境。</p><ul><li>JAVA_HOME&#x3D;C:\Program Files\Java\jdk-17.0.1</li><li>PATH&#x3D;%JAVA_HOME%\bin</li><li>目前JAVA_HOME没有配置，思考一个问题，这样行不行呢？目前只运行java程序是没问题的。真的没问题吗？</li></ul></li><li><p>Tomcat服务器的安装：</p><ul><li>绿色版本的安装很简单，直接zip包解压即可。解压就是安装。</li><li>我有一个好习惯，在C盘的根目录下新建一个dev目录，java开发所有相关的工具都安装到dev目录下，这样比较方便管理。（你随意）</li><li>启动Tomcat<ul><li>bin目录下有一个文件：startup.bat,通过它可以启动Tomcat服务器。<ul><li>xxx.bat文件是个什么文件？bat文件是windows操作系统专用的，bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。</li><li>startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。</li><li>tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。</li><li>分析startup.bat文件得出，执行这个命令，实际上最后是执行：catalina.bat文件。</li><li>catalina.bat文件中有这样一行配置：MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap （这个类就是main方法所在的类。）</li><li>tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。</li></ul></li><li>我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。</li><li>启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置：<ul><li>JAVA_HOME&#x3D;JDK的根</li><li>CATALINA_HOME&#x3D;Tomcat服务器的根</li></ul></li></ul></li></ul></li><li><p>关于Tomcat服务器的目录</p><ul><li>bin ： 这个目录是Tomcat服务器的命令文件存放的目录，比如：启动Tomcat，关闭Tomcat等。</li><li>conf： 这个目录是Tomcat服务器的配置文件存放目录。（server.xml文件中可以配置端口号，默认Tomcat端口是8080）</li><li>lib ：这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。</li><li>logs: Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。</li><li>temp：Tomcat服务器的临时目录。存储临时文件。</li><li>webapps：这个目录当中就是用来存放大量的webapp（web application：web应用）</li><li>work：这个目录是用来存放JSP文件翻译之后的java文件以及编译之后的class文件。</li></ul></li><li><p>配置Tomcat服务器需要哪些环境变量？</p><ul><li>JAVA_HOME&#x3D;JDK的根</li><li>CATALINA_HOME&#x3D;Tomcat服务器的根</li><li>PATH&#x3D;%JAVA_HOME%\bin;%CATALINA_HOME%\bin</li></ul></li><li><p>启动Tomcat： startup</p></li><li><p>关闭Tomcat：stop （shutdown.bat文件重命名为stop.bat，为什么？原因是shutdown命令和windows中的关机命令冲突。所以修改一下。）</p></li><li><p>怎么测试Tomcat服务器有没有启动成功呢？</p><ul><li>打开浏览器，在浏览器的地址栏上输入URL即可：<ul><li><a href="http://ip地址:端口号">http://ip地址:端口号</a></li><li>ip地址是什么？端口号我知道，是8080</li><li>本机的IP地址是：127.0.0.1，或者是localhost，都行。</li></ul></li></ul></li></ul><h2 id="实现一个最基本的web应用（这个web应用中没有java小程序）"><a href="#实现一个最基本的web应用（这个web应用中没有java小程序）" class="headerlink" title="实现一个最基本的web应用（这个web应用中没有java小程序）"></a>实现一个最基本的web应用（这个web应用中没有java小程序）</h2><ul><li><p>第一步：找到CATALINA_HOME\webapps目录</p><ul><li>因为所有的webapp要放到webapps目录下。（没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。）</li></ul></li><li><p>第二步：在CATALINA_HOME\webapps目录下新建一个子目录，起名：oa</p><ul><li>这个目录名oa就是你这个webapp的名字。</li></ul></li><li><p>第三步：在oa目录下新建资源文件，例如：index.html</p><ul><li>编写index.html文件的内容。</li></ul></li><li><p>第四步：启动Tomcat服务器</p></li><li><p>第五步：打开浏览器，在浏览器地址栏上输入这样的URL：</p></li><li><p><a href="http://127.0.0.1:8080/oa/index.html">http://127.0.0.1:8080/oa/index.html</a></p></li><li><p>思考一个问题：</p><ul><li><p>我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗？既然是一样的，我们完全可以使用超链接。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--注意以下的路径，以&#x2F;开始，带项目名，是一个绝对路径。不需要添加：http:&#x2F;&#x2F;127.0.0.1:8080--&gt;&lt;a href&#x3D;&quot;&#x2F;oa&#x2F;login.html&quot;&gt;user login2&lt;&#x2F;a&gt;&lt;!--多个层级也没有关系，正常访问即可。--&gt;&lt;!--注意：我们目前前端上的路径都以“&#x2F;”开始的，都是加项目名的。--&gt;&lt;a href&#x3D;&quot;&#x2F;oa&#x2F;test&#x2F;debug&#x2F;d.html&quot;&gt;d page&lt;&#x2F;a&gt;</code></pre></li></ul></li><li><p><a href="http://127.0.0.1:8080/oa/userList.html">http://127.0.0.1:8080/oa/userList.html</a> </p><ul><li>访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。</li><li>连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。（动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。）</li></ul></li></ul><h2 id="对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议"><a href="#对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议" class="headerlink" title="对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议"></a>对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议</h2><p><img src="D:\course\01-Servlet\文档\BS结构系统的通信原理2.png" alt="BS结构系统的通信原理2"></p><ul><li>有哪些角色（在整个BS结构的系统当中，有哪些人参与进去了）<ul><li>浏览器软件的开发团队（浏览器软件太多了：谷歌浏览器、火狐浏览器、IE浏览器….）</li><li>WEB Server的开发团队（WEB Server这个软件也是太多了：Tomcat、Jetty、WebLogic、JBOSS、WebSphere….）</li><li>DB Server的开发团队（DB Server这个软件也是太多了：Oracle、MySQL…..）</li><li>webapp的开发团队（WEB应用是我们做为JavaWEB程序员开发的）</li></ul></li><li>角色和角色之间需要遵守哪些规范，哪些协议<ul><li>webapp的开发团队   和    WEB Server的开发团队  之间有一套规范: JavaEE规范之一Servlet规范。<ul><li>Servlet规范的作用是什么？<ul><li>WEB Server   和   webapp解耦合。</li></ul></li></ul></li><li>Browser  和   WebServer之间有一套传输协议：HTTP协议。（超文本传输协议。）</li><li>webapp开发团队  和  DB Server的开发团队之间有一套规范：JDBC规范。</li></ul></li></ul><p><img src="D:\course\01-Servlet\文档\BS结构系统的角色和协议.png" alt="BS结构系统的角色和协议"></p><ul><li>Servlet规范是一个什么规范？<ul><li>遵循Servlet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。（因为这个webapp是遵循Servlet规范的。）</li><li>Servlet规范包括什么呢？<ul><li>规范了哪些接口</li><li>规范了哪些类</li><li>规范了一个web应用中应该有哪些配置文件</li><li>规范了一个web应用中配置文件的名字</li><li>规范了一个web应用中配置文件存放的路径</li><li>规范了一个web应用中配置文件的内容</li><li>规范了一个合法有效的web应用它的目录结构应该是怎样的。</li><li>…..</li></ul></li></ul></li></ul><h2 id="开发一个带有Servlet（Java小程序）的webapp（重点）"><a href="#开发一个带有Servlet（Java小程序）的webapp（重点）" class="headerlink" title="开发一个带有Servlet（Java小程序）的webapp（重点）"></a>开发一个带有Servlet（Java小程序）的webapp（重点）</h2><ul><li><p>开发步骤是怎样的？</p><ul><li><p>第一步：在webapps目录下新建一个目录，起名crm（这个crm就是webapp的名字）。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。</p><ul><li>注意：crm就是这个webapp的根</li></ul></li><li><p>第二步：在webapp的根下新建一个目录：WEB-INF</p><ul><li>注意：这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。必须的必须。</li></ul></li><li><p>第三步：在WEB-INF目录下新建一个目录：classes</p><ul><li>注意：这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件（这里存放的是字节码文件）。</li></ul></li><li><p>第四步：在WEB-INF目录下新建一个目录：lib</p><ul><li>注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。</li></ul></li><li><p>第五步：在WEB-INF目录下新建一个文件：web.xml</p><ul><li><p>注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。</p></li><li><p>这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴</p></li><li><p>&#96;&#96;&#96;xml</p><?xml version="1.0" encoding="UTF-8"?><p><web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee                  https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"  version="5.0"  metadata-complete="true"></p></web-app><pre class="line-numbers language-none"><code class="language-none">- 第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。  - 这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。）  - Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。）  - Servlet接口是JavaEE的规范中的一员。  - Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。  - 重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet  - 注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。- 第七步：编译我们编写的HelloServlet  - 重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH    CLASSPATH&#x3D;.;C:\dev\apache-tomcat-10.0.12\lib\servlet-api.jar  - 思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？    - 没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。- 第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\classes目录下。- 第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。  - 这一步用专业术语描述：在web.xml文件中注册Servlet类。  - &#96;&#96;&#96;xml    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;        &lt;web-app xmlns&#x3D;&quot;https:&#x2F;&#x2F;jakarta.ee&#x2F;xml&#x2F;ns&#x2F;jakartaee&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xsi:schemaLocation&#x3D;&quot;https:&#x2F;&#x2F;jakarta.ee&#x2F;xml&#x2F;ns&#x2F;jakartaee                          https:&#x2F;&#x2F;jakarta.ee&#x2F;xml&#x2F;ns&#x2F;jakartaee&#x2F;web-app_5_0.xsd&quot;      version&#x3D;&quot;5.0&quot;      metadata-complete&#x3D;&quot;true&quot;&gt;        &lt;!--servlet描述信息--&gt;    &lt;!--任何一个servlet都对应一个servlet-mapping --&gt;    &lt;servlet&gt;    &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;&#x2F;servlet-name&gt;    &lt;!--这个位置必须是带有包名的全限定类名--&gt;    &lt;servlet-class&gt;com.bjpowernode.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;    &lt;&#x2F;servlet&gt;        &lt;!--servlet映射信息--&gt;    &lt;servlet-mapping&gt;    &lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt;    &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;&#x2F;servlet-name&gt;    &lt;!--这里需要一个路径--&gt;    &lt;!--这个路径唯一的要求是必须以 &#x2F; 开始--&gt;    &lt;!--当前这个路径可以随便写--&gt;    &lt;url-pattern&gt;&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;        &lt;&#x2F;web-app&gt;    </code></pre></li></ul></li><li><p>第十步：启动Tomcat服务器</p></li><li><p>第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是：</p><ul><li><a href="http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd">http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd</a>   </li><li>非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。</li><li>注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：&#x2F;crm</li></ul></li><li><p>浏览器上编写的路径太复杂，可以使用超链接。（<strong>非常重要：html页面只能放到WEB-INF目录外面。</strong>）</p></li><li><p>以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。</p></li><li><p>总结一下：一个合法的webapp目录结构应该是怎样的？</p><pre class="line-numbers language-none"><code class="language-none">webapproot     |------WEB-INF       |------classes(存放字节码)       |------lib(第三方jar包)       |------web.xml(注册Servlet)     |------html     |------css     |------javascript     |------image     ....</code></pre></li><li><p>浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程？（以下这个过程描述的很粗糙。其中还有很多步骤我省略了。）</p><ul><li>用户输入URL，或者直接点击超链接：<a href="http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd">http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd</a>  </li><li>然后Tomcat服务器接收到请求，截取路径：&#x2F;crm&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd  </li><li>Tomcat服务器找到crm项目</li><li>Tomcat服务器在web.xml文件中查找&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd  对应的Servlet是：com.bjpowernode.servlet.HelloServlet</li><li>Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。</li><li>Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。</li></ul></li></ul></li></ul><h2 id="关于JavaEE的版本"><a href="#关于JavaEE的版本" class="headerlink" title="关于JavaEE的版本"></a>关于JavaEE的版本</h2><ul><li>JavaEE目前最高版本是 JavaEE8</li><li>JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。</li><li>Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。</li><li>以后没有JavaEE了。以后都叫做Jakarta EE。</li><li>JavaEE8版本升级之后的”JavaEE 9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9</li><li>JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet</li><li>JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet （包名都换了）</li><li>如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。</li></ul><h2 id="解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）"><a href="#解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）" class="headerlink" title="解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）"></a>解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）</h2><p>将CATALINA_HOME&#x2F;conf&#x2F;logging.properties文件中的内容修改如下：</p><p>java.util.logging.ConsoleHandler.encoding &#x3D; GBK</p><h2 id="向浏览器响应一段HTML代码"><a href="#向浏览器响应一段HTML代码" class="headerlink" title="向浏览器响应一段HTML代码"></a>向浏览器响应一段HTML代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void service(ServletRequest request, ServletResponse response)&#123;    response.setContentType(&quot;text&#x2F;html&quot;);    PrintWriter out &#x3D; response.getWriter();    out.print(&quot;&lt;h1&gt;hello servlet!&lt;&#x2F;h1&gt;&quot;);&#125;</code></pre><h2 id="在Servlet中连接数据库，怎么做？"><a href="#在Servlet中连接数据库，怎么做？" class="headerlink" title="在Servlet中连接数据库，怎么做？"></a>在Servlet中连接数据库，怎么做？</h2><ul><li>Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。</li><li>在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF&#x2F;lib目录下。（com.mysql.cj.jdbc.Driver 这个类就在驱动jar包当中。）</li></ul><h2 id="在集成开发环境当中开发Servlet程序"><a href="#在集成开发环境当中开发Servlet程序" class="headerlink" title="在集成开发环境当中开发Servlet程序"></a>在集成开发环境当中开发Servlet程序</h2><ul><li><p>集成开发工具很多，其中目前使用比较多的是：</p><ul><li>IntelliJ IDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。）</li><li>Eclipse（这个少一些），Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。</li></ul></li><li><p>使用IDEA集成开发工具开发Servlet</p><ul><li>第一步：New Project（我比较习惯先创建一个Empty Project【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是一种习惯，你可以直接新建非空的Project），这个Empty Project起名为：javaweb（不是必须的，只是一个名字而已。一般情况下新建的Project的名字最好和目录的名字一致。）</li><li>第二步：新建模块（File –&gt; new –&gt; Module…）<ul><li>这里新建的是一个普通的JavaSE模块（这里先不要新建Java Enterprise模块）</li><li>这个Module自动会被放在javaweb的project下面。</li><li>这个Module起名：servlet01</li></ul></li><li>第三步：让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module）<ul><li>在Module上点击右键：Add Framework Support…（添加框架支持）</li><li>在弹出的窗口中，选择Web Application（选择的是webapp的支持）</li><li>选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。</li><li><strong>重点，需要注意的：在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul></li><li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。</li><li>第五步：编写Servlet（StudentServlet）<ul><li>class StudentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有。怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath）<ul><li>File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS….</li></ul></li><li>实现jakarta.servlet.Servlet接口中的5个方法。</li></ul></li><li>第六步：在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。）</li><li>第七步：在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。</li><li>第八步：在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;studentServlet&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.StudentServlet&lt;&#x2F;servlet-class&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;studentServlet&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;servlet&#x2F;student&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;    &lt;&#x2F;web-app&gt;</code></pre><ul><li><p>第九步：给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p><ul><li><p>student.html</p></li><li><p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。</p></li><li><p>student.html文件的内容</p></li><li><p>&#96;&#96;&#96;html</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>student page</title></head><body>    <!--这里的项目名是 /xmm ，无法动态获取，先写死-->    <a href="/xmm/servlet/student">student list</a></body></html><pre class="line-numbers language-none"><code class="language-none">        - 第十步：让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。    - IDEA工具右上角，绿色小锤子右边有一个：Add Configuration    - 左上角加号，点击Tomcat Server --&gt; local    - 在弹出的界面中设置服务器Server的参数（基本上不用动）    - 在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。    - 修改 Application context为：&#x2F;xmm  - 第十一步：启动Tomcat服务器    - 在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。    - 我们开发中建议适用debug模式启动Tomcat  - 第十二步：打开浏览器，在浏览器地址栏上输入：http:&#x2F;&#x2F;localhost:8080&#x2F;xmm&#x2F;student.html## Servlet对象的生命周期- 什么是Servlet对象生命周期？  - Servlet对象什么时候被创建。  - Servlet对象什么时候被销毁。  - Servlet对象创建了几个？  - Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。- Servlet对象是由谁来维护的？  - Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。  - Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。  - Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】）  - WEB容器来管理Servlet对象的死活。- 思考：我们自己new的Servlet对象受WEB容器的管理吗？  - 我们自己new的Servlet对象是不受WEB容器管理的。  - WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中）  - web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系  - ![WEB容器中的Map集合](D:\course\01-Servlet\文档\WEB容器中的Map集合.png)- 研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？  - 在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。  - 经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。  - 这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。- 怎么让服务器启动的时候创建Servlet对象呢？  - 在servlet标签中添加&lt;load-on-startup&gt;子标签，在该子标签中填写整数，越小的整数优先级越高。  - &#96;&#96;&#96;xml    &lt;servlet&gt;        &lt;servlet-name&gt;aservlet&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.AServlet&lt;&#x2F;servlet-class&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;aservlet&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;a&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;</code></pre></li></ul></li></ul></li><li><p>Servlet对象生命周期</p><ul><li><p>默认情况下服务器启动的时候AServlet对象并没有被实例化</p></li><li><p>用户发送第一次请求的时候，控制台输出了以下内容：</p><pre class="line-numbers language-none"><code class="language-none">AServlet无参数构造方法执行了AServlet&#39;s init method execute!AServlet&#39;s service method execute!</code></pre></li><li><p>根据以上输出内容得出结论：</p><ul><li>用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。）</li><li>AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。）</li><li>用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。</li></ul></li><li><p>用户继续发送第二次请求，控制台输出了以下内容：</p><pre class="line-numbers language-none"><code class="language-none">AServlet&#39;s service method execute!</code></pre></li><li><p>根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明：</p><ul><li>第一：Servlet对象是单例的（单实例的。但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。）</li><li>第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</li><li>第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</li></ul></li><li><p>关闭服务器的时候，控制台输出了以下内容：</p><pre class="line-numbers language-none"><code class="language-none">AServlet&#39;s destroy method execute!</code></pre></li><li><p>通过以上输出内容，可以得出以下结论：</p><ul><li>Servlet的destroy方法只被Tomcat服务器调用一次。</li><li>destroy方法是在什么时候被调用的？<ul><li>在服务器关闭的时候。</li><li>因为服务器关闭的时候要销毁AServlet对象的内存。</li><li>服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。</li></ul></li></ul></li><li><p>请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？</p><ul><li>destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。</li></ul></li><li><p>Servlet对象更像一个人的一生：</p><ul><li>Servlet的无参数构造方法执行：标志着你出生了。</li><li>Servlet对象的init方法的执行：标志着你正在接受教育。</li><li>Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。</li><li>Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。</li></ul></li><li><p>关于Servlet类中方法的调用次数？</p><ul><li>构造方法只执行一次。</li><li>init方法只执行一次。</li><li>service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。</li><li>destroy方法只执行一次。</li></ul></li><li><p>当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？</p><ul><li>报错了：500错误。</li><li>注意：500是一个HTTP协议的错误状态码。</li><li>500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。）</li><li>如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</li><li>所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</li></ul></li><li><p>思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？</p><ul><li>不能。</li><li>Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</li></ul></li><li><p>init、service、destroy方法中使用最多的是哪个方法？</p><ul><li>使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</li><li>什么时候使用init方法呢？<ul><li>init方法很少用。</li><li>通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池….</li></ul></li><li>什么时候使用destroy方法呢？<ul><li>destroy方法也很少用。</li><li>通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。</li></ul></li></ul></li></ul></li></ul><h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h2><ul><li><p>我们编写一个Servlet类直接实现Servlet接口有什么缺点？</p><ul><li>我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。</li></ul></li><li><p>适配器设计模式Adapter</p><ul><li>手机直接插到220V的电压上，手机直接就报废了。怎么办？可以找一个充电器。这个充电器就是一个适配器。手机连接适配器。适配器连接220V的电压。这样问题就解决了。</li></ul></li><li><p>编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。</p><ul><li>GenericServlet实现Servlet接口。</li><li>GenericServlet是一个适配器。</li><li>以后编写的所有Servlet类继承GenericServlet，重写service方法即可。</li></ul></li><li><p>思考：GenericServlet类是否需要改造一下？怎么改造？更利于子类程序的编写？</p><ul><li><p>思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？</p><ul><li>还会执行。会执行GenericServlet类中的init方法。</li></ul></li><li><p>思考第二个问题：init方法是谁调用的？</p><ul><li>Tomcat服务器调用的。</li></ul></li><li><p>思考第三个问题：init方法中的ServletConfig对象是谁创建的？是谁传过来的？</p><ul><li>都是Tomcat干的。</li><li>Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。</li></ul></li><li><p>思考一下Tomcat服务器伪代码：</p><ul><li>&#96;&#96;&#96;java<br>public class Tomcat {<br>public static void main(String[] args){<br>    &#x2F;&#x2F; …..<br>    &#x2F;&#x2F; Tomcat服务器伪代码<br>    &#x2F;&#x2F; 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象）<br>    Class clazz &#x3D; Class.forName(“com.bjpowernode.javaweb.servlet.LoginServlet”);<br>    Object obj &#x3D; clazz.newInstance();<br><br>    &#x2F;&#x2F; 向下转型<br>    Servlet servlet &#x3D; (Servlet)obj;<br><br>    &#x2F;&#x2F; 创建ServletConfig对象<br>    &#x2F;&#x2F; Tomcat服务器负责将ServletConfig对象实例化出来。<br>    &#x2F;&#x2F; 多态（Tomcat服务器完全实现了Servlet规范）<br>    ServletConfig servletConfig &#x3D; new org.apache.catalina.core.StandardWrapperFacade();<br><br>    &#x2F;&#x2F; 调用Servlet的init方法<br>    servlet.init(servletConfig);<br><br>    &#x2F;&#x2F; 调用Servlet的service方法<br>    &#x2F;&#x2F; ….<br><br>}<br>}<pre class="line-numbers language-none"><code class="language-none">## ServletConfig- 什么是ServletConfig？  - Servlet对象的配置信息对象。  - ServletConfig对象中封装了&lt;servlet&gt;&lt;&#x2F;servlet&gt;标签中的配置信息。（web.xml文件中servlet的配置信息）- 一个Servlet对应一个ServletConfig对象。- Servlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。- Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。- ServletConfig接口的实现类是Tomcat服务器给实现的。（Tomcat服务器说的就是WEB服务器。）- ServletConfig接口有哪些常用的方法？  - &#96;&#96;&#96;java    public String getInitParameter(String name); &#x2F;&#x2F; 通过初始化参数的name获取value    public Enumeration&lt;String&gt; getInitParameterNames(); &#x2F;&#x2F; 获取所有的初始化参数的name    public ServletContext getServletContext(); &#x2F;&#x2F; 获取ServletContext对象    public String getServletName(); &#x2F;&#x2F; 获取Servlet的name</code></pre></li></ul></li><li><p>以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。</p></li></ul></li></ul><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul><li><p>一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。</p></li><li><p>只要在同一个webapp当中，只要在同一个应用当中，所有的Servlet对象都是共享同一个ServletContext对象的。</p></li><li><p>ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。</p></li><li><p>Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。</p></li><li><p>ServletContext被称为Servlet上下文对象。（Servlet对象的四周环境对象。）</p></li><li><p>一个ServletContext对象通常对应的是一个web.xml文件。</p></li><li><p>ServletContext对应显示生活中的什么例子呢？</p><ul><li>一个教室里有多个学生，那么每一个学生就是一个Servlet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如：教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。</li></ul></li><li><p>ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。</p><ul><li>ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。</li></ul></li><li><p>ServletContext接口中有哪些常用的方法？</p><ul><li><pre><code class="java">public String getInitParameter(String name); // 通过初始化参数的name获取valuepublic Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name<pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;xml  &lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt;  &lt;context-param&gt;      &lt;param-name&gt;pageSize&lt;&#x2F;param-name&gt;      &lt;param-value&gt;10&lt;&#x2F;param-value&gt;  &lt;&#x2F;context-param&gt;  &lt;context-param&gt;      &lt;param-name&gt;startIndex&lt;&#x2F;param-name&gt;      &lt;param-value&gt;0&lt;&#x2F;param-value&gt;  &lt;&#x2F;context-param&gt;  &lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;  &lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt;</code></pre></code></pre></li><li><pre><code class="java">// 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径// 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。public String getContextPath();//String contextPath = application.getContextPath();<pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;java  &#x2F;&#x2F; 获取文件的绝对路径（真实路径）  public String getRealPath(String path);</code></pre></code></pre></li><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 通过ServletContext对象也是可以记录日志的<br>public void log(String message);<br>public void log(String message, Throwable t);<br>&#x2F;&#x2F; 这些日志信息记录到哪里了？<br>&#x2F;&#x2F; localhost.2021-11-05.log</p><p>&#x2F;&#x2F; Tomcat服务器的logs目录下都有哪些日志文件？<br>&#x2F;&#x2F;catalina.2021-11-05.log 服务器端的java程序运行的控制台信息。<br>&#x2F;&#x2F;localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。<br>&#x2F;&#x2F;localhost_access_log.2021-11-05.txt 访问日志</p><pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;java  &#x2F;&#x2F; ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域）    &#x2F;&#x2F; 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中    &#x2F;&#x2F; 为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。    &#x2F;&#x2F; 为什么数据量要小？ 因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。    &#x2F;&#x2F; 为什么这些共享数据很少的修改，或者说几乎不修改？  &#x2F;&#x2F; 所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。    &#x2F;&#x2F; 数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。    &#x2F;&#x2F; 存（怎么向ServletContext应用域中存数据）  public void setAttribute(String name, Object value); &#x2F;&#x2F; map.put(k, v)  &#x2F;&#x2F; 取（怎么从ServletContext应用域中取数据）  public Object getAttribute(String name); &#x2F;&#x2F; Object v &#x3D; map.get(k)  &#x2F;&#x2F; 删（怎么删除ServletContext应用域中的数据）  public void removeAttribute(String name); &#x2F;&#x2F; map.remove(k)    </code></pre></li></ul></li><li><p>注意：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构：</p><ul><li><pre><code>jakarta.servlet.Servlet（接口）【爷爷】jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】我们以后编写的Servlet要继承HttpServlet类。<pre class="line-numbers language-none"><code class="language-none">- 大家到目前为止都接触过哪些缓存机制了？  - 堆内存当中的字符串常量池。    - &quot;abc&quot; 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。  - 堆内存当中的整数型常量池。    - [-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。  - 连接池(Connection Cache)    - 这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。    - JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。    - 连接池      - 最小连接数      - 最大连接数      - 连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。  - 线程池    - Tomcat服务器本身就是支持多线程的。    - Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？      - 当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。      - 所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。  - redis    - NoSQL数据库。非关系型数据库。缓存数据库。  - 向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。## HTTP协议- 什么是协议？  - 协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。  - 协议就是一套规范，就是一套标准。由其他人或其他组织来负责制定的。  - 我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是：中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。- 什么是HTTP协议？  - HTTP协议：是W3C制定的一种超文本传输协议。（通信协议：发送消息的模板提前被制定好。）  - W3C：    - 万维网联盟组织    - 负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。    - 万维网之父：蒂姆·伯纳斯·李  - 什么是超文本？    - 超文本说的就是：不是普通文本，比如流媒体：声音、视频、图片等。    - HTTP协议支持：不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。  - 这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。  - 什么是解耦合？    - B不依赖S。    - S也不依赖B。  - B&#x2F;S表示：B&#x2F;S结构的系统（浏览器访问WEB服务器的系统）  - 浏览器   向   WEB服务器发送数据，叫做：请求（request)  - WEB服务器   向   浏览器发送数据，叫做：响应（response）  - HTTP协议包括：    - 请求协议      - 浏览器  向   WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。    - 响应协议      - WEB服务器  向  浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。  - HTTP协议就是提前制定好的一种消息模板。    - 不管你是哪个品牌的浏览器，都是这么发。    - 不管你是哪个品牌的WEB服务器，都是这么发。    - FF浏览器  可以向 Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。    - WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。- HTTP的请求协议（B --&gt; S）  - HTTP的请求协议包括：4部分    - 请求行    - 请求头    - 空白行    - 请求体  - HTTP请求协议的具体报文：GET请求    - &#96;&#96;&#96;      GET &#x2F;servlet05&#x2F;getServlet?username&#x3D;lucy&amp;userpwd&#x3D;1111 HTTP&#x2F;1.1                           请求行      Host: localhost:8080                                                                    请求头      Connection: keep-alive      sec-ch-ua: &quot;Google Chrome&quot;;v&#x3D;&quot;95&quot;, &quot;Chromium&quot;;v&#x3D;&quot;95&quot;, &quot;;Not A Brand&quot;;v&#x3D;&quot;99&quot;      sec-ch-ua-mobile: ?0      sec-ch-ua-platform: &quot;Windows&quot;      Upgrade-Insecure-Requests: 1      User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36      Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9      Sec-Fetch-Site: same-origin      Sec-Fetch-Mode: navigate      Sec-Fetch-User: ?1      Sec-Fetch-Dest: document      Referer: http:&#x2F;&#x2F;localhost:8080&#x2F;servlet05&#x2F;index.html      Accept-Encoding: gzip, deflate, br      Accept-Language: zh-CN,zh;q&#x3D;0.9                                                                                              空白行                                                                                              请求体</code></pre></code></pre></li><li><p>HTTP请求协议的具体报文：POST请求</p><ul><li>&#96;&#96;&#96;<br>POST &#x2F;servlet05&#x2F;postServlet HTTP&#x2F;1.1                                                  请求行<br>Host: localhost:8080                                                                  请求头<br>Connection: keep-alive<br>Content-Length: 25<br>Cache-Control: max-age&#x3D;0<br>sec-ch-ua: “Google Chrome”;v&#x3D;”95”, “Chromium”;v&#x3D;”95”, “;Not A Brand”;v&#x3D;”99”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “Windows”<br>Upgrade-Insecure-Requests: 1<br>Origin: <a href="http://localhost:8080/">http://localhost:8080</a><br>Content-Type: application&#x2F;x-www-form-urlencoded<br>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,<em>&#x2F;</em>;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9<br>Sec-Fetch-Site: same-origin<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Referer: <a href="http://localhost:8080/servlet05/index.html">http://localhost:8080/servlet05/index.html</a><br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q&#x3D;0.9<br>                                                                                  空白行<br>username&#x3D;lisi&amp;userpwd&#x3D;123                                                             请求体<pre class="line-numbers language-none"><code class="language-none">  - 请求行    - 包括三部分：      - 第一部分：请求方式（7种）        - get（常用的）        - post（常用的）        - delete        - put        - head        - options        - trace      - 第二部分：URI        - 什么是URI？ 统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。        - 什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。        - URI和URL什么关系，有什么区别？          - URL包括URI          - http:&#x2F;&#x2F;localhost:8080&#x2F;servlet05&#x2F;index.html 这是URL。          - &#x2F;servlet05&#x2F;index.html 这是URI。      - 第三部分：HTTP协议版本号  - 请求头    - 请求的主机    - 主机的端口    - 浏览器信息    - 平台信息    - cookie等信息    - ....  - 空白行    - 空白行是用来区分“请求头”和“请求体”  - 请求体    - 向服务器发送的具体数据。- HTTP的响应协议（S --&gt; B）  - HTTP的响应协议包括：4部分    - 状态行    - 响应头    - 空白行    - 响应体  - HTTP响应协议的具体报文：    - &#96;&#96;&#96;      HTTP&#x2F;1.1 200 ok                                     状态行      Content-Type: text&#x2F;html;charset&#x3D;UTF-8               响应头      Content-Length: 160      Date: Mon, 08 Nov 2021 13:19:32 GMT      Keep-Alive: timeout&#x3D;20      Connection: keep-alive                                                          空白行      &lt;!doctype html&gt;                                     响应体      &lt;html&gt;          &lt;head&gt;              &lt;title&gt;from get servlet&lt;&#x2F;title&gt;          &lt;&#x2F;head&gt;          &lt;body&gt;              &lt;h1&gt;from get servlet&lt;&#x2F;h1&gt;          &lt;&#x2F;body&gt;      &lt;&#x2F;html&gt;</code></pre></li></ul></li><li><p>状态行</p><ul><li>三部分组成<ul><li>第一部分：协议版本号（HTTP&#x2F;1.1）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。）<ul><li>200 表示请求响应成功，正常结束。</li><li>404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。</li><li>405表示前端发送的请求方式与后端请求的处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。</li><li>以4开始的，一般是浏览器端的错误导致的。</li><li>以5开始的，一般是服务器端的错误导致的。</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok 表示正常成功结束。</li><li>not found 表示资源找不到。</li></ul></li></ul></li></ul></li><li><p>响应头：</p><ul><li>响应的内容类型</li><li>响应的内容长度</li><li>响应的时间</li><li>….</li></ul></li><li><p>空白行：</p><ul><li>用来分隔“响应头”和“响应体”的。</li></ul></li><li><p>响应体：</p><ul><li>响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</li></ul></li></ul></li><li><p>怎么查看的协议内容？</p><ul><li>使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。</li></ul></li><li><p>怎么向服务器发送GET请求，怎么向服务器发送POST请求？</p><ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method&#x3D;”post”。</li><li>其他所有情况一律都是get请求：<ul><li>在浏览器地址栏上直接输入URL，敲回车，属于get请求。</li><li>在浏览器上直接点击超链接，属于get请求。</li><li>使用form表单提交数据时，form标签中没有写method属性，默认就是get</li><li>或者使用form的时候，form标签中method属性值为：method&#x3D;”get”</li><li>….</li></ul></li></ul></li><li><p>GET请求和POST请求有什么区别？</p><ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，”?”后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据）<ul><li><a href="http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111">http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111</a></li></ul></li><li>post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据）</li><li>get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。</li><li>get请求无法发送大数据量。</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。</li><li>post请求可以发送大数据量，理论上没有长度限制。</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。</li><li>post请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。</li><li>get请求是安全的。get请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。）</li><li>post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。</li><li>get请求支持缓存。<ul><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg">https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg</a></li><li>任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中：<ul><li>一个get请求的路径a  对应  一个资源。</li><li>一个get请求的路径b  对应  一个资源。</li><li>一个get请求的路径c  对应  一个资源。</li><li>……</li></ul></li><li>实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。</li><li>有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。<ul><li>只要每一次get请求的请求路径不同即可。</li><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898</a></li><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899</a></li><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=%E7%B3%BB%E7%BB%9F%E6%AF%AB%E7%A7%92%E6%95%B0">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数</a></li><li>怎么解决？可以在路径的后面添加一个每时每刻都在变化的“时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。</li></ul></li></ul></li><li>post请求不支持缓存。（POST是用来修改服务器端的资源的。）<ul><li>post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。</li></ul></li></ul></li><li><p>GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求？</p><ul><li>怎么选择GET请求和POST请求呢？衡量标准是什么呢？你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。</li><li>大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存&#x2F;修改等。</li><li>如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息）</li><li>做文件上传，一定是post请求。要传的数据不是普通文本。</li><li>其他情况都可以使用get请求。</li></ul></li><li><p>不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的：</p><ul><li>name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</li><li>name是什么？<ul><li>以form表单为例：form表单中input标签的name。</li></ul></li><li>value是什么？<ul><li>以form表单为例：form表单中input标签的value。</li></ul></li></ul></li></ul><h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><ul><li>什么是设计模式？<ul><li>某个问题的固定的解决方案。(可以被重复使用。)</li></ul></li><li>你知道哪些设计模式？<ul><li>GoF设计模式：<ul><li>通常我们所说的23种设计模式。（Gang of Four：4人组提出的设计模式）</li><li>单例模式</li><li>工厂模式</li><li>代理模式</li><li>门面模式</li><li>责任链设计模式</li><li>观察者模式</li><li>模板方法设计模式</li><li>…..</li></ul></li><li>JavaEE设计模式：<ul><li>DAO</li><li>DTO</li><li>VO</li><li>PO</li><li>pojo</li><li>….</li></ul></li><li>….</li></ul></li><li>什么是模板方法设计模式？<ul><li>在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。</li></ul></li><li>模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的（但也可以不是final的）</li><li>模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。</li></ul><h2 id="HttpServlet源码分析"><a href="#HttpServlet源码分析" class="headerlink" title="HttpServlet源码分析"></a>HttpServlet源码分析</h2><ul><li>HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。</li><li>HttpServlet在哪个包下？<ul><li>jakarta.servlet.http.HttpServlet</li></ul></li><li>到目前为止我们接触了servlet规范中哪些接口？<ul><li>jakarta.servlet.Servlet  核心接口（接口）</li><li>jakarta.servlet.ServletConfig Servlet配置信息接口（接口）</li><li>jakarta.servlet.ServletContext Servlet上下文接口（接口）</li><li>jakarta.servlet.ServletRequest Servlet请求接口（接口）</li><li>jakarta.servlet.ServletResponse Servlet响应接口（接口）</li><li>jakarta.servlet.ServletException Servlet异常（类）</li><li>jakarta.servlet.GenericServlet 标准通用的Servlet类（抽象类）</li></ul></li><li>http包下都有哪些类和接口呢？jakarta.servlet.http.*;<ul><li>jakarta.servlet.http.HttpServlet （HTTP协议专用的Servlet类，抽象类）</li><li>jakarta.servlet.http.HttpServletRequest （HTTP协议专用的请求对象）</li><li>jakarta.servlet.http.HttpServletResponse （HTTP协议专用的响应对象）</li></ul></li><li>HttpServletRequest对象中封装了什么信息？<ul><li>HttpServletRequest，简称request对象。</li><li>HttpServletRequest中封装了请求协议的全部内容。</li><li>Tomcat服务器（WEB服务器）将“请求协议”中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。</li><li>也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。</li></ul></li><li>HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。</li><li>回忆Servlet生命周期？<ul><li>用户第一次请求<ul><li>Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xml文件中配置的Servlet类对应的对象。)</li><li>Tomcat服务器调用Servlet对象的init方法完成初始化。</li><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>用户第二次请求<ul><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>用户第三次请求<ul><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>….<ul><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>服务器关闭<ul><li>Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。</li><li>Tomcat服务器销毁Servlet对象。</li></ul></li></ul></li><li>HttpServlet源码分析：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloServlet extends HttpServlet &#123;&#x2F;&#x2F; 用户第一次请求，创建HelloServlet对象的时候，会执行这个无参数构造方法。public HelloServlet() &#123;    &#125;        &#x2F;&#x2F;override 重写 doGet方法    &#x2F;&#x2F;override 重写 doPost方法&#125;public abstract class GenericServlet implements Servlet, ServletConfig,        java.io.Serializable &#123;           &#x2F;&#x2F; 用户第一次请求的时候，HelloServlet对象第一次被创建之后，这个init方法会执行。    public void init(ServletConfig config) throws ServletException &#123;        this.config &#x3D; config;        this.init();    &#125;&#x2F;&#x2F; 用户第一次请求的时候，带有参数的init(ServletConfig config)执行之后，会执行这个没有参数的init()public void init() throws ServletException &#123;        &#x2F;&#x2F; NOOP by default    &#125;&#125;&#x2F;&#x2F; HttpServlet模板类。public abstract class HttpServlet extends GenericServlet &#123;    &#x2F;&#x2F; 用户发送第一次请求的时候这个service会执行    &#x2F;&#x2F; 用户发送第N次请求的时候，这个service方法还是会执行。    &#x2F;&#x2F; 用户只要发送一次请求，这个service方法就会执行一次。    @Override    public void service(ServletRequest req, ServletResponse res)        throws ServletException, IOException &#123;        HttpServletRequest  request;        HttpServletResponse response;        try &#123;            &#x2F;&#x2F; 将ServletRequest和ServletResponse向下转型为带有Http的HttpServletRequest和HttpServletResponse            request &#x3D; (HttpServletRequest) req;            response &#x3D; (HttpServletResponse) res;        &#125; catch (ClassCastException e) &#123;            throw new ServletException(lStrings.getString(&quot;http.non_http&quot;));        &#125;        &#x2F;&#x2F; 调用重载的service方法。        service(request, response);    &#125;        &#x2F;&#x2F; 这个service方法的两个参数都是带有Http的。    &#x2F;&#x2F; 这个service是一个模板方法。    &#x2F;&#x2F; 在该方法中定义核心算法骨架，具体的实现步骤延迟到子类中去完成。    protected void service(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException &#123;        &#x2F;&#x2F; 获取请求方式        &#x2F;&#x2F; 这个请求方式最终可能是：&quot;&quot;        &#x2F;&#x2F; 注意：request.getMethod()方法获取的是请求方式，可能是七种之一：        &#x2F;&#x2F; GET POST PUT DELETE HEAD OPTIONS TRACE        String method &#x3D; req.getMethod();        &#x2F;&#x2F; 如果请求方式是GET请求，则执行doGet方法。        if (method.equals(METHOD_GET)) &#123;            long lastModified &#x3D; getLastModified(req);            if (lastModified &#x3D;&#x3D; -1) &#123;                &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason                &#x2F;&#x2F; to go through further expensive logic                doGet(req, resp);            &#125; else &#123;                long ifModifiedSince;                try &#123;                    ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);                &#125; catch (IllegalArgumentException iae) &#123;                    &#x2F;&#x2F; Invalid date header - proceed as if none was set                    ifModifiedSince &#x3D; -1;                &#125;                if (ifModifiedSince &lt; (lastModified &#x2F; 1000 * 1000)) &#123;                    &#x2F;&#x2F; If the servlet mod time is later, call doGet()                    &#x2F;&#x2F; Round down to the nearest second for a proper compare                    &#x2F;&#x2F; A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                &#125; else &#123;                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                &#125;            &#125;        &#125; else if (method.equals(METHOD_HEAD)) &#123;            long lastModified &#x3D; getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        &#125; else if (method.equals(METHOD_POST)) &#123;            &#x2F;&#x2F; 如果请求方式是POST请求，则执行doPost方法。            doPost(req, resp);        &#125; else if (method.equals(METHOD_PUT)) &#123;            doPut(req, resp);        &#125; else if (method.equals(METHOD_DELETE)) &#123;            doDelete(req, resp);        &#125; else if (method.equals(METHOD_OPTIONS)) &#123;            doOptions(req,resp);        &#125; else if (method.equals(METHOD_TRACE)) &#123;            doTrace(req,resp);        &#125; else &#123;            &#x2F;&#x2F;            &#x2F;&#x2F; Note that this means NO servlet supports whatever            &#x2F;&#x2F; method was requested, anywhere on this server.            &#x2F;&#x2F;            String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs &#x3D; new Object[1];            errArgs[0] &#x3D; method;            errMsg &#x3D; MessageFormat.format(errMsg, errArgs);            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        &#125;    &#125;            protected void doGet(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException&#123;        &#x2F;&#x2F; 报405错误        String msg &#x3D; lStrings.getString(&quot;http.method_get_not_supported&quot;);        sendMethodNotAllowed(req, resp, msg);    &#125;        protected void doPost(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException &#123;        &#x2F;&#x2F; 报405错误        String msg &#x3D; lStrings.getString(&quot;http.method_post_not_supported&quot;);        sendMethodNotAllowed(req, resp, msg);    &#125;    &#125;&#x2F;*通过以上源代码分析：假设前端发送的请求是get请求，后端程序员重写的方法是doPost假设前端发送的请求是post请求，后端程序员重写的方法是doGet会发生什么呢？发生405这样的一个错误。405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。通过以上源代码可以知道：只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.怎么避免405的错误呢？后端重写了doGet方法，前端一定要发get请求。后端重写了doPost方法，前端一定要发post请求。这样可以避免405错误。这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。有的人，你会看到为了避免405错误，在Servlet类当中，将doGet和doPost方法都进行了重写。这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能少写一点。*&#x2F;</code></pre><ul><li><p>我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗？</p><ul><li>可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。</li></ul></li><li><p>到今天我们终于得到了最终的一个Servlet类的开发步骤：</p><ul><li>第一步：编写一个Servlet类，直接继承HttpServlet</li><li>第二步：重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。</li><li>第三步：将Servlet类配置到web.xml文件当中。</li><li>第四步：准备前端的页面（form表单），form表单中指定请求路径即可。</li></ul></li></ul><h2 id="关于一个web站点的欢迎页面"><a href="#关于一个web站点的欢迎页面" class="headerlink" title="关于一个web站点的欢迎页面"></a>关于一个web站点的欢迎页面</h2><ul><li><p>什么是一个web站点的欢迎页面？</p><ul><li>对于一个webapp来说，我们是可以设置它的欢迎页面的。</li><li>设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何“资源路径”，这个时候会默认访问你的欢迎页面。</li><li>我们一般的访问方式是：<ul><li><a href="http://localhost:8080/servlet06/login.html">http://localhost:8080/servlet06/login.html</a> 这种方式是指定了要访问的就是login.html资源。</li></ul></li><li>如果我们访问的方式是：<ul><li><a href="http://localhost:8080/servlet06">http://localhost:8080/servlet06</a> 如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢？</li><li>默认会访问你设置的欢迎页面。</li></ul></li></ul></li><li><p>怎么设置欢迎页面呢？</p><ul><li><p>第一步：我在IDEA工具的web目录下新建了一个文件login.html</p></li><li><p>第二步：在web.xml文件中进行了以下的配置</p><ul><li><pre><code class="xml">&lt;welcome-file-list&gt;        &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<pre class="line-numbers language-none"><code class="language-none">    - 注意：设置欢迎页面的时候，这个路径不需要以“&#x2F;”开始。并且这个路径默认是从webapp的根下开始查找。  - 第三步：启动服务器，浏览器地址栏输入地址    - http:&#x2F;&#x2F;localhost:8080&#x2F;servlet07- 如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢？  - 在webapp根下新建page1  - 在page1下新建page2目录  - 在page2目录下新建page.html页面  - 在web.xml文件中应该这样配置    - &#96;&#96;&#96;      &lt;welcome-file-list&gt;          &lt;welcome-file&gt;page1&#x2F;page2&#x2F;page.html&lt;&#x2F;welcome-file&gt;      &lt;&#x2F;welcome-file-list&gt;</code></pre></code></pre></li><li><p>注意：路径不需要以“&#x2F;”开始，并且路径默认从webapp的根下开始找。</p></li></ul></li></ul></li><li><p>一个webapp是可以设置多个欢迎页面的</p><ul><li>&#96;&#96;&#96;xml<welcome-file-list>    <welcome-file>page1/page2/page.html</welcome-file>    <welcome-file>login.html</welcome-file></welcome-file-list><pre class="line-numbers language-none"><code class="language-none">  - 注意：越靠上的优先级越高。找不到的继续向下找。- 你有没有注意一件事：当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么？  - 这是因为小猫咪Tomcat服务器已经提前配置好了。  - 实际上配置欢迎页面有两个地方可以配置：    - 一个是在webapp内部的web.xml文件中。（在这个地方配置的属于局部配置）    - 一个是在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件中进行配置。（在这个地方配置的属于全局配置）      - &#96;&#96;&#96;xml        &lt;welcome-file-list&gt;            &lt;welcome-file&gt;index.html&lt;&#x2F;welcome-file&gt;            &lt;welcome-file&gt;index.htm&lt;&#x2F;welcome-file&gt;            &lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;        &lt;&#x2F;welcome-file-list&gt;</code></pre><ul><li><p>Tomcat服务器的全局欢迎页面是：index.html index.htm index.jsp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.jsp作为一个web站点的欢迎页面。</p></li><li><p>注意原则：局部优先原则。（就近原则）</p></li></ul></li></ul></li><li><p>欢迎页可以是一个Servlet吗？</p><ul><li><p>当然可以。</p></li><li><p>你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。</p></li><li><p>静态资源：index.html welcome.html …..</p></li><li><p>动态资源：Servlet类。</p></li><li><p>步骤：</p><ul><li><p>第一步：写一个Servlet</p><ul><li>&#96;&#96;&#96;java<br>public class WelcomeServlet extends HttpServlet {<br>@Override<br>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>    response.setContentType(“text&#x2F;html”);<br>    PrintWriter out &#x3D; response.getWriter();<br>    out.print(“<h1>welcome to bjpowernode!</h1>“);<br>}<br>}<pre class="line-numbers language-none"><code class="language-none">    - 第二步：在web.xml文件中配置servlet  - &#96;&#96;&#96;xml        &lt;servlet&gt;            &lt;servlet-name&gt;welcomeServlet&lt;&#x2F;servlet-name&gt;            &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.WelcomeServlet&lt;&#x2F;servlet-class&gt;        &lt;&#x2F;servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;welcomeServlet&lt;&#x2F;servlet-name&gt;            &lt;url-pattern&gt;&#x2F;fdsa&#x2F;fds&#x2F;a&#x2F;fds&#x2F;af&#x2F;ds&#x2F;af&#x2F;dsafdsafdsa&lt;&#x2F;url-pattern&gt;        &lt;&#x2F;servlet-mapping&gt;</code></pre></li></ul></li><li><p>第三步：在web.xml文件中配置欢迎页</p><ul><li>&#96;&#96;&#96;xml<br><welcome-file-list><br>    <welcome-file>fdsa&#x2F;fds&#x2F;a&#x2F;fds&#x2F;af&#x2F;ds&#x2F;af&#x2F;dsafdsafdsa</welcome-file><br></welcome-file-list><pre class="line-numbers language-none"><code class="language-none">        ## 关于WEB-INF目录- 在WEB-INF目录下新建了一个文件：welcome.html- 打开浏览器访问：http:&#x2F;&#x2F;localhost:8080&#x2F;servlet07&#x2F;WEB-INF&#x2F;welcome.html 出现了404错误。- 注意：放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、JS、image等静态资源一定要放到WEB-INF目录之外。## HttpServletRequest接口详解- HttpServletRequest是一个接口，全限定名称：jakarta.servlet.http.HttpServletRequest- HttpServletRequest接口是Servlet规范中的一员。- HttpServletRequest接口的父接口：ServletRequest  - &#96;&#96;&#96;java    public interface HttpServletRequest extends ServletRequest &#123;&#125;</code></pre></li></ul></li></ul></li></ul></li><li><p>HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的？</p><ul><li><p>通过测试：org.apache.catalina.connector.RequestFacade 实现了 HttpServletRequest接口</p><ul><li><pre><code class="java">public class RequestFacade implements HttpServletRequest &#123;&#125;<pre class="line-numbers language-none"><code class="language-none">  - 测试结果说明：Tomcat服务器（WEB服务器、WEB容器）实现了HttpServletRequest接口，还是说明了Tomcat服务器实现了Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是HttpServletRequest接口中有哪些方法，这些方法可以完成什么功能！！！！- HttpServletRequest对象中都有什么信息？都包装了什么信息？  - HttpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息？封装了HTTP的请求协议。  - 实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletRequest对象当中，传给了我们javaweb程序员。  - javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。- request和response对象的生命周期？  - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。  - 一次请求对应一个request。  - 两次请求则对应两个request。  - .....- HttpServletRequest接口中有哪些常用的方法？  - 怎么获取前端浏览器用户提交的数据？    - &#96;&#96;&#96;java      Map&lt;String,String[]&gt; getParameterMap() 这个是获取Map      Enumeration&lt;String&gt; getParameterNames() 这个是获取Map集合中所有的key      String[] getParameterValues(String name) 根据key获取Map集合的value      String getParameter(String name)  获取value这个一维数组当中的第一个元素。这个方法最常用。      &#x2F;&#x2F; 以上的4个方法，和获取用户提交的数据有关系。</code></pre></code></pre></li><li><p>思考：如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢？</p><ul><li><p>前端提交的数据格式：username&#x3D;abc&amp;userpwd&#x3D;111&amp;aihao&#x3D;s&amp;aihao&#x3D;d&amp;aihao&#x3D;tt</p></li><li><p>我会采用Map集合来存储：</p><ul><li>&#96;&#96;&#96;java<br>Map&lt;String,String&gt;<br>key存储String<br>value存储String<br>这种想法对吗？不对。<br>如果采用以上的数据结构存储会发现key重复的时候value覆盖。<br>key         value<br>———————<br>username    abc<br>userpwd     111<br>aihao       s<br>aihao       d<br>aihao       tt<br>这样是不行的，因为map的key不能重复。<br>Map&lt;String, String[]&gt;<br>key存储String<br>value存储String[]<br>keyvalue<br>——————————-<br>username{“abc”}<br>userpwd{“111”}<br>aihao{“s”,”d”,”tt”}<pre class="line-numbers language-none"><code class="language-none">    - 注意：前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串&quot;120&quot;的方式提交的，所以服务器端获取到的一定是一个字符串的&quot;120&quot;，而不是一个数字。（前端永远提交的是字符串，后端获取的也永远是字符串。）  - 手工开发一个webapp。测试HttpServletRequest接口中的相关方法。  - 先测试了4个常用的方法，获取请求参数的四个方法。    - &#96;&#96;&#96;java      Map&lt;String,String[]&gt; parameterMap &#x3D; request.getParameterMap();      Enumeration&lt;String&gt; names &#x3D; request.getParameterNames();      String[] values &#x3D; request.getParameterValues(&quot;name&quot;);      String value &#x3D; request.getParameter(&quot;name&quot;);</code></pre></li></ul></li></ul></li><li><p>request对象实际上又称为“请求域”对象。</p><ul><li><p>应用域对象是什么？</p><ul><li><p>ServletContext （Servlet上下文对象。）</p></li><li><p>什么情况下会考虑向ServletContext这个应用域当中绑定数据呢？</p><ul><li>第一：所有用户共享的数据。</li><li>第二：这个共享的数据量很小。</li><li>第三：这个共享的数据很少的修改操作。</li><li>在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。</li><li>实际上向应用域当中绑定数据，就相当于把数据放到了缓存（Cache）当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。</li></ul></li><li><p>你见过哪些缓存技术呢？</p><ul><li>字符串常量池</li><li>整数型常量池 [-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中获取。大大提升系统性能。</li><li>数据库连接池（提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。）</li><li>线程池（Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能）</li><li>后期你还会学习更多的缓存技术，例如：redis、mongoDB…..</li></ul></li><li><p>ServletContext当中有三个操作域的方法：</p><ul><li><p>&#96;&#96;&#96;java<br>void setAttribute(String name, Object obj); &#x2F;&#x2F; 向域当中绑定数据。<br>Object getAttribute(String name); &#x2F;&#x2F; 从域当中根据name获取数据。<br>void removeAttribute(String name); &#x2F;&#x2F; 将域当中绑定的数据移除</p><p>&#x2F;&#x2F; 以上的操作类似于Map集合的操作。<br>Map&lt;String, Object&gt; map;<br>map.put(“name”, obj); &#x2F;&#x2F; 向map集合中放key和value<br>Object obj &#x3D; map.get(“name”); &#x2F;&#x2F; 通过map集合的key获取value<br>map.remove(“name”); &#x2F;&#x2F; 通过Map集合的key删除key和value这个键值对。</p><pre class="line-numbers language-none"><code class="language-none">- “请求域”对象  - “请求域”对象要比“应用域”对象范围小很多。生命周期短很多。请求域只在一次请求内有效。  - 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。  - 请求域对象也有这三个方法：    - &#96;&#96;&#96;java      void setAttribute(String name, Object obj); &#x2F;&#x2F; 向域当中绑定数据。      Object getAttribute(String name); &#x2F;&#x2F; 从域当中根据name获取数据。      void removeAttribute(String name); &#x2F;&#x2F; 将域当中绑定的数据移除</code></pre></li></ul></li><li><p>请求域和应用域的选用原则？</p><ul><li>尽量使用小的域对象，因为小的域对象占用的资源较少。</li></ul></li></ul></li><li><p>跳转</p><ul><li><p>转发（一次请求）</p><ul><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 第一步：获取请求转发器对象<br>RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;b”);<br>&#x2F;&#x2F; 第二步：调用转发器的forward方法完成跳转&#x2F;转发<br>dispatcher.forward(request,response);</p><p>&#x2F;&#x2F; 第一步和第二步代码可以联合在一起。<br>request.getRequestDispatcher(“&#x2F;b”).forward(request,response);</p><pre class="line-numbers language-none"><code class="language-none">- 两个Servlet怎么共享数据？  - 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。- 转发的下一个资源必须是一个Servlet吗？  - 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如：html....  - 注意：转发的时候，路径的写法要注意，转发的路径以“&#x2F;”开始，不加项目名。- 关于request对象中两个非常容易混淆的方法：  - &#96;&#96;&#96;java        &#x2F;&#x2F; uri?username&#x3D;zhangsan&amp;userpwd&#x3D;123&amp;sex&#x3D;1    String username &#x3D; request.getParameter(&quot;username&quot;);        &#x2F;&#x2F; 之前一定是执行过：request.setAttribute(&quot;name&quot;, new Object())    Object obj &#x3D; request.getAttribute(&quot;name&quot;);        &#x2F;&#x2F; 以上两个方法的区别是什么？    &#x2F;&#x2F; 第一个方法：获取的是用户在浏览器上提交的数据。    &#x2F;&#x2F; 第二个方法：获取的是请求域当中绑定的数据。</code></pre></li></ul></li></ul></li><li><p>HttpServletRequest接口的其他常用方法：</p><ul><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 获取客户端的IP地址<br>String remoteAddr &#x3D; request.getRemoteAddr();</p><p>&#x2F;&#x2F; get请求在请求行上提交数据。<br>&#x2F;&#x2F; post请求在请求体中提交数据。<br>&#x2F;&#x2F; 设置请求体的字符集。（显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。）<br>&#x2F;&#x2F; Tomcat10之后，request请求体当中的字符集默认就是UTF-8，不需要设置字符集，不会出现乱码问题。<br>&#x2F;&#x2F; Tomcat9前（包括9在内），如果前端请求体提交的是中文，后端获取之后出现乱码，怎么解决这个乱码？执行以下代码。<br>request.setCharacterEncoding(“UTF-8”);</p><p>&#x2F;&#x2F; 在Tomcat9之前（包括9），响应中文也是有乱码的，怎么解决这个响应的乱码？<br>response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);<br>&#x2F;&#x2F; 在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。</p><p>&#x2F;&#x2F; 注意一个细节<br>&#x2F;&#x2F; 在Tomcat10包括10在内之后的版本，中文将不再出现乱码。（这也体现了中文地位的提升。）</p><p>&#x2F;&#x2F; get请求乱码问题怎么解决？<br>&#x2F;&#x2F; get请求发送的时候，数据是在请求行上提交的，不是在请求体当中提交的。<br>&#x2F;&#x2F; get请求乱码怎么解决<br>&#x2F;&#x2F; 方案：修改CATALINA_HOME&#x2F;conf&#x2F;server.xml配置文件</p><Connector URIEncoding="UTF-8" />// 注意：从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以GET请求也没有乱码问题了。    <p>&#x2F;&#x2F; 获取应用的根路径<br>String contextPath &#x3D; request.getContextPath();</p><p>&#x2F;&#x2F; 获取请求方式<br>String method &#x3D; request.getMethod();</p><p>&#x2F;&#x2F; 获取请求的URI<br>String uri &#x3D; request.getRequestURI();  &#x2F;&#x2F; &#x2F;aaa&#x2F;testRequest</p><p>&#x2F;&#x2F; 获取servlet path<br>String servletPath &#x3D; request.getServletPath(); &#x2F;&#x2F;   &#x2F;testRequest</p><pre class="line-numbers language-none"><code class="language-none">## 使用纯Servlet做一个单表的CRUD操作- 使用纯粹的Servlet完成单表【对部门的】的增删改查操作。（B&#x2F;S结构的。）- 实现步骤  - 第一步：准备一张数据库表。（sql脚本）    - &#96;&#96;&#96;sql      # 部门表      drop table if exists dept;      create table dept(      deptno int primary key,          dname varchar(255),          loc varchar(255)      );      insert into dept(deptno, dname, loc) values(10, &#39;XiaoShouBu&#39;, &#39;BEIJING&#39;);      insert into dept(deptno, dname, loc) values(20, &#39;YanFaBu&#39;, &#39;SHANGHAI&#39;);      insert into dept(deptno, dname, loc) values(30, &#39;JiShuBu&#39;, &#39;GUANGZHOU&#39;);      insert into dept(deptno, dname, loc) values(40, &#39;MeiTiBu&#39;, &#39;SHENZHEN&#39;);      commit;      select * from dept;</code></pre></li></ul></li></ul></li></ul></li><li><p>第二步：准备一套HTML页面（项目原型）【前端开发工具使用HBuilder】</p><ul><li>把HTML页面准备好</li><li>然后将HTML页面中的链接都能够跑通。（页面流转没问题。）</li><li>应该设计哪些页面呢？<ul><li>欢迎页面：index.html</li><li>列表页面：list.html（以列表页面为核心，展开其他操作。）</li><li>新增页面：add.html</li><li>修改页面：edit.html</li><li>详情页面：detail.html</li></ul></li></ul></li><li><p>第三步：分析我们这个系统包括哪些功能？</p><ul><li>什么叫做一个功能呢？<ul><li>只要 这个操作连接了数据库，就表示一个独立的功能。</li></ul></li><li>包括哪些功能？<ul><li>查看部门列表</li><li>新增部门</li><li>删除部门</li><li>查看部门详细信息</li><li>跳转到修改页面</li><li>修改部门</li></ul></li></ul></li><li><p>第四步：在IDEA当中搭建开发环境</p><ul><li>创建一个webapp（给这个webapp添加servlet-api.jar和jsp-api.jar到classpath当中。）</li><li>向webapp中添加连接数据库的jar包（mysql驱动）<ul><li>必须在WEB-INF目录下新建lib目录，然后将mysql的驱动jar包拷贝到这个lib目录下。这个目录名必须叫做lib，全部小写的。</li></ul></li><li>JDBC的工具类</li><li>将所有HTML页面拷贝到web目录下。</li></ul></li><li><p>第五步：实现第一个功能：查看部门列表</p><ul><li><p>我们应该怎么去实现一个功能呢？</p><ul><li>建议：你可以从后端往前端一步一步写。也可以从前端一步一步往后端写。都可以。但是千万要记住不要想起来什么写什么。你写代码的过程最好是程序的执行过程。也就是说：程序执行到哪里，你就写哪里。这样一个顺序流下来之后，基本上不会出现什么错误、意外。</li><li>从哪里开始？<ul><li>假设从前端开始，那么一定是从用户点击按钮那里开始的。</li></ul></li></ul></li><li><p>第一：先修改前端页面的超链接，因为用户先点击的就是这个超链接。</p><ul><li>&#96;&#96;&#96;html<br><a href="/oa/dept/list">查看部门列表</a><pre class="line-numbers language-none"><code class="language-none">- 第二：编写web.xml文件  - &#96;&#96;&#96;xml    &lt;servlet&gt;        &lt;servlet-name&gt;list&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptListServlet&lt;&#x2F;servlet-class&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;list&lt;&#x2F;servlet-name&gt;        &lt;!--web.xml文件中的这个路径也是以“&#x2F;”开始的，但是不需要加项目名--&gt;        &lt;url-pattern&gt;&#x2F;dept&#x2F;list&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;</code></pre></li></ul></li><li><p>第三：编写DeptListServlet类继承HttpServlet类。然后重写doGet方法。</p><ul><li><p>&#96;&#96;&#96;java<br>package com.bjpowernode.oa.web.action;</p><p>import jakarta.servlet.ServletException;<br>import jakarta.servlet.http.HttpServlet;<br>import jakarta.servlet.http.HttpServletRequest;<br>import jakarta.servlet.http.HttpServletResponse;</p><p>import java.io.IOException;</p><p>public class DeptListServlet extends HttpServlet {<br>@Override<br>protected void doGet(HttpServletRequest request, HttpServletResponse response)<br>        throws ServletException, IOException {<br>}<br>}</p><pre class="line-numbers language-none"><code class="language-none">- 第四：在DeptListServlet类的doGet方法中连接数据库，查询所有的部门，动态的展示部门列表页面.  - 分析list.html页面中哪部分是固定死的，哪部分是需要动态展示的。  - list.html页面中的内容所有的双引号要替换成单引号，因为out.print(&quot;&quot;)这里有一个双引号，容易冲突。  - 现在写完这个功能之后，你会有一种感觉，感觉开发很繁琐，只使用servlet写代码太繁琐了。  - &#96;&#96;&#96;java    while(rs.next())&#123;        String deptno &#x3D; rs.getString(&quot;a&quot;);        String dname &#x3D; rs.getString(&quot;dname&quot;);        String loc &#x3D; rs.getString(&quot;loc&quot;);            out.print(&quot;&lt;tr&gt;&quot;);        out.print(&quot;&lt;td&gt;&quot;+(++i)+&quot;&lt;&#x2F;td&gt;&quot;);        out.print(&quot;&lt;td&gt;&quot;+deptno+&quot;&lt;&#x2F;td&gt;&quot;);        out.print(&quot;&lt;td&gt;&quot;+dname+&quot;&lt;&#x2F;td&gt;&quot;);        out.print(&quot;&lt;td&gt;&quot;);        out.print(&quot;&lt;a href&#x3D;&#39;&#39;&gt;删除&lt;&#x2F;a&gt;&quot;);        out.print(&quot;&lt;a href&#x3D;&#39;edit.html&#39;&gt;修改&lt;&#x2F;a&gt;&quot;);        out.print(&quot;&lt;a href&#x3D;&#39;detail.html&#39;&gt;详情&lt;&#x2F;a&gt;&quot;);        out.print(&quot;&lt;&#x2F;td&gt;&quot;);        out.print(&quot;&lt;&#x2F;tr&gt;&quot;);    &#125;</code></pre></li></ul></li></ul></li><li><p>第六步：查看部门详情。</p><ul><li><p>建议：从前端往后端一步一步实现。首先要考虑的是，用户点击的是什么？用户点击的东西在哪里？</p><ul><li><p>一定要先找到用户点的“详情”在哪里。找了半天，终于在后端的java程序中找到了</p><ul><li><pre><code class="html">&lt;a href=&#39;写一个路径&#39;&gt;详情&lt;/a&gt;<pre class="line-numbers language-none"><code class="language-none">  - 详情  是需要连接数据库的，所以这个超链接点击之后也是需要执行一段java代码的。所以要将这个超链接的路径修改一下。  - 注意：修改路径之后，这个路径是需要加项目名的。&quot;&#x2F;oa&#x2F;dept&#x2F;detail&quot;- 技巧：  - &#96;&#96;&#96;java    out.print(&quot;&lt;a href&#x3D;&#39;&quot;+contextPath+&quot;&#x2F;dept&#x2F;detail?deptno&#x3D;&quot;+deptno+&quot;&#39;&gt;详情&lt;&#x2F;a&gt;&quot;);</code></pre></code></pre></li><li><p>重点：向服务器提交数据的格式：uri?name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</p></li><li><p>这里的问号，必须是英文的问号。不能中文的问号。</p></li></ul></li></ul></li><li><p>解决404的问题。写web.xml文件。</p><ul><li>&#96;&#96;&#96;xml<servlet>    <servlet-name>detail</servlet-name>    <servlet-class>com.bjpowernode.oa.web.action.DeptDetailServlet</servlet-class></servlet><servlet-mapping>    <servlet-name>detail</servlet-name>    <url-pattern>/dept/detail</url-pattern></servlet-mapping><pre class="line-numbers language-none"><code class="language-none">- 编写一个类：DeptDetailServlet继承HttpServlet，重写doGet方法。  - &#96;&#96;&#96;java    package com.bjpowernode.oa.web.action;        import jakarta.servlet.ServletException;    import jakarta.servlet.http.HttpServlet;    import jakarta.servlet.http.HttpServletRequest;    import jakarta.servlet.http.HttpServletResponse;        import java.io.IOException;        public class DeptDetailServlet extends HttpServlet &#123;        @Override        protected void doGet(HttpServletRequest request, HttpServletResponse response)                throws ServletException, IOException &#123;            &#x2F;&#x2F;中文思路（思路来源于：你要做什么？目标：查看部门详细信息。）            &#x2F;&#x2F; 第一步：获取部门编号            &#x2F;&#x2F; 第二步：根据部门编号查询数据库，获取该部门编号对应的部门信息。            &#x2F;&#x2F; 第三步：将部门信息响应到浏览器上。（显示一个详情。）        &#125;    &#125;</code></pre></li></ul></li><li><p>在doGet方法当中：连接数据库，根据部门编号查询该部门的信息。动态展示部门详情页。</p></li></ul></li><li><p>第七步：删除部门</p><ul><li><p>怎么开始？从哪里开始？从前端页面开始，用户点击删除按钮的时候，应该提示用户是否删除。因为删除这个动作是比较危险的。任何系统在进行删除操作之前，是必须要提示用户的，因为这个删除的动作有可能是用户误操作。（在前端页面上写JS代码，来提示用户是否删除。）</p><ul><li><pre><code class="html">&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;del(30)&quot; &gt;删除&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function del(dno)&#123;        if(window.confirm(&quot;亲，删了不可恢复哦！&quot;))&#123;            document.location.href = &quot;/oa/dept/delete?deptno=&quot; + dno;        &#125;    &#125;&lt;/script&gt;<pre class="line-numbers language-none"><code class="language-none">  - 以上的前端程序要写到后端的java代码当中：    - DeptListServlet类的doGet方法当中，使用out.print()方法，将以上的前端代码输出到浏览器上。  - 解决404的问题：    - http:&#x2F;&#x2F;localhost:8080&#x2F;oa&#x2F;dept&#x2F;delete?deptno&#x3D;30     - web.xml文件      - &#96;&#96;&#96;xml      &lt;servlet&gt;          &lt;servlet-name&gt;delete&lt;&#x2F;servlet-name&gt;          &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptDelServlet&lt;&#x2F;servlet-class&gt;      &lt;&#x2F;servlet&gt;      &lt;servlet-mapping&gt;          &lt;servlet-name&gt;delete&lt;&#x2F;servlet-name&gt;          &lt;url-pattern&gt;&#x2F;dept&#x2F;delete&lt;&#x2F;url-pattern&gt;      &lt;&#x2F;servlet-mapping&gt;</code></pre></code></pre></li><li><p>编写DeptDelServlet继承HttpServlet，重写doGet方法。</p></li><li><p>&#96;&#96;&#96;java<br>package com.bjpowernode.oa.web.action;</p><p>import jakarta.servlet.ServletException;<br>import jakarta.servlet.http.HttpServlet;<br>import jakarta.servlet.http.HttpServletRequest;<br>import jakarta.servlet.http.HttpServletResponse;</p><p>import java.io.IOException;</p><p>public class DeptDelServlet extends HttpServlet {<br>@Override<br>protected void doGet(HttpServletRequest request, HttpServletResponse response)<br>        throws ServletException, IOException {<br>    &#x2F;&#x2F; 根据部门编号，删除部门。<br><br>}<br>}</p><pre class="line-numbers language-none"><code class="language-none">  - 删除成功或者失败的时候的一个处理（这里我们选择了转发，并没有使用重定向机制。）    - &#96;&#96;&#96;java    &#x2F;&#x2F; 判断删除成功了还是失败了。    if (count &#x3D;&#x3D; 1) &#123;        &#x2F;&#x2F;删除成功        &#x2F;&#x2F;仍然跳转到部门列表页面        &#x2F;&#x2F;部门列表页面的显示需要执行另一个Servlet。怎么办？转发。        request.getRequestDispatcher(&quot;&#x2F;dept&#x2F;list&quot;).forward(request, response);    &#125;else&#123;        &#x2F;&#x2F; 删除失败        request.getRequestDispatcher(&quot;&#x2F;error.html&quot;).forward(request, response);    &#125;</code></pre></li></ul></li></ul></li><li><p>第八步：新增部门</p><ul><li>注意：最后保存成功之后，转发到 &#x2F;dept&#x2F;list 的时候，会出现405，为什么？<ul><li>第一：保存用的是post请求。底层要执行doPost方法。</li><li>第二：转发是一次请求，之前是post，之后还是post，因为它是一次请求。</li><li>第三：&#x2F;dept&#x2F;list Servlet当中只有一个doGet方法。</li><li>怎么解决？两种方案<ul><li>第一种：在&#x2F;dept&#x2F;list Servlet中添加doPost方法，然后在doPost方法中调用doGet。</li><li>第二种：重定向。</li></ul></li></ul></li></ul></li><li><p>第九步：跳转到修改部门的页面</p></li><li><p>第十步：修改部门</p></li></ul></li></ul><h2 id="在一个web应用中应该如何完成资源的跳转"><a href="#在一个web应用中应该如何完成资源的跳转" class="headerlink" title="在一个web应用中应该如何完成资源的跳转"></a>在一个web应用中应该如何完成资源的跳转</h2><ul><li><p>在一个web应用中通过两种方式，可以完成资源的跳转：</p><ul><li>第一种方式：转发</li><li>第二种方式：重定向</li></ul></li><li><p>转发和重定向有什么区别？</p><ul><li><p>代码上有什么区别？</p><ul><li><p>转发</p><ul><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 获取请求转发器对象<br>RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;dept&#x2F;list”);<br>&#x2F;&#x2F; 调用请求转发器对象的forward方法完成转发<br>dispatcher.forward(request, response);</p><p>&#x2F;&#x2F; 合并一行代码<br>request.getRequestDispatcher(“&#x2F;dept&#x2F;list”).forward(request, response);<br>&#x2F;&#x2F; 转发的时候是一次请求，不管你转发了多少次。都是一次请求。<br>&#x2F;&#x2F; AServlet转发到BServlet，再转发到CServlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。<br>&#x2F;&#x2F; 这是因为调用forward方法的时候，会将当前的request和response对象传递给下一个Servlet。</p><pre class="line-numbers language-none"><code class="language-none">- 重定向  - &#96;&#96;&#96;java    &#x2F;&#x2F; 注意：路径上要加一个项目名。为什么？    &#x2F;&#x2F; 浏览器发送请求，请求路径上是需要添加项目名的。    &#x2F;&#x2F; 以下这一行代码会将请求路径“&#x2F;oa&#x2F;dept&#x2F;list”发送给浏览器    &#x2F;&#x2F; 浏览器会自发的向服务器发送一次全新的请求：&#x2F;oa&#x2F;dept&#x2F;list    response.sendRedirect(&quot;&#x2F;oa&#x2F;dept&#x2F;list&quot;);</code></pre></li></ul></li></ul></li><li><p>形式上有什么区别？</p><ul><li>转发（一次请求）<ul><li>在浏览器地址栏上发送的请求是：<a href="http://localhost:8080/servlet10/a">http://localhost:8080/servlet10/a</a> ，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。</li></ul></li><li>重定向（两次请求）<ul><li>在浏览器地址栏上发送的请求是：<a href="http://localhost:8080/servlet10/a">http://localhost:8080/servlet10/a</a> ，最终在浏览器地址栏上显示的地址是：<a href="http://localhost:8080/servlet10/b">http://localhost:8080/servlet10/b</a></li></ul></li></ul></li><li><p>转发和重定向的本质区别？</p><ul><li>转发：是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。</li><li>重定向：是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。</li></ul></li><li><p>使用一个例子去描述这个转发和重定向</p><ul><li>借钱（转发：发送了一次请求）<ul><li>杜老师没钱了，找张三借钱，其实张三没有钱，但是张三够义气，张三自己找李四借了钱，然后张三把这个钱给了杜老师，杜老师不知道这个钱是李四的，杜老师只求了一个人。杜老师以为这个钱就是张三的。</li></ul></li><li>借钱（重定向：发送了两次请求）<ul><li>杜老师没钱了，找张三借钱，张三没有钱，张三有一个好哥们，叫李四，李四是个富二代，于是张三将李四的家庭住址告诉了杜老师，杜老师按照这个地址去找到李四，然后从李四那里借了钱。显然杜老师在这个过程中，求了两个人。并且杜老师知道最终这个钱是李四借给俺的。</li></ul></li></ul></li></ul></li><li><p>转发和重定向应该如何选择？什么时候使用转发，什么时候使用重定向？</p><ul><li>如果在上一个Servlet当中向request域当中绑定了数据，希望从下一个Servlet当中把request域里面的数据取出来，使用转发机制。</li><li>剩下所有的请求均使用重定向。（重定向使用较多。）</li></ul></li><li><p>跳转的下一个资源有没有要求呢？必须是一个Servlet吗？</p><ul><li>不一定，跳转的资源只要是服务器内部合法的资源即可。包括：Servlet、JSP、HTML…..</li></ul></li><li><p>转发会存在浏览器的刷新问题。</p></li></ul><h2 id="将oa项目中的资源跳转修改为合适的跳转方式"><a href="#将oa项目中的资源跳转修改为合适的跳转方式" class="headerlink" title="将oa项目中的资源跳转修改为合适的跳转方式"></a>将oa项目中的资源跳转修改为合适的跳转方式</h2><ul><li>删除之后，重定向</li><li>修改之后，重定向</li><li>保存之后，重定向</li><li>重定向：<ul><li>成功</li><li>失败</li></ul></li></ul><h2 id="Servlet注解，简化配置"><a href="#Servlet注解，简化配置" class="headerlink" title="Servlet注解，简化配置"></a>Servlet注解，简化配置</h2><ul><li><p>分析oa项目中的web.xml文件</p><ul><li>现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。</li><li>在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。</li><li>而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢？可以的。</li></ul></li><li><p>Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么？</p><ul><li>开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。</li><li>web.xml文件体积变小了。</li></ul></li><li><p>并不是说注解有了之后，web.xml文件就不需要了：</p><ul><li>有一些需要变化的信息，还是要配置到web.xml文件中。一般都是 注解+配置文件 的开发模式。</li><li>一些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。</li></ul></li><li><p>我们的第一个注解：</p><ul><li>&#96;&#96;&#96;<br>jakarta.servlet.annotation.WebServlet<pre class="line-numbers language-none"><code class="language-none">  - 在Servlet类上使用：@WebServlet，WebServlet注解中有哪些属性呢？    - name属性：用来指定Servlet的名字。等同于：&lt;servlet-name&gt;    - urlPatterns属性：用来指定Servlet的映射路径。可以指定多个字符串。&lt;url-pattern&gt;    - loadOnStartUp属性：用来指定在服务器启动阶段是否加载该Servlet。等同于：&lt;load-on-startup&gt;    - value属性：当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。    - 注意：不是必须将所有属性都写上，只需要提供需要的。（需要什么用什么。）    - 注意：属性是一个数组，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略。- 注解对象的使用格式：  - @注解名称(属性名&#x3D;属性值, 属性名&#x3D;属性值, 属性名&#x3D;属性值....)## 使用模板方法设计模式优化oa项目- 上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。  - 一个单标的CRUD，就写了6个Servlet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。（类的数量太大。）  - 怎么解决这个类爆炸问题？可以使用模板方法设计模式。- 怎么解决类爆炸问题？  - 以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。  - 可以这样做：一个请求对应一个方法。一个业务对应一个Servlet类。  - 处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet。## 分析使用纯粹Servlet开发web应用的缺陷- 在Servlet当中编写HTML&#x2F;CSS&#x2F;JavaScript等前端代码。存在什么问题？  - java程序中编写前端代码，编写难度大。麻烦。  - java程序中编写前端代码，显然程序的耦合度非常高。  - java程序中编写前端代码，代码非常不美观。  - java程序中编写前端代码，维护成本太高。（非常难于维护）    - 修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包，重新发布。- 思考一下，如果是你的话，你准备怎么解决这个问题？  - 思路很重要。使用什么样的思路去做、去解决这个问题    - 上面的那个Servlet（Java程序）能不能不写了，让机器自动生成。我们程序员只需要写这个Servlet程序中的“前端的那段代码”，然后让机器将我们写的“前端代码”自动翻译生成“Servlet这种java程序”。然后机器再自动将“java”程序编译生成&quot;class&quot;文件。然后再使用JVM调用这个class中的方法。## 关于B&#x2F;S结构系统的会话机制（session机制）- 什么是会话？  - 会话对应的英语单词：session  - 用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做：session。  - 什么是一次请求：用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是：request。  - 一个会话当中包含多次请求。（一次会话对应N次请求。）  - 在java的servlet规范当中，session对应的类名：HttpSession（jarkata.servlet.http.HttpSession）- session机制属于B&#x2F;S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。- session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用session对象可以保留会话状态。）- 为什么需要session对象来保存会话状态呢？  - 因为HTTP协议是一种无状态协议。  - 什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。  - 只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗？    - 不知道。服务器是不知道浏览器关闭的。  - 张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成：  - 张三专属的session对象  - 李四专属的session对象  - 为什么不使用request对象保存会话状态？为什么不使用ServletContext对象保存会话状态？  - request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。  - request是一次请求一个对象。  - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。  - ServletContext对象的域太大。  - request请求域（HttpServletRequest）、session会话域（HttpSession）、application域（ServletContext）  - request &lt; session &lt; application  - 思考一下：session对象的实现原理。  - HttpSession session &#x3D; request.getSession();  - 这行代码很神奇。张三访问的时候获取的session对象就是张三的。李四访问的时候获取的session对象就是李四的。  - session的实现原理：  - JSESSIONID&#x3D;xxxxxx  这个是以Cookie的形式保存在浏览器的内存中的。浏览器只要关闭。这个cookie就没有了。  - session列表是一个Map，map的key是sessionid，map的value是session对象。  - 用户第一次请求，服务器生成session对象，同时生成id，将id发送给浏览器。  - 用户第二次请求，自动将浏览器内存中的id发送给服务器，服务器根据id查找session对象。  - 关闭浏览器，内存消失，cookie消失，sessionid消失，会话等同于结束。- Cookie禁用了，session还能找到吗？  - cookie禁用是什么意思？服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。  - 找不到了。每一次请求都会获取到新的session对象。  - cookie禁用了，session机制还能实现吗？    - 可以。需要使用URL重写机制。    - http:&#x2F;&#x2F;localhost:8080&#x2F;servlet12&#x2F;test&#x2F;session;jsessionid&#x3D;19D1C99560DCBF84839FA43D58F56E16    - URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：你要是禁用cookie，你就别用了。- 总结一下到目前位置我们所了解的域对象：  - request（对应的类名：HttpServletRequest）    - 请求域（请求级别的）  - session（对应的类名：HttpSession）    - 会话域（用户级别的）  - application（对应的类名：ServletContext）    - 应用域（项目级别的，所有用户共享的。）  - 这三个域对象的大小关系    - request &lt; session &lt; application  - 他们三个域对象都有以下三个公共的方法：    - setAttribute（向域当中绑定数据）    - getAttribute（从域当中获取数据）    - removeAttribute（删除域当中的数据）  - 使用原则：尽量使用小的域。- session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。  - 登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，表示用户没有登录过。则跳转到登录页面。- 销毁session对象：  - &#96;&#96;&#96;java    session.invalidate();</code></pre></li></ul></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul><li><p>session的实现原理中，每一个session对象都会关联一个sessionid，例如：</p><ul><li>JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8</li><li>以上的这个键值对数据其实就是cookie对象。</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。</li><li>例如，这个Cookie: JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。</li><li>服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。</li></ul></li><li><p>cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？？？？？？？</p></li><li><p>cookie最终是保存在浏览器客户端上的。</p><ul><li>可以保存在运行内存中。（浏览器只要关闭cookie就消失了。）</li><li>也可以保存在硬盘文件中。（永久保存。）</li></ul></li><li><p>cookie有啥用呢？</p><ul><li>cookie和session机制其实都是为了保存会话的状态。</li><li>cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。）</li><li>session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。）</li><li>为什么要有cookie和session机制呢？因为HTTP协议是无状态 无连接协议。</li></ul></li><li><p>cookie的经典案例</p><ul><li>京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？<ul><li>将购物车中的商品编号放到cookie当中，cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。<ul><li>京东存储购物车中商品的cookie可能是这样的：productIds&#x3D;xxxxx,yyyy,zzz,kkkk</li><li>注意：cookie如果清除掉，购物车中的商品就消失了。</li></ul></li></ul></li><li>126邮箱中有一个功能：十天内免登录<ul><li>这个功能也是需要cookie来实现的。</li><li>怎么实现的呢？<ul><li>用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器，服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。</li><li>怎么让cookie失效？<ul><li>十天过后自动失效。</li><li>或者改密码。</li><li>或者在客户端浏览器上清除cookie。</li></ul></li></ul></li></ul></li></ul></li><li><p>cookie机制和session机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要是你是做web开发，不管是什么编程语言，cookie和session机制都是需要的。</p></li><li><p>HTTP协议中规定：任何一个cookie都是由name和value组成的。name和value都是字符串类型的。</p></li><li><p>在java的servlet中，对cookie提供了哪些支持呢？</p><ul><li>提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie;</li><li>java程序怎么把cookie数据发送给浏览器呢？response.addCookie(cookie);</li></ul></li><li><p>在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL。）</p></li><li><p>关于cookie的有效时间</p><ul><li>怎么用java设置cookie的有效时间<ul><li>cookie.setMaxAge(60 * 60); 设置cookie在一小时之后失效。</li></ul></li><li>没有设置有效时间：默认保存在浏览器的运行内存中，浏览器关闭则cookie消失。</li><li>只要设置cookie的有效时间 &gt; 0，这个cookie一定会存储到硬盘文件当中。</li><li>设置cookie的有效时间 &#x3D; 0 呢？<ul><li>cookie被删除，同名cookie被删除。</li></ul></li><li>设置cookie的有效时间 &lt; 0 呢？<ul><li>保存在运行内存中。和不设置一样。</li></ul></li></ul></li><li><p>关于cookie的path，cookie关联的路径：</p><ul><li>假设现在发送的请求路径是“<a href="http://localhost:8080/servlet13/cookie/generate%E2%80%9D%E7%94%9F%E6%88%90%E7%9A%84cookie%EF%BC%8C%E5%A6%82%E6%9E%9Ccookie%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AEpath%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84path%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">http://localhost:8080/servlet13/cookie/generate”生成的cookie，如果cookie没有设置path，默认的path是什么？</a><ul><li>默认的path是：<a href="http://localhost:8080/servlet13/cookie">http://localhost:8080/servlet13/cookie</a> 以及它的子路径。</li><li>也就是说，以后只要浏览器的请求路径是<a href="http://localhost:8080/servlet13/cookie">http://localhost:8080/servlet13/cookie</a> 这个路径以及这个路径下的子路径，cookie都会被发送到服务器。</li></ul></li><li>手动设置cookie的path<ul><li>cookie.setPath(“&#x2F;servlet13”); 表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。</li></ul></li></ul></li><li><p>浏览器发送cookie给服务器了，服务器中的java程序怎么接收？</p><ul><li><p>&#96;&#96;&#96;java<br>Cookie[] cookies &#x3D; request.getCookies(); &#x2F;&#x2F; 这个方法可能返回null<br>if(cookies !&#x3D; null){<br>for(Cookie cookie : cookies){<br>    &#x2F;&#x2F; 获取cookie的name<br>    String name &#x3D; cookie.getName();<br>    &#x2F;&#x2F; 获取cookie的value<br>    String value &#x3D; cookie.getValue();<br>}<br>}</p><pre class="line-numbers language-none"><code class="language-none">- 使用cookie实现一下十天内免登录功能。  - 先实现登录功能    - 登录成功      - 跳转到部门列表页面    - 登录失败      - 跳转到登录失败页面  - 修改前端页面    - 在登录页面给一个复选框，复选框后面给一句话：十天内免登录。    - 用户选择了复选框：表示要支持十天内免登录。    - 用户没有选择复选框：表示用户不想使用十天内免登录功能。  - 修改Servlet中的login方法    - 如果用户登录成功了，并且用户登录时选择了十天内免登录功能，这个时候应该在Servlet的login方法中创建cookie，用来存储用户名和密码，并且设置路径，设置有效期，将cookie响应给浏览器。（浏览器将其自动保存在硬盘文件当中10天）  - 用户再次访问该网站的时候，访问这个网站的首页的时候，有两个走向:    - 要么跳转到部门列表页面    - 要么跳转到登录页面    - 以上分别有两个走向，这显然是需要编写java程序进行控制的。# JSP- 我的第一个JSP程序：    - 在WEB-INF目录之外创建一个index.jsp文件，然后这个文件中没有任何内容。  - 将上面的项目部署之后，启动服务器，打开浏览器，访问以下地址：  - http:&#x2F;&#x2F;localhost:8080&#x2F;jsp&#x2F;index.jsp 展现在大家面前的是一个空白。  - 实际上访问以上的这个：index.jsp，底层执行的是：index_jsp.class 这个java程序。  - 这个index.jsp会被tomcat翻译生成index_jsp.java文件，然后tomcat服务器又会将index_jsp.java编译生成index_jsp.class文件  - 访问index.jsp，实际上执行的是index_jsp.class中的方法。  - JSP实际上就是一个Servlet。  - index.jsp访问的时候，会自动翻译生成index_jsp.java，会自动编译生成index_jsp.class，那么index_jsp 这就是一个类。  - index_jsp 类继承 HttpJspBase，而HttpJspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。  - jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西。没有任何区别。  - jsp和servlet一样，都是单例的。（假单例。）  - jsp文件第一次访问的时候是比较慢的，为什么？  - 为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的jsp文件先访问一遍。  - 第一次比较麻烦：    - 要把jsp文件翻译生成java源文件    - java源文件要编译生成class字节码文件    - 然后通过class去创建servlet对象    - 然后调用servlet对象的init方法    - 最后调用servlet对象的service方法。  - 第二次就比较快了，为什么？    - 因为第二次直接调用单例servlet对象的service方法即可。  - JSP是什么？  - JSP是java程序。（JSP本质还是一个Servlet）  - JSP是：JavaServer Pages的缩写。（基于Java语言实现的服务器端的页面。）  - Servlet是JavaEE的13个子规范之一，那么JSP也是JavaEE的13个子规范之一。  - JSP是一套规范。所有的web容器&#x2F;web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译”  - 每一个web容器&#x2F;web服务器都会内置一个JSP翻译引擎。  - 对JSP进行错误调试的时候，还是要直接打开JSP文件对应的java文件，检查java代码。- 开发JSP的最高境界：    - 眼前是JSP代码，但是脑袋中呈现的是java代码。  - JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢？  - 职责不同：    - Servlet的职责是什么：收集数据。（Servlet的强项是逻辑处理，业务处理，然后链接数据库，获取&#x2F;收集数据。）    - JSP的职责是什么：展示数据。（JSP的强项是做数据的展示）  - JSP的基础语法  - 在jsp文件中直接编写文字，都会自动被翻译到哪里？    - 翻译到servlet类的service方法的out.write(&quot;翻译到这里&quot;)，直接翻译到双引号里，被java程序当做普通字符串打印输出到浏览器。    - 在JSP中编写的HTML CSS JS代码，这些代码对于JSP来说只是一个普通的字符串。但是JSP把这个普通的字符串一旦输出到浏览器，浏览器就会对HTML CSS JS进行解释执行。展现一个效果。  - JSP的page指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题：    - 通过page指令来设置响应的内容类型，在内容类型的最后面添加：charset&#x3D;UTF-8      - &lt;%@page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;%&gt;，表示响应的内容类型是text&#x2F;html，采用的字符集UTF-8      - &lt;%@page import&#x3D;&quot;java.util.List,java.util.ArrayList&quot;%&gt;  - 怎么在JSP中编写Java程序：    - &lt;% java语句; %&gt;      - 在这个符号当中编写的被视为java程序，被翻译到Servlet类的service方法内部。      - 这里你要细心点，你要思考，在&lt;% %&gt;这个符号里面写java代码的时候，你要时时刻刻的记住你正在“方法体”当中写代码，方法体中可以写什么，不可以写什么，你心里是否明白呢？      - 在service方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。      - service方法当中不能写静态代码块，不能写方法，不能定义成员变量。。。。。。      - 在同一个JSP当中 &lt;%%&gt; 这个符号可以出现多个。    - &lt;%! %&gt;      - 在这个符号当中编写的java程序会自动翻译到service方法之外。      - 这个语法很少用，为什么？不建议使用，因为在service方法外面写静态变量和实例变量，都会存在线程安全问题，因为JSP就是servlet，servlet是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。    - JSP的输出语句      - 怎么向浏览器上输出一个java变量。      - &lt;% String name &#x3D; “jack”;  out.write(&quot;name &#x3D; &quot; + name); %&gt;      - 注意：以上代码中的out是JSP的九大内置对象之一。可以直接拿来用。当然，必须只能在service方法内部使用。      - 如果向浏览器上输出的内容中没有“java代码”，例如输出的字符串是一个固定的字符串，可以直接在jsp中编写，不需要写到&lt;%%&gt; 这里。      - 如果输出的内容中含有“java代码”，这个时候可以使用以下语法格式：        - &lt;%&#x3D; %&gt; 注意：在&#x3D;的后面编写要输出的内容。        - &lt;%&#x3D; %&gt; 这个符号会被翻译到哪里？最终翻译成什么？           - 翻译成了这个java代码：   out.print();          - 翻译到service方法当中了。        - 什么时候使用&lt;%&#x3D;%&gt; 输出呢？输出的内容中含有java的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出的是一个固定的字符串，直接在JSP文件中编写即可。  - 在JSP中如何编写JSP的专业注释    - &lt;%--JSP的专业注释，不会被翻译到java源代码当中。--%&gt;    - &lt;!--这种注释属于HTML的注释，这个注释信息仍然会被翻译到java源代码当中，不建议。--&gt;  - JSP基础语法总结：    - JSP中直接编写普通字符串      - 翻译到service方法的out.write(&quot;这里&quot;)    - &lt;%%&gt;      - 翻译到service方法体内部，里面是一条一条的java语句。    - &lt;%! %&gt;      - 翻译到service方法之外。    - &lt;%&#x3D; %&gt;      - 翻译到service方法体内部，翻译为：out.print();    - &lt;%@page  contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;%&gt;      - page指令，通过contentType属性用来设置响应的内容类型。  - 使用Servlet + JSP完成oa项目的改造。    - 使用Servlet处理业务，收集数据。 使用JSP展示数据。    - 将之前原型中的html文件，全部修改为jsp，然后在jsp文件头部添加page指令（指定contentType防止中文乱码），将所有的JSP直接拷贝到web目录下。    - 完成所有页面的正常流转。（页面仍然能够正常的跳转。修改超链接的请求路径。）            - &lt;%&#x3D;request.getContextPath() %&gt;  在JSP中动态的获取应用的根路径。          - Servlet中连接数据库，查询所有的部门，遍历结果集。      - 遍历结果集的过程中，取出部门编号、部门名、位置等信息，封装成java对象。      - 将java对象存放到List集合中。      - 将List集合存储到request域当中。      - 转发forward到jsp。          - 在JSP中：      - 从request域当中取出List集合。      - 遍历List集合，取出每个部门对象。动态生成tr。          - 思考一个问题：如果我只用JSP这一个技术，能不能开发web应用？      - 当然可以使用JSP来完成所有的功能。因为JSP就是Servlet，在JSP的&lt;%%&gt;里面写的代码就是在service方法当中的，所以在&lt;%%&gt;当中完全可以编写JDBC代码，连接数据库，查询数据，也可以在这个方法当中编写业务逻辑代码，处理业务，都是可以的，所以使用单独的JSP开发web应用完全没问题。      - 虽然JSP一个技术就可以完成web应用，但是不建议，还是建议采用servlet + jsp的方式进行开发。这样都能将各自的优点发挥出来。JSP就是做数据展示。Servlet就是做数据的收集。（JSP中编写的Java代码越少越好。）一定要职责分明。    - JSP文件的扩展名必须是xxx.jsp吗？      - jsp文件的扩展名是可以配置的。不是固定的。      - 在CATALINA_HOME&#x2F;conf&#x2F;web.xml，在这个文件当中配置jsp文件的扩展名。      - &#96;&#96;&#96;xml        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;jsp&lt;&#x2F;servlet-name&gt;            &lt;url-pattern&gt;*.jsp&lt;&#x2F;url-pattern&gt;            &lt;url-pattern&gt;*.jspx&lt;&#x2F;url-pattern&gt;        &lt;&#x2F;servlet-mapping&gt;</code></pre><ul><li><p>xxx.jsp文件对于小猫咪来说，只是一个普通的文本文件，web容器会将xxx.jsp文件最终生成java程序，最终调用的是java对象相关的方法，真正执行的时候，和jsp文件就没有关系了。</p></li><li><p>小窍门：JSP如果看不懂，建议把jsp翻译成java代码，就能看懂了。</p></li><li><p>同学问：包名bean是什么意思？</p><ul><li>javabean（java的logo是一杯冒着热气的咖啡。javabean被翻译为：咖啡豆）</li><li>java是一杯咖啡，咖啡又是由一粒一粒的咖啡豆研磨而成。</li><li>整个java程序中有很多bean的存在。由很多bean组成。</li><li>什么是javabean？实际上javabean你可以理解为符合某种规范的java类，比如：<ul><li>有无参数构造方法</li><li>属性私有化</li><li>对外提供公开的set和get方法</li><li>实现java.io.Serializable接口</li><li>重写toString</li><li>重写hashCode+equals</li><li>….</li></ul></li><li>javabean其实就是java中的实体类。负责数据的封装。</li><li>由于javabean符合javabean规范，具有更强的通用性。</li></ul></li><li><p>完成剩下所有功能的改造。</p></li></ul></li></ul></li><li><p>当前的oa应用存在的问题：</p><ul><li>任何一个用户都可以访问这个系统，都可以对这个系统当中的数据进行增删改这些危险的操作。我只想让合法的用户去使用这个系统，不合法的用户不能访问这个系统，怎么办？<ul><li>加一个登录功能。登录成功的可以访问该系统，登录失败不能访问。</li></ul></li><li>实现登录功能：<ul><li>步骤1：数据库当中添加一个用户表：t_user<ul><li>t_user表当中存储的是用户的登录信息，最基本的也包括：登录的用户名和登录的密码。</li><li>密码一般在数据库表当中存储的是密文。一般不以明文的形式存储。（这里先使用明文方式。）</li><li>向t_user表中插入数据。</li></ul></li><li>步骤2：再实现一个登录页面。<ul><li>登录页面上应该有一个登录的表单。有用户名和密码输入的框。</li><li>用户点击登录，提交表单，提交用户名和密码。form是post方式提交。</li></ul></li><li>步骤3：后台要有一个对应的Servlet来处理登录的请求。<ul><li>登录成功：跳转到部门列表页面。</li><li>登录失败：跳转到失败的页面。</li></ul></li><li>步骤4：再提供一个登录失败的页面。</li></ul></li></ul></li><li><p>登录功能实现了，目前存在的最大的问题：</p><ul><li>这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。</li><li>这个登录没有真正起到拦截的作用。怎么解决？</li></ul></li><li><p>JSP的指令</p><ul><li><p>指令的作用：指导JSP的翻译引擎如何工作（指导当前的JSP翻译引擎如何翻译JSP文件。）</p></li><li><p>指令包括哪些呢？</p><ul><li>include指令：包含指令，在JSP中完成静态包含，很少用了。（这里不讲）</li><li>taglib指令：引入标签库的指令。这个到JJSTL标签库的时候再学习。现在先不管。</li><li>page指令：目前重点学习一个page指令。</li></ul></li><li><p>指令的使用语法是什么？</p><ul><li>&lt;%@指令名  属性名&#x3D;属性值  属性名&#x3D;属性值  属性名&#x3D;属性值….%&gt;</li></ul></li><li><p>关于page指令当中都有哪些常用的属性呢？</p><ul><li><pre><code>&lt;%@page session=&quot;true|false&quot; %&gt;true表示启用JSP的内置对象session，表示一定启动session对象。没有session对象会创建。如果没有设置，默认值就是session=&quot;true&quot;session=&quot;false&quot; 表示不启动内置对象session。当前JSP页面中无法使用内置对象session。<pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;  &lt;%@page contentType&#x3D;&quot;text&#x2F;json&quot; %&gt;  contentType属性用来设置响应的内容类型  但同时也可以设置字符集。  &lt;%@page contentType&#x3D;&quot;text&#x2F;json;charset&#x3D;UTF-8&quot; %&gt;</code></pre></code></pre></li><li><pre><code>&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt;pageEncoding=&quot;UTF-8&quot; 表示设置响应时采用的字符集。<pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;  &lt;%@page import&#x3D;&quot;java.util.List, java.util.Date, java.util.ArrayList&quot; %&gt;  &lt;%@page import&#x3D;&quot;java.util.*&quot; %&gt;  import语句，导包。</code></pre></code></pre></li><li><p>&#96;&#96;&#96;<br>&lt;%@page errorPage&#x3D;”&#x2F;error.jsp” %&gt;<br>当前页面出现异常之后，跳转到error.jsp页面。<br>errorPage属性用来指定出错之后的跳转位置。</p><pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;  &lt;%@page isErrorPage&#x3D;&quot;true&quot; %&gt;  表示启用JSP九大内置对象之一：exception  默认值是false。</code></pre></li></ul></li></ul></li><li><p>JSP的九大内置对象</p><ul><li><p>jakarta.servlet.jsp.PageContext pageContext       页面作用域</p></li><li><p>jakarta.servlet.http.HttpServletRequest request 请求作用域</p></li><li><p>jakarta.servlet.http.HttpSession session  会话作用域</p></li><li><p>jakarta.servlet.ServletContext application 应用作用域</p><ul><li>pageContext &lt; request &lt; session &lt; application</li><li>以上四个作用域都有：setAttribute、getAttribute、removeAttribute方法。</li><li>以上作用域的使用原则：尽可能使用小的域。</li></ul></li><li><p>java.lang.Throwable exception   </p></li><li><p>jakarta.servlet.ServletConfig config</p></li><li><p>java.lang.Object page  （其实是this，当前的servlet对象）</p></li><li><p>jakarta.servlet.jsp.JspWriter out  （负责输出）</p></li><li><p>jakarta.servlet.http.HttpServletResponse response （负责响应）</p></li></ul></li></ul><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><ul><li><p>EL表达式是干什么用的？</p><ul><li>Expression Language（表达式语言）</li><li>EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。</li><li>JSP中夹杂着各种java代码，例如&lt;% java代码 %&gt;、&lt;%&#x3D;%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。</li><li>EL表达式可以算是JSP语法的一部分。EL表达式归属于JSP。</li></ul></li><li><p>EL表达式出现在JSP中主要是：</p><ul><li>从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效：<ul><li>第一功效：从某个域中取数据。<ul><li>四个域：<ul><li>pageContext</li><li>request</li><li>session</li><li>application</li></ul></li></ul></li><li>第二功效：将取出的数据转成字符串。<ul><li>如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。</li></ul></li><li>第三功效：将字符串输出到浏览器。<ul><li>和这个一样：&lt;%&#x3D; %&gt;，将其输出到浏览器。</li></ul></li></ul></li></ul></li><li><p>EL表达式很好用，基本的语法格式：</p><ul><li>${表达式}</li></ul></li><li><p>EL表达式的使用：</p><ul><li><pre><code class="jsp">&lt;%    // 创建User对象    User user = new User();    user.setUsername(&quot;jackson&quot;);    user.setPassword(&quot;1234&quot;);    user.setAge(50);    // 将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。    // 数据是必须存储到四大范围之一的。    request.setAttribute(&quot;userObj&quot;, user);%&gt;&lt;%--使用EL表达式取--%&gt;$&#123;这个位置写什么？？？？这里写的一定是存储到域对象当中时的name&#125;要这样写：$&#123;userObj&#125;等同于java代码：&lt;%=request.getAttribute(&quot;userObj&quot;)%&gt;你不要这样写：$&#123;&quot;userObj&quot;&#125;面试题：    $&#123;abc&#125; 和 $&#123;&quot;abc&quot;&#125;的区别是什么？        $&#123;abc&#125;表示从某个域中取出数据，并且被取的这个数据的name是&quot;abc&quot;，之前一定有这样的代码: 域.setAttribute(&quot;abc&quot;, 对象);        $&#123;&quot;abc&quot;&#125; 表示直接将&quot;abc&quot;当做普通字符串输出到浏览器。不会从某个域中取数据了。$&#123;userObj&#125; 底层是怎么做的？从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。&lt;%--如果想输出对象的属性值，怎么办？--%&gt;$&#123;userObj.username&#125; 使用这个语法的前提是：User对象有getUsername()方法。$&#123;userObj.password&#125; 使用这个语法的前提是：User对象有getPassword()方法。$&#123;userObj.age&#125; 使用这个语法的前提是：User对象有getAge()方法。$&#123;userObj.email&#125; 使用这个语法的前提是：User对象有getEmail()方法。EL表达式中的. 这个语法，实际上调用了底层的getXxx()方法。注意：如果没有对应的get方法，则出现异常。报500错误。$&#123;userObj.addr222.zipcode&#125;以上EL表达式对应的java代码：user.getAddr222().getZipcode()<pre class="line-numbers language-none"><code class="language-none">- EL表达式优先从小范围中读取数据。  - pageContext &lt; request &lt; session &lt; application- EL表达式中有四个隐含的隐式的范围：  - pageScope 对应的是 pageContext范围。  - requestScope 对应的是 request范围。  - sessionScope 对应的是 session范围。  - applicationScope 对应的是 application范围。- EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。- EL表达式取数据的时候有两种形式：  - 第一种：.  （大部分使用这种方式）  - 第二种：[ ] （如果存储到域的时候，这个name中含有特殊字符，可以使用 [ ]）    - request.setAttribute(&quot;abc.def&quot;, &quot;zhangsan&quot;);    - $&#123;requestScope.abc.def&#125; 这样是无法取值的。    - 应该这样：$&#123;requestScope[&quot;abc.def&quot;]&#125;- 掌握使用EL表达式，怎么从Map集合中取数据：  - $&#123;map.key&#125;- 掌握使用EL表达式，怎么从数组和List集合中取数据：  - $&#123;数组[0]&#125;  - $&#123;数组[1]&#125;  - $&#123;list[0]&#125;- page指令当中，有一个属性，可以忽略EL表达式  - &#96;&#96;&#96;    &lt;%@page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; isELIgnored&#x3D;&quot;true&quot; %&gt;    isELIgnored&#x3D;&quot;true&quot; 表示忽略EL表达式    isELIgnored&#x3D;&quot;false&quot; 表示不忽略EL表达式。（这是默认值）        isELIgnored&#x3D;&quot;true&quot; 这个是全局的控制。        可以使用反斜杠进行局部控制：\$&#123;username&#125; 这样也可以忽略EL表达式。</code></pre></code></pre></li><li><p>通过EL表达式获取应用的根：</p><ul><li>${pageContext.request.contextPath}</li></ul></li><li><p>EL表达式中其他的隐式对象：</p><ul><li>pageContext</li><li>param</li><li>paramValues</li><li>initParam</li></ul></li><li><p>EL表达式的运算符</p><ul><li>算术运算符<ul><li>+、-、*、&#x2F;、%</li></ul></li><li>关系运算符<ul><li><input disabled="" type="checkbox"> &#x3D;&#x3D; eq !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</li></ul></li><li>逻辑运算符<ul><li><input disabled="" type="checkbox"> !  &amp;&amp; ||  not and or</li></ul></li><li>条件运算符<ul><li><input disabled="" type="checkbox"> ? :</li></ul></li><li>取值运算符<ul><li>[ ]和.</li></ul></li><li>empty运算符<ul><li><input disabled="" type="checkbox"> empty运算符的结果是boolean类型</li><li><input disabled="" type="checkbox"> ${empty param.username}</li><li><input disabled="" type="checkbox"> ${not empty param.username}</li><li><input disabled="" type="checkbox"> ${!empty param.password}</li></ul></li></ul></li></ul></li></ul><h1 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h1><ul><li><p>什么是JSTL标签库？</p><ul><li>Java Standard Tag Lib（Java标准的标签库）</li><li>JSTL标签库通常结合EL表达式一起使用。目的是让JSP中的java代码消失。</li><li>标签是写在JSP当中的，但实际上最终还是要执行对应的java程序。（java程序在jar包当中。）</li></ul></li><li><p>使用JSTL标签库的步骤：</p><ul><li><p>第一步：引入JSTL标签库对应的jar包。</p><ul><li>tomcat10之后引入的jar包是：<ul><li>jakarta.servlet.jsp.jstl-2.0.0.jar</li><li>jakarta.servlet.jsp.jstl-api-2.0.0.jar</li></ul></li><li>在IDEA当中怎么引入？<ul><li>在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其“Add Lib…”</li><li>一定是要和mysql的数据库驱动一样，都是放在WEB-INF&#x2F;lib目录下的。</li><li>什么时候需要将jar包放到WEB-INF&#x2F;lib目录下？如果这个jar是tomcat服务器没有的。</li></ul></li></ul></li><li><p>第二步：在JSP中引入要使用标签库。（使用taglib指令引入标签库。）</p><ul><li><p>JSTL提供了很多种标签，你要引入哪个标签？？？？重点掌握核心标签库。</p></li><li><p>&#96;&#96;&#96;<br>&lt;%@taglib prefix&#x3D;”c” uri&#x3D;”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;<br>这个就是核心标签库。<br>prefix&#x3D;”这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。”</p><pre class="line-numbers language-none"><code class="language-none">    - 第三步：在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。  - JSTL标签的原理  - &#96;&#96;&#96;    &lt;%@taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;    以上uri后面的路径实际上指向了一个xxx.tld文件。    tld文件实际上是一个xml配置文件。    在tld文件中描述了“标签”和“java类”之间的关系。    以上核心标签库对应的tld文件是：c.tld文件。它在哪里。    在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下，有一个c.tld文件。</code></pre></li></ul></li><li><p>源码解析：配置文件tld解析</p><ul><li>&#96;&#96;&#96;<tag>    <description>对该标签的描述</description>    <name>catch</name> 标签的名字    <tag-class>org.apache.taglibs.standard.tag.common.core.CatchTag</tag-class> 标签对应的java类。    <body-content>JSP</body-content> 标签体当中可以出现的内容，如果是JSP，就表示标签体中可以出现符合JSP所有语法的代码。例如EL表达式。    <attribute>        <description>            对这个属性的描述        </description>        <name>var</name> 属性名        <required>false</required> false表示该属性不是必须的。true表示该属性是必须的。        <rtexprvalue>false</rtexprvalue> 这个描述说明了该属性是否支持EL表达式。false表示不支持。true表示支持EL表达式。    </attribute>  </tag>&lt;c:catch var&#x3D;””&gt;<br>JSP….<br></c:catch><pre class="line-numbers language-none"><code class="language-none">  - jstl中的核心标签库core当中有哪些常用的标签呢？  - c:if    - &lt;c:if test&#x3D;&quot;boolean类型，支持EL表达式&quot;&gt;&lt;&#x2F;c: if&gt;  - c:forEach    - &lt;c:forEach items&#x3D;&quot;集合，支持EL表达式&quot; var&#x3D;&quot;集合中的元素&quot; varStatus&#x3D;&quot;元素状态对象&quot;&gt; $&#123;元素状态对象.count&#125; &lt;&#x2F;c: forEach&gt;    - &lt;c:forEach var&#x3D;&quot;i&quot; begin&#x3D;&quot;1&quot; end&#x3D;&quot;10&quot; step&#x3D;&quot;2&quot;&gt; $&#123;i&#125; &lt;&#x2F;c: forEach&gt;  - c:choose c:when c:otherwise    - &#96;&#96;&#96;      &lt;c:choose&gt;          &lt;c:when test&#x3D;&quot;$&#123;param.age &lt; 18&#125;&quot;&gt;              青少年          &lt;&#x2F;c:when&gt;          &lt;c:when test&#x3D;&quot;$&#123;param.age &lt; 35&#125;&quot;&gt;              青年          &lt;&#x2F;c:when&gt;          &lt;c:when test&#x3D;&quot;$&#123;param.age &lt; 55&#125;&quot;&gt;              中年          &lt;&#x2F;c:when&gt;          &lt;c:otherwise&gt;              老年          &lt;&#x2F;c:otherwise&gt;      &lt;&#x2F;c:choose&gt;</code></pre></li></ul></li></ul></li></ul><h2 id="改造OA"><a href="#改造OA" class="headerlink" title="改造OA"></a>改造OA</h2><ul><li><p>使用什么技术改造呢？</p><ul><li>Servlet + JSP + EL表达式 + JSTL标签。进行改造。</li></ul></li><li><p>在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。</p><ul><li><p>这是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。</p></li><li><p>&lt; base href&#x3D;”<a href="http://localhost:8080/oa/&quot;&gt;">http://localhost:8080/oa/&quot;&gt;</a></p></li><li><p>在当前页面中，凡是路径没有以“&#x2F;”开始的，都会自动将base中的路径添加到这些路径之前。</p><ul><li>&lt; a href&#x3D;”ab&#x2F;def”&gt;&lt;&#x2F; a&gt;</li><li>等同于：&lt; a href&#x3D;”<a href="http://localhost:8080/oa/ab/def&quot;&gt;">http://localhost:8080/oa/ab/def&quot;&gt;</a>&lt;&#x2F; a&gt;</li></ul></li><li><p>需要注意：在JS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。</p></li><li><p>&#96;&#96;&#96;</p><base href="${pageContext.request.scheme}://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/"><pre class="line-numbers language-none"><code class="language-none"># Filter过滤器- 当前的OA项目存在什么缺陷？  - DeptServlet、EmpServlet、OrderServlet。每一个Servlet都是处理自己相关的业务。在这些Servlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Servlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题?    - 可以使用Servlet规范中的Filter过滤器来解决这个问题。  - Filter是什么，有什么用，执行原理是什么？  - Filter是过滤器。  - Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Servlet执行之后添加代码。之前之后都可以添加过滤规则。  - 一般情况下，都是在过滤器当中编写公共代码。  - 一个过滤器怎么写呢？  - 第一步：编写一个Java类实现一个接口：jarkata.servlet.Filter。并且实现这个接口当中所有的方法。    - init方法：在Filter对象第一次被创建之后调用，并且只调用一次。    - doFilter方法：只要用户发送一次请求，则执行一次。发送N次请求，则执行N次。在这个方法中编写过滤规则。    - destroy方法：在Filter对象被释放&#x2F;销毁之前调用，并且只调用一次。  - 第二步：在web.xml文件中对Filter进行配置。这个配置和Servlet很像。    - &#96;&#96;&#96;      &lt;filter&gt;          &lt;filter-name&gt;filter2&lt;&#x2F;filter-name&gt;          &lt;filter-class&gt;com.bjpowernode.javaweb.servlet.Filter2&lt;&#x2F;filter-class&gt;      &lt;&#x2F;filter&gt;      &lt;filter-mapping&gt;          &lt;filter-name&gt;filter2&lt;&#x2F;filter-name&gt;          &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;      &lt;&#x2F;filter-mapping&gt;</code></pre><ul><li>或者使用注解：@WebFilter({“*.do”})</li></ul></li></ul></li><li><p>注意：</p><ul><li>Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。</li><li>Filter对象默认情况下，在服务器启动的时候会新建对象。</li><li>Servlet是单例的。Filter也是单例的。（单实例。）</li></ul></li><li><p>目标Servlet是否执行，取决于两个条件：</p><ul><li>第一：在过滤器当中是否编写了：chain.doFilter(request, response); 代码。</li><li>第二：用户发送的请求路径是否和Servlet的请求路径一致。</li></ul></li><li><p>chain.doFilter(request, response); 这行代码的作用：</p><ul><li>执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。</li></ul></li><li><p>注意：Filter的优先级，天生的就比Servlet优先级高。</p><ul><li>&#x2F;a.do 对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Servlet。</li></ul></li><li><p>关于Filter的配置路径：</p><ul><li>&#x2F;a.do、&#x2F;b.do、&#x2F;dept&#x2F;save。这些配置方式都是精确匹配。</li><li>&#x2F;* 匹配所有路径。</li><li>*.do 后缀匹配。不要以 &#x2F; 开始</li><li>&#x2F;dept&#x2F;*  前缀匹配。</li></ul></li><li><p>在web.xml文件中进行配置的时候，Filter的执行顺序是什么？</p><ul><li>依靠filter-mapping标签的配置位置，越靠上优先级越高。</li></ul></li><li><p>过滤器的调用顺序，遵循栈数据结构。</p></li><li><p>使用@WebFilter的时候，Filter的执行顺序是怎样的呢？</p><ul><li>执行顺序是：比较Filter这个类名。</li><li>比如：FilterA和FilterB，则先执行FilterA。</li><li>比如：Filter1和Filter2，则先执行Filter1.</li></ul></li><li><p>Filter的生命周期？</p><ul><li>和Servlet对象生命周期一致。</li><li>唯一的区别：Filter默认情况下，在服务器启动阶段就实例化。Servlet不会。</li></ul></li><li><p>Filter过滤器这里有一个设计模式：</p><ul><li>责任链设计模式。</li><li>过滤器最大的优点：<ul><li>在程序编译阶段不会确定调用顺序。因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中filter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。</li></ul></li><li>责任链设计模式最大的核心思想：<ul><li>在程序运行阶段，动态的组合程序的调用顺序。</li></ul></li></ul></li><li><p>使用过滤器改造OA项目。</p></li></ul><h1 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h1><ul><li><p>什么是监听器？</p><ul><li>监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。</li><li>在Servlet中，所有的监听器接口都是以“Listener”结尾。</li></ul></li><li><p>监听器有什么用？</p><ul><li>监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机。</li><li>特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。</li></ul></li><li><p>Servlet规范中提供了哪些监听器？</p><ul><li>jakarta.servlet包下：<ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li></ul></li><li>jakarta.servlet.http包下：<ul><li>HttpSessionListener</li><li>HttpSessionAttributeListener<ul><li>该监听器需要使用@WebListener注解进行标注。</li><li>该监听器监听的是什么？是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。</li></ul></li><li>HttpSessionBindingListener<ul><li>该监听器不需要使用@WebListener进行标注。</li><li>假设User类实现了该监听器，那么User对象在被放入session的时候触发bind事件，User对象从session中删除的时候，触发unbind事件。</li><li>假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。</li></ul></li><li>HttpSessionIdListener<ul><li>session的id发生改变的时候，监听器中的唯一一个方法就会被调用。</li></ul></li><li>HttpSessionActivationListener<ul><li>监听session对象的钝化和活化的。</li><li>钝化：session对象从内存存储到硬盘文件。</li><li>活化：从硬盘文件把session恢复到内存。</li></ul></li></ul></li></ul></li><li><p>实现一个监听器的步骤：以ServletContextListener为例。</p><ul><li><p>第一步：编写一个类实现ServletContextListener接口。并且实现里面的方法。</p><ul><li><pre><code>void contextInitialized(ServletContextEvent event)void contextDestroyed(ServletContextEvent event)<pre class="line-numbers language-none"><code class="language-none">- 第二步：在web.xml文件中对ServletContextListener进行配置，如下：  - &#96;&#96;&#96;    &lt;listener&gt;        &lt;listener-class&gt;com.bjpowernode.javaweb.listener.MyServletContextListener&lt;&#x2F;listener-class&gt;    &lt;&#x2F;listener&gt;</code></pre></code></pre></li><li><p>当然，第二步也可以不使用配置文件，也可以用注解，例如：@WebListener</p></li></ul></li></ul></li><li><p>注意：所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用？什么时候被调用呢？</p><ul><li>当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。</li></ul></li><li><p>思考一个业务场景：</p><ul><li>请编写一个功能，记录该网站实时的在线用户的个数。</li><li>我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话，session有多少个，在线用户就有多少个。这种方式的话：HttpSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。</li><li>业务发生改变了，只统计登录的用户的在线数量，这个该怎么办？<ul><li>session.setAttribute(“user”, userObj); </li><li>用户登录的标志是什么？session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现HttpSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到ServletContext对象中。页面展示在线人数即可。</li></ul></li></ul></li><li><p>实现oa项目中当前登录在线的人数。</p><ul><li>什么代表着用户登录了？<ul><li>session.setAttribute(“user”, userObj); User类型的对象只要往session中存储过，表示有新用户登录。</li></ul></li><li>什么代表着用户退出了？<ul><li>session.removeAttribute(“user”); User类型的对象从session域中移除了。</li><li>或者有可能是session销毁了。（session超时）</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
